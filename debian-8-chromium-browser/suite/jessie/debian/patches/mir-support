Description: Add Mir support
Origin: https://github.com/racarr-ubuntu/ozone-mir
Author: Robert Carr, Chad Miller
X-rev-id: 166346ab7a00e8dbd23a9f32ddb5741ad5afb41f

--- a/chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc
+++ b/chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc
@@ -26,7 +26,7 @@
 #include "ui/events/event_switches.h"
 #include "ui/gfx/screen.h"
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && 0
 #include <gnu/libc-version.h>
 
 #include "base/version.h"
@@ -116,7 +116,7 @@ void RecordStartupMetricsOnBlockingPool(
 }
 
 void RecordLinuxGlibcVersion() {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && 0
   Version version(gnu_get_libc_version());
 
   UMALinuxGlibcVersion glibc_version_result = UMA_LINUX_GLIBC_NOT_PARSEABLE;
@@ -140,7 +140,7 @@ void RecordLinuxGlibcVersion() {
 #endif
 }
 
-#if defined(USE_X11) && !defined(OS_CHROMEOS)
+#if defined(USE_X11) && !defined(OS_CHROMEOS) && 0
 UMALinuxWindowManager GetLinuxWindowManager() {
   switch (ui::GuessWindowManager()) {
     case ui::WM_UNKNOWN:
@@ -239,7 +239,7 @@ void ChromeBrowserMainExtraPartsMetrics:
 
 void ChromeBrowserMainExtraPartsMetrics::PostBrowserStart() {
   RecordLinuxGlibcVersion();
-#if defined(USE_X11) && !defined(OS_CHROMEOS)
+#if defined(USE_X11) && !defined(OS_CHROMEOS) && 0
   UMA_HISTOGRAM_ENUMERATION("Linux.WindowManager",
                             GetLinuxWindowManager(),
                             UMA_LINUX_WINDOW_MANAGER_COUNT);
--- a/chrome/browser/ui/aura/active_desktop_monitor.cc
+++ b/chrome/browser/ui/aura/active_desktop_monitor.cc
@@ -11,6 +11,8 @@
 #include "ui/views/widget/desktop_aura/desktop_window_tree_host_x11.h"
 #elif defined(OS_WIN)
 #include "ui/views/widget/desktop_aura/desktop_window_tree_host_win.h"
+#elif defined(USE_OZONE)
+#include "ozone/ui/desktop_aura/desktop_window_tree_host_wayland.h"
 #endif
 
 // static
@@ -48,6 +50,10 @@ bool ActiveDesktopMonitor::IsDesktopWind
 #elif defined(USE_X11)
   return views::DesktopWindowTreeHostX11::GetContentWindowForXID(
       host->GetAcceleratedWidget()) != NULL;
+#elif defined(USE_OZONE)
+  return views::DesktopWindowTreeHostWayland::
+      GetContentWindowForAcceleratedWidget(
+          host->GetAcceleratedWidget()) != NULL;
 #else
   NOTREACHED();
   return true;
--- /dev/null
+++ b/chrome/browser/ui/views/frame/browser_desktop_root_window_host_ozone.cc
@@ -0,0 +1,55 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/ui/views/frame/browser_desktop_root_window_host_ozone.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// BrowserDesktopWindowTreeHostOzone, public:
+
+BrowserDesktopWindowTreeHostOzone::BrowserDesktopWindowTreeHostOzone(
+    views::internal::NativeWidgetDelegate* native_widget_delegate,
+    views::DesktopNativeWidgetAura* desktop_native_widget_aura,
+    BrowserView* browser_view)
+      : browser_view_(browser_view),
+      desktop_root_window_host_(NULL) {
+  desktop_root_window_host_ = views::DesktopWindowTreeHost::Create(
+      native_widget_delegate,
+      desktop_native_widget_aura);
+}
+
+BrowserDesktopWindowTreeHostOzone::~BrowserDesktopWindowTreeHostOzone() {
+  desktop_root_window_host_ = NULL;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// BrowserDesktopWindowTreeHostOzone,
+//     BrowserDesktopWindowTreeHost implementation:
+
+views::DesktopWindowTreeHost*
+    BrowserDesktopWindowTreeHostOzone::AsDesktopWindowTreeHost() {
+  return desktop_root_window_host_;
+}
+
+int BrowserDesktopWindowTreeHostOzone::GetMinimizeButtonOffset() const {
+  return 0;
+}
+
+bool BrowserDesktopWindowTreeHostOzone::UsesNativeSystemMenu() const {
+  return false;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// BrowserDesktopWindowTreeHost, public:
+
+// static
+BrowserDesktopWindowTreeHost*
+    BrowserDesktopWindowTreeHost::CreateBrowserDesktopWindowTreeHost(
+        views::internal::NativeWidgetDelegate* native_widget_delegate,
+        views::DesktopNativeWidgetAura* desktop_native_widget_aura,
+        BrowserView* browser_view,
+        BrowserFrame* browser_frame) {
+  return new BrowserDesktopWindowTreeHostOzone(native_widget_delegate,
+                                               desktop_native_widget_aura,
+                                               browser_view);
+}
--- /dev/null
+++ b/chrome/browser/ui/views/frame/browser_desktop_root_window_host_ozone.h
@@ -0,0 +1,42 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_UI_VIEWS_FRAME_BROWSER_DESKTOP_ROOT_WINDOW_HOST_OZONE_H_
+#define CHROME_BROWSER_UI_VIEWS_FRAME_BROWSER_DESKTOP_ROOT_WINDOW_HOST_OZONE_H_
+
+#include "ui/aura/window_tree_host.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host.h"
+#include "chrome/browser/ui/views/frame/browser_desktop_window_tree_host.h"
+
+class BrowserFrame;
+class BrowserView;
+
+namespace views {
+class DesktopNativeWidgetAura;
+}
+
+class BrowserDesktopWindowTreeHostOzone
+    : public BrowserDesktopWindowTreeHost {
+ public:
+  BrowserDesktopWindowTreeHostOzone(
+      views::internal::NativeWidgetDelegate* native_widget_delegate,
+      views::DesktopNativeWidgetAura* desktop_native_widget_aura,
+      BrowserView* browser_view);
+  virtual ~BrowserDesktopWindowTreeHostOzone();
+
+ private:
+  // Overridden from BrowserDesktopWindowTreeHost:
+  virtual views::DesktopWindowTreeHost* AsDesktopWindowTreeHost() OVERRIDE;
+  virtual int GetMinimizeButtonOffset() const OVERRIDE;
+  virtual bool UsesNativeSystemMenu() const OVERRIDE;
+
+  BrowserView* browser_view_;
+
+  // Ownership passed to RootWindow on Init.
+  views::DesktopWindowTreeHost* desktop_root_window_host_;
+
+  DISALLOW_COPY_AND_ASSIGN(BrowserDesktopWindowTreeHostOzone);
+};
+
+#endif  // CHROME_BROWSER_UI_VIEWS_FRAME_BROWSER_DESKTOP_ROOT_WINDOW_HOST_OZONE_H_
--- a/chrome/chrome_browser_ui.gypi
+++ b/chrome/chrome_browser_ui.gypi
@@ -1357,6 +1357,8 @@
       'browser/ui/views/first_run_dialog.cc',
       'browser/ui/views/first_run_dialog.h',
       'browser/ui/views/frame/browser_desktop_window_tree_host.h',
+      'browser/ui/views/frame/browser_desktop_root_window_host_ozone.cc',
+      'browser/ui/views/frame/browser_desktop_root_window_host_ozone.h',
       'browser/ui/views/frame/browser_desktop_window_tree_host_x11.cc',
       'browser/ui/views/frame/browser_desktop_window_tree_host_x11.h',
       'browser/ui/views/frame/desktop_browser_frame_auralinux.cc',
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -137,6 +137,10 @@
 #include "ui/gfx/x/x11_types.h"
 #endif
 
+#if defined(USE_OZONE)
+#include "ozone/content/ozone_channel_host_factory.h"
+#endif
+
 // One of the linux specific headers defines this as a macro.
 #ifdef DestroyAll
 #undef DestroyAll
@@ -983,6 +987,11 @@ void BrowserMainLoop::ShutdownThreadsAnd
     TRACE_EVENT0("shutdown", "BrowserMainLoop::Subsystem:GPUChannelFactory");
     if (BrowserGpuChannelHostFactory::instance())
       BrowserGpuChannelHostFactory::Terminate();
+
+#if defined(USE_OZONE)
+    if (OzoneChannelHostFactory::instance())
+      OzoneChannelHostFactory::Terminate();
+#endif
   }
 
   // Must happen after the I/O thread is shutdown since this class lives on the
@@ -1179,6 +1188,13 @@ int BrowserMainLoop::BrowserThreadsStart
   }
 #endif  // defined(OS_MACOSX)
 
+#if defined(USE_OZONE)
+  bool using_gpu_process =
+      !parsed_command_line_.HasSwitch(switches::kSingleProcess) &&
++      !parsed_command_line_.HasSwitch(switches::kInProcessGPU);
+  OzoneChannelHostFactory::Initialize(using_gpu_process);
+#endif  // defined(USE_OZONE)
+
 #endif  // !defined(OS_IOS)
 
   return result_code_;
--- a/content/content_common.gypi
+++ b/content/content_common.gypi
@@ -951,6 +951,25 @@
         },
      ]
     }],
+    ['use_ozone == 1', {
+      'sources': [
+        '<(DEPTH)/ozone/content/event_converter_in_process.h',
+        '<(DEPTH)/ozone/content/event_converter_in_process.cc',
+        '<(DEPTH)/ozone/content/messages.h',
+        '<(DEPTH)/ozone/content/message_generator.h',
+        '<(DEPTH)/ozone/content/message_generator.cc',
+        '<(DEPTH)/ozone/content/ozone_channel.h',
+        '<(DEPTH)/ozone/content/ozone_channel.cc',
+        '<(DEPTH)/ozone/content/ozone_channel_host.h',
+        '<(DEPTH)/ozone/content/ozone_channel_host.cc',
+        '<(DEPTH)/ozone/content/ozone_channel_host_factory.h',
+        '<(DEPTH)/ozone/content/ozone_channel_host_factory.cc',
+        '<(DEPTH)/ozone/content/remote_event_dispatcher.h',
+        '<(DEPTH)/ozone/content/remote_event_dispatcher.cc',
+        '<(DEPTH)/ozone/content/remote_state_change_handler.h',
+        '<(DEPTH)/ozone/content/remote_state_change_handler.cc',
+      ],
+    }],
     ['OS=="win"', {
       'dependencies': [
         '../media/media.gyp:media',
--- a/content/gpu/gpu_main.cc
+++ b/content/gpu/gpu_main.cc
@@ -65,6 +65,10 @@
 #include <sanitizer/coverage_interface.h>
 #endif
 
+#if defined(USE_OZONE)
+#include "ozone/content/ozone_channel.h"
+#endif
+
 const int kGpuTimeout = 10000;
 
 namespace content {
@@ -362,6 +366,11 @@ int GpuMain(const MainFunctionParams& pa
 
   {
     TRACE_EVENT0("gpu", "Run Message Loop");
+
+#if defined(USE_OZONE)
+    OzoneChannel channel;
+    channel.Register();
+#endif
     main_message_loop.Run();
   }
 
--- a/media/ozone/media_ozone_platform.cc
+++ b/media/ozone/media_ozone_platform.cc
@@ -44,6 +44,14 @@ MediaOzonePlatform* CreateMediaOzonePlat
   return new MediaOzonePlatformStub;
 }
 
+MediaOzonePlatform* CreateMediaOzonePlatformMir() {
+  return new MediaOzonePlatformStub;
+}
+
+MediaOzonePlatform* CreateMediaOzonePlatformWayland() {
+  return new MediaOzonePlatformStub;
+}
+
 MediaOzonePlatform* CreateMediaOzonePlatformGbm() {
   return new MediaOzonePlatformStub;
 }
--- /dev/null
+++ b/ozone/content/DEPS
@@ -0,0 +1,9 @@
+include_rules = [
+  "+content/public/common",
+  "+ipc/",
+  "-ozone/ui/desktop_aura",
+  "+ozone/ui/events",
+  "-ozone/wayland/",
+  "+ui/events",
+  "-ui/views",
+]
--- /dev/null
+++ b/ozone/content/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/content/event_converter_in_process.cc
@@ -0,0 +1,264 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/content/event_converter_in_process.h"
+
+#include <string>
+
+#include "base/bind.h"
+#include "ozone/ui/events/output_change_observer.h"
+#include "ozone/ui/events/window_change_observer.h"
+
+namespace content {
+
+EventConverterInProcess::EventConverterInProcess()
+    : EventConverterOzoneWayland(),
+      observer_(NULL),
+      output_observer_(NULL) {
+}
+
+EventConverterInProcess::~EventConverterInProcess() {
+}
+
+void EventConverterInProcess::MotionNotify(float x, float y) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyMotion, this, x, y));
+}
+
+void EventConverterInProcess::ButtonNotify(unsigned handle,
+                                           ui::EventType type,
+                                           ui::EventFlags flags,
+                                           float x,
+                                           float y) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyButtonPress, this, handle, type,
+          flags, x, y));
+}
+
+void EventConverterInProcess::AxisNotify(float x,
+                                         float y,
+                                         int xoffset,
+                                         int yoffset) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyAxis, this, x, y, xoffset, yoffset));
+}
+
+void EventConverterInProcess::PointerEnter(unsigned handle,
+                                           float x,
+                                           float y) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyPointerEnter, this, handle, x, y));
+}
+
+void EventConverterInProcess::PointerLeave(unsigned handle,
+                                           float x,
+                                           float y) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyPointerLeave, this, handle, x, y));
+}
+
+void EventConverterInProcess::KeyNotify(ui::EventType type,
+                                        unsigned code,
+                                        unsigned modifiers) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyKeyEvent, this, type,
+          ui::KeyboardCodeFromNativeKeysym(code),
+              ui::CharacterCodeFromNativeKeySym(code, modifiers), modifiers));
+}
+
+void EventConverterInProcess::TouchNotify(ui::EventType type,
+                                          float x,
+                                          float y,
+                                          int32_t touch_id,
+                                          uint32_t time_stamp) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyTouchEvent, this, type, x, y, touch_id,
+          time_stamp));
+}
+
+void EventConverterInProcess::CloseWidget(unsigned handle) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyCloseWidget, this, handle));
+}
+
+void EventConverterInProcess::OutputSizeChanged(unsigned width,
+                                                unsigned height) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyOutputSizeChanged, this, width, height));
+}
+
+void EventConverterInProcess::WindowResized(unsigned handle,
+                                            unsigned width,
+                                            unsigned height) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyWindowResized, this, handle, width,
+          height));
+}
+
+void EventConverterInProcess::Commit(unsigned handle, const std::string& text) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyCommit, this, handle, text));
+}
+
+void EventConverterInProcess::PreeditChanged(unsigned handle,
+                                             const std::string& text,
+                                             const std::string& commit) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &EventConverterInProcess::NotifyPreeditChanged, this, handle, text,
+      commit));
+}
+
+void EventConverterInProcess::PreeditEnd() {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+        &EventConverterInProcess::NotifyPreeditEnd, this));
+}
+
+void EventConverterInProcess::PreeditStart() {
+    ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+        &EventConverterInProcess::NotifyPreeditStart, this));
+}
+
+void EventConverterInProcess::SetWindowChangeObserver(
+    ui::WindowChangeObserver* observer) {
+  observer_ = observer;
+}
+
+void EventConverterInProcess::SetOutputChangeObserver(
+    ui::OutputChangeObserver* observer) {
+  output_observer_ = observer;
+}
+
+void EventConverterInProcess::NotifyMotion(EventConverterInProcess* data,
+                                           float x,
+                                           float y) {
+  gfx::Point position(x, y);
+  ui::MouseEvent mouseev(ui::ET_MOUSE_MOVED,
+                         position,
+                         position,
+                         0,
+                         0);
+  data->DispatchEvent(&mouseev);
+}
+
+void EventConverterInProcess::NotifyButtonPress(EventConverterInProcess* data,
+                                                unsigned handle,
+                                                ui::EventType type,
+                                                ui::EventFlags flags,
+                                                float x,
+                                                float y) {
+    gfx::Point position(x, y);
+    ui::MouseEvent mouseev(type,
+                           position,
+                           position,
+                           flags,
+                           1);
+    data->DispatchEvent(&mouseev);
+
+    if (type == ui::ET_MOUSE_RELEASED && data->observer_)
+      data->observer_->OnWindowFocused(handle);
+}
+
+void EventConverterInProcess::NotifyAxis(EventConverterInProcess* data,
+                                         float x,
+                                         float y,
+                                         int xoffset,
+                                         int yoffset) {
+  gfx::Point position(x, y);
+  ui::MouseEvent mouseev(ui::ET_MOUSEWHEEL, position, position, 0, 0);
+  ui::MouseWheelEvent wheelev(mouseev, xoffset, yoffset);
+
+  data->DispatchEvent(&wheelev);
+}
+
+void EventConverterInProcess::NotifyPointerEnter(
+    EventConverterInProcess* data, unsigned handle, float x, float y) {
+  if (data->observer_)
+    data->observer_->OnWindowEnter(handle);
+
+  gfx::Point position(x, y);
+  ui::MouseEvent mouseev(ui::ET_MOUSE_ENTERED, position, position, 0, 0);
+  data->DispatchEvent(&mouseev);
+}
+
+void EventConverterInProcess::NotifyPointerLeave(
+    EventConverterInProcess* data, unsigned handle, float x, float y) {
+  if (data->observer_)
+    data->observer_->OnWindowLeave(handle);
+
+  gfx::Point position(x, y);
+  ui::MouseEvent mouseev(ui::ET_MOUSE_EXITED, position, position, 0, 0);
+  data->DispatchEvent(&mouseev);
+}
+
+void EventConverterInProcess::NotifyKeyEvent(EventConverterInProcess* data,
+                                             ui::EventType type,
+                                             ui::KeyboardCode code,
+                                             uint16 CharacterCodeFromNativeKey,
+                                             unsigned modifiers) {
+  //ui::KeyEvent keyev(type, modifiers, ?, ?, code);  // FIXME(chad): WTF strings  chrome/test/chromedriver/chrome/ui_events.cc
+  //keyev.set_character(CharacterCodeFromNativeKey);
+  //data->DispatchEvent(&keyev);
+}
+
+void EventConverterInProcess::NotifyTouchEvent(EventConverterInProcess* data,
+                                               ui::EventType type,
+                                               float x,
+                                               float y,
+                                               int32_t touch_id,
+                                               uint32_t time_stamp) {
+  gfx::Point position(x, y);
+  base::TimeDelta time_delta = base::TimeDelta::FromMilliseconds(time_stamp);
+  ui::TouchEvent touchev(type, position, touch_id, time_delta);
+  data->DispatchEvent(&touchev);
+}
+
+void EventConverterInProcess::NotifyCloseWidget(
+    EventConverterInProcess* data, unsigned handle) {
+  if (data->observer_)
+    data->observer_->OnWindowClose(handle);
+}
+
+void
+EventConverterInProcess::NotifyOutputSizeChanged(EventConverterInProcess* data,
+                                                 unsigned width,
+                                                 unsigned height) {
+  if (data->output_observer_)
+    data->output_observer_->OnOutputSizeChanged(width, height);
+}
+
+void
+EventConverterInProcess::NotifyWindowResized(EventConverterInProcess* data,
+                                             unsigned handle,
+                                             unsigned width,
+                                             unsigned height) {
+  if (data->observer_)
+    data->observer_->OnWindowResized(handle, width, height);
+}
+
+void
+EventConverterInProcess::NotifyCommit(EventConverterInProcess* data,
+                                      unsigned handle,
+                                      const std::string& text) {
+  if (data->observer_)
+    data->observer_->OnCommit(handle, text);
+}
+
+void
+EventConverterInProcess::NotifyPreeditChanged(EventConverterInProcess* data,
+                                              unsigned handle,
+                                              const std::string& text,
+                                              const std::string& commit) {
+  if (data->observer_)
+    data->observer_->OnPreeditChanged(handle, text, commit);
+}
+
+void
+EventConverterInProcess::NotifyPreeditEnd(EventConverterInProcess* data) {
+}
+
+void
+EventConverterInProcess::NotifyPreeditStart(EventConverterInProcess* data) {
+}
+
+}  // namespace content
--- /dev/null
+++ b/ozone/content/event_converter_in_process.h
@@ -0,0 +1,123 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_CONTENT_CONVERTER_IN_PROCESS_H_
+#define OZONE_CONTENT_CONVERTER_IN_PROCESS_H_
+
+#include <string>
+
+#include "base/memory/scoped_ptr.h"
+#include "ozone/ui/events/event_converter_ozone_wayland.h"
+#include "ozone/ui/events/keyboard_code_conversion_ozone.h"
+#include "ui/events/event.h"
+#include "ui/events/platform/platform_event_source.h"
+
+namespace content {
+
+class EventConverterInProcess : public ui::EventConverterOzoneWayland,
+                                public ui::PlatformEventSource {
+ public:
+  EventConverterInProcess();
+  virtual ~EventConverterInProcess();
+
+  virtual void MotionNotify(float x, float y) override;
+  virtual void ButtonNotify(unsigned handle,
+                            ui::EventType type,
+                            ui::EventFlags flags,
+                            float x,
+                            float y) override;
+  virtual void AxisNotify(float x,
+                          float y,
+                          int xoffset,
+                          int yoffset) override;
+  virtual void PointerEnter(unsigned handle, float x, float y) override;
+  virtual void PointerLeave(unsigned handle, float x, float y) override;
+  virtual void KeyNotify(ui::EventType type,
+                         unsigned code,
+                         unsigned modifiers) override;
+  virtual void TouchNotify(ui::EventType type,
+                           float x,
+                           float y,
+                           int32_t touch_id,
+                           uint32_t time_stamp) override;
+  virtual void CloseWidget(unsigned handle) override;
+
+  virtual void OutputSizeChanged(unsigned width, unsigned height) override;
+  virtual void WindowResized(unsigned windowhandle,
+                             unsigned width,
+                             unsigned height) override;
+
+  virtual void Commit(unsigned handle, const std::string& text) override;
+  virtual void PreeditChanged(unsigned handle, const std::string& text,
+                              const std::string& commit) override;
+  virtual void PreeditEnd() override;
+  virtual void PreeditStart() override;
+
+  virtual void SetWindowChangeObserver(
+      ui::WindowChangeObserver* observer) override;
+  virtual void SetOutputChangeObserver(
+      ui::OutputChangeObserver* observer) override;
+
+ private:
+  static void NotifyMotion(EventConverterInProcess* data,
+                           float x,
+                           float y);
+  static void NotifyButtonPress(EventConverterInProcess* data,
+                                unsigned handle,
+                                ui::EventType type,
+                                ui::EventFlags flags,
+                                float x,
+                                float y);
+  static void NotifyAxis(EventConverterInProcess* data,
+                         float x,
+                         float y,
+                         int xoffset,
+                         int yoffset);
+  static void NotifyPointerEnter(EventConverterInProcess* data,
+                                 unsigned handle,
+                                 float x,
+                                 float y);
+  static void NotifyPointerLeave(EventConverterInProcess* data,
+                                 unsigned handle,
+                                 float x,
+                                 float y);
+  static void NotifyKeyEvent(EventConverterInProcess* data,
+                             ui::EventType type,
+                             ui::KeyboardCode code,
+                             uint16 CharacterCodeFromNativeKey,
+                             unsigned modifiers);
+  static void NotifyTouchEvent(EventConverterInProcess* data,
+                               ui::EventType type,
+                               float x,
+                               float y,
+                               int32_t touch_id,
+                               uint32_t time_stamp);
+  static void NotifyCloseWidget(EventConverterInProcess* data,
+                                unsigned handle);
+  static void NotifyOutputSizeChanged(EventConverterInProcess* data,
+                                      unsigned width,
+                                      unsigned height);
+  static void NotifyWindowResized(EventConverterInProcess* data,
+                                  unsigned handle,
+                                  unsigned width,
+                                  unsigned height);
+  static void NotifyCommit(EventConverterInProcess* data, unsigned handle,
+                           const std::string& text);
+  static void NotifyPreeditChanged(EventConverterInProcess* data,
+                                   unsigned handle,
+                                   const std::string& text,
+                                   const std::string& commit);
+  static void NotifyPreeditEnd(EventConverterInProcess* data);
+  static void NotifyPreeditStart(EventConverterInProcess* data);
+
+  ui::WindowChangeObserver* observer_;
+  ui::OutputChangeObserver* output_observer_;
+  base::Callback<void(void*)> dispatch_callback_;  // NOLINT(readability/
+                                                   // function)
+  DISALLOW_COPY_AND_ASSIGN(EventConverterInProcess);
+};
+
+}  // namespace content
+
+#endif  // OZONE_CONTENT_CONVERTER_IN_PROCESS_H_
--- /dev/null
+++ b/ozone/content/message_generator.cc
@@ -0,0 +1,33 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Get basic type definitions.
+#define IPC_MESSAGE_IMPL
+#include "ozone/content/message_generator.h"
+
+// Generate constructors.
+#include "ipc/struct_constructor_macros.h"
+#include "ozone/content/message_generator.h"  // NOLINT(build/include)
+
+// Generate destructors.
+#include "ipc/struct_destructor_macros.h"
+#include "ozone/content/message_generator.h"  // NOLINT(build/include)
+
+// Generate param traits write methods.
+#include "ipc/param_traits_write_macros.h"  // NOLINT(build/include_alpha)
+namespace IPC {
+#include "ozone/content/message_generator.h"  // NOLINT(build/include)
+}  // namespace IPC
+
+// Generate param traits read methods.
+#include "ipc/param_traits_read_macros.h"  // NOLINT(build/include_alpha)
+namespace IPC {
+#include "ozone/content/message_generator.h"  // NOLINT(build/include)
+}  // namespace IPC
+
+// Generate param traits log methods.
+#include "ipc/param_traits_log_macros.h"  // NOLINT(build/include_alpha)
+namespace IPC {
+#include "ozone/content/message_generator.h"  // NOLINT(build/include)
+}  // namespace IPC
--- /dev/null
+++ b/ozone/content/message_generator.h
@@ -0,0 +1,7 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Multiply-included file, hence no include guard.
+
+#include "ozone/content/messages.h"
--- /dev/null
+++ b/ozone/content/messages.h
@@ -0,0 +1,124 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Multiply-included message file, hence no include guard here.
+
+#include <string>
+
+#include "base/basictypes.h"
+#include "base/strings/string16.h"
+#include "content/public/common/common_param_traits.h"
+#include "ipc/ipc_message_macros.h"
+#include "ipc/ipc_message_utils.h"
+#include "ipc/ipc_param_traits.h"
+#include "ipc/param_traits_macros.h"
+#include "ozone/ui/events/window_constants.h"
+#include "ui/events/event_constants.h"
+
+#define IPC_MESSAGE_START LastIPCMsgStart
+
+IPC_ENUM_TRAITS_MAX_VALUE(ui::EventFlags,
+                          ui::EF_ALTGR_DOWN)
+IPC_ENUM_TRAITS_MAX_VALUE(ui::EventType,
+                          ui::ET_LAST)
+IPC_ENUM_TRAITS_MAX_VALUE(ui::WidgetState,
+                          ui::DESTROYED)
+IPC_ENUM_TRAITS_MAX_VALUE(ui::WidgetType,
+                          ui::POPUP)
+
+IPC_MESSAGE_CONTROL2(WaylandInput_MotionNotify,  // NOLINT(readability/fn_size)
+                     float /*x*/,
+                     float /*y*/)
+
+IPC_MESSAGE_CONTROL5(WaylandInput_ButtonNotify,  // NOLINT(readability/fn_size)
+                     unsigned /*handle*/,
+                     ui::EventType /*type*/,
+                     ui::EventFlags /*flags*/,
+                     float /*x*/,
+                     float /*y*/)
+
+IPC_MESSAGE_CONTROL5(WaylandInput_TouchNotify,  // NOLINT(readability/fn_size)
+                     ui::EventType /*type*/,
+                     float /*x*/,
+                     float /*y*/,
+                     int32_t /*touch_id*/,
+                     uint32_t /*time_stamp*/)
+
+IPC_MESSAGE_CONTROL4(WaylandInput_AxisNotify,  // NOLINT(readability/fn_size)
+                     float /*x*/,
+                     float /*y*/,
+                     int /*x_offset*/,
+                     int /*y_offset*/)
+
+IPC_MESSAGE_CONTROL3(WaylandInput_PointerEnter,  // NOLINT(readability/fn_size)
+                     unsigned /*handle*/,
+                     float /*x*/,
+                     float /*y*/)
+
+IPC_MESSAGE_CONTROL3(WaylandInput_PointerLeave,  // NOLINT(readability/fn_size)
+                     unsigned /*handle*/,
+                     float /*x*/,
+                     float /*y*/)
+
+IPC_MESSAGE_CONTROL3(WaylandInput_KeyNotify,  // NOLINT(readability/fn_size)
+                     ui::EventType /*type*/,
+                     unsigned /*code*/,
+                     unsigned /*modifiers*/)
+
+IPC_MESSAGE_CONTROL2(WaylandInput_OutputSize,  // NOLINT(readability/fn_size)
+                     unsigned /*width*/,
+                     unsigned /*height*/)
+
+IPC_MESSAGE_CONTROL1(WaylandInput_CloseWidget,  // NOLINT(readability/fn_size)
+                     unsigned /*handle*/)
+
+IPC_MESSAGE_CONTROL3(WaylandWindow_Resized,  // NOLINT(readability/fn_size)
+                     unsigned /* window handle */,
+                     unsigned /* width */,
+                     unsigned /* height */)
+
+IPC_MESSAGE_ROUTED4(WaylandWindow_State,  // NOLINT(readability/fn_size)
+                    unsigned /* window handle */,
+                    ui::WidgetState /*state*/,
+                    unsigned /*width*/,
+                    unsigned /*height*/)
+
+IPC_MESSAGE_ROUTED5(WaylandWindow_Attributes,  // NOLINT(readability/fn_size)
+                    unsigned /* window handle */,
+                    unsigned /* window parent */,
+                    unsigned /* x */,
+                    unsigned /* y */,
+                    ui::WidgetType /* window type */)
+
+IPC_MESSAGE_ROUTED2(WaylandWindow_Title,  // NOLINT(readability/fn_size)
+                    unsigned /* window handle */,
+                    base::string16 /* window title */)
+
+IPC_MESSAGE_ROUTED1(WaylandWindow_Cursor,  // NOLINT(readability/fn_size)
+                    int /* cursor type */)
+
+IPC_MESSAGE_ROUTED0(WaylandWindow_ImeReset)  // NOLINT(readability/fn_size)
+
+// FIXME(chad): Rect is not templated
+//IPC_MESSAGE_ROUTED1(WaylandWindow_ImeCaretBoundsChanged, // NOLINT(readability/
+//                    gfx::Rect /* ImeCaretBoundsChanged */)  //     fn_size)
+
+IPC_MESSAGE_ROUTED0(WaylandWindow_ShowInputPanel)  // NOLINT(readability/
+                                                   //        fn_size)
+
+IPC_MESSAGE_ROUTED0(WaylandWindow_HideInputPanel)  // NOLINT(readability/
+                                                   //        fn_size)
+
+IPC_MESSAGE_CONTROL2(WaylandInput_Commit,  // NOLINT(readability/fn_size)
+                     unsigned,
+                     std::string)
+
+IPC_MESSAGE_CONTROL3(WaylandInput_PreeditChanged, // NOLINT(readability/
+                     unsigned,                    //        fn_size)
+                     std::string, std::string)
+
+IPC_MESSAGE_CONTROL0(WaylandInput_PreeditEnd)  // NOLINT(readability/fn_size)
+
+IPC_MESSAGE_CONTROL0(WaylandInput_PreeditStart)  // NOLINT(readability/fn_size)
+
--- /dev/null
+++ b/ozone/content/ozone_channel.cc
@@ -0,0 +1,108 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/content/ozone_channel.h"
+
+#include "content/child/child_process.h"
+#include "content/child/child_thread.h"
+#include "ozone/content/messages.h"
+#include "ozone/content/remote_event_dispatcher.h"
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/ui/events/ime_state_change_handler.h"
+#include "ozone/ui/events/window_state_change_handler.h"
+
+namespace content {
+// GpuChannelManager generates unique routeid for every new
+// ImageTransportSurface. In Ozone-Wayland, we register a routeid between
+// DisplayChannel and ChannelHost. Therefore, we hardcore our own routeid with a
+// unique negitive value to avoid any conflicts from the GpuChannelManager ones.
+#define WAYLAND_ROUTE_ID -0x1
+
+namespace {
+
+content::ChildThread* GetProcessMainThread() {
+  content::ChildProcess* process = content::ChildProcess::current();
+  DCHECK(process && process->main_thread());
+  return process->main_thread();
+}
+
+}
+
+OzoneChannel::OzoneChannel() {
+  event_converter_ = new RemoteEventDispatcher();
+  ui::EventFactoryOzoneWayland::GetInstance()->
+      SetEventConverterOzoneWayland(event_converter_);
+}
+
+OzoneChannel::~OzoneChannel() {
+  ChildThread* thread = GetProcessMainThread();
+  thread->GetRouter()->RemoveRoute(WAYLAND_ROUTE_ID);
+}
+
+bool OzoneChannel::OnMessageReceived(
+    const IPC::Message& message) {
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(OzoneChannel, message)
+  IPC_MESSAGE_HANDLER(WaylandWindow_State, OnWidgetStateChanged)
+  IPC_MESSAGE_HANDLER(WaylandWindow_Attributes, OnWidgetAttributesChanged)
+  IPC_MESSAGE_HANDLER(WaylandWindow_Title, OnWidgetTitleChanged)
+  IPC_MESSAGE_HANDLER(WaylandWindow_Cursor, OnWidgetCursorChanged)
+  IPC_MESSAGE_HANDLER(WaylandWindow_ImeReset, OnWidgetImeReset)
+  IPC_MESSAGE_HANDLER(WaylandWindow_ShowInputPanel, OnWidgetShowInputPanel)
+  IPC_MESSAGE_HANDLER(WaylandWindow_HideInputPanel, OnWidgetHideInputPanel)
+  IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+
+  return handled;
+}
+
+void OzoneChannel::Register() {
+  ChildThread* thread = GetProcessMainThread();
+  thread->GetRouter()->AddRoute(WAYLAND_ROUTE_ID, this);
+}
+
+void OzoneChannel::OnWidgetStateChanged(unsigned handleid,
+                                        ui::WidgetState state,
+                                        unsigned width,
+                                        unsigned height) {
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(handleid,
+                                                              state,
+                                                              width,
+                                                              height);
+}
+
+void OzoneChannel::OnWidgetTitleChanged(unsigned widget,
+                                        base::string16 title) {
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetTitle(widget, title);
+}
+
+void OzoneChannel::OnWidgetCursorChanged(int cursor_type) {
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetCursor(cursor_type);
+}
+
+void OzoneChannel::OnWidgetAttributesChanged(unsigned widget,
+                                             unsigned parent,
+                                             unsigned x,
+                                             unsigned y,
+                                             ui::WidgetType type) {
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetAttributes(widget,
+                                                                   parent,
+                                                                   x,
+                                                                   y,
+                                                                   type);
+}
+
+void OzoneChannel::OnWidgetImeReset() {
+  ui::IMEStateChangeHandler::GetInstance()->ResetIme();
+}
+
+void OzoneChannel::OnWidgetShowInputPanel() {
+  ui::IMEStateChangeHandler::GetInstance()->ShowInputPanel();
+}
+
+void OzoneChannel::OnWidgetHideInputPanel() {
+  ui::IMEStateChangeHandler::GetInstance()->HideInputPanel();
+}
+
+}  // namespace content
--- /dev/null
+++ b/ozone/content/ozone_channel.h
@@ -0,0 +1,49 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_CONTENT_OZONE_CHANNEL_H_
+#define OZONE_CONTENT_OZONE_CHANNEL_H_
+
+#include "base/strings/string16.h"
+#include "ipc/ipc_listener.h"
+#include "ozone/ui/events/window_constants.h"
+
+namespace content {
+class RemoteEventDispatcher;
+// OzoneChannel is responsible for listening to any messages sent by it's
+// host counterpart in BrowserProcess. There will be always only one
+// OzoneChannel per browser instance.
+
+class OzoneChannel : public IPC::Listener {
+ public:
+  OzoneChannel();
+  virtual ~OzoneChannel();
+
+  // IPC::Listener implementation.
+  virtual bool OnMessageReceived(const IPC::Message& message) override;
+
+  void Register();
+  void OnWidgetStateChanged(unsigned handleid,
+                            ui::WidgetState state,
+                            unsigned width,
+                            unsigned height);
+  void OnWidgetTitleChanged(unsigned widget, base::string16 title);
+  void OnWidgetCursorChanged(int cursor_type);
+  void OnWidgetAttributesChanged(unsigned widget,
+                                 unsigned parent,
+                                 unsigned x,
+                                 unsigned y,
+                                 ui::WidgetType type);
+  void OnWidgetImeReset();
+  void OnWidgetShowInputPanel();
+  void OnWidgetHideInputPanel();
+
+ private:
+  RemoteEventDispatcher* event_converter_;
+  DISALLOW_COPY_AND_ASSIGN(OzoneChannel);
+};
+
+}  // namespace content
+
+#endif  // OZONE_CONTENT_OZONE_CHANNEL_H_
--- /dev/null
+++ b/ozone/content/ozone_channel_host.cc
@@ -0,0 +1,195 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/content/ozone_channel_host.h"
+
+#include <string>
+
+#include "base/bind.h"
+#include "content/browser/gpu/browser_gpu_channel_host_factory.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/common/process_type.h"
+#include "ozone/content/messages.h"
+#include "ozone/content/remote_state_change_handler.h"
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+
+namespace content {
+
+OzoneChannelHost::OzoneChannelHost()
+    : state_handler_(NULL) {
+  dispatcher_ = ui::EventFactoryOzoneWayland::GetInstance()->EventConverter();
+  BrowserChildProcessObserver::Add(this);
+  EstablishChannel();
+}
+
+OzoneChannelHost::~OzoneChannelHost() {
+  BrowserChildProcessObserver::Remove(this);
+  delete state_handler_;
+}
+
+void OzoneChannelHost::OnMotionNotify(float x, float y) {
+  dispatcher_->MotionNotify(x, y);
+}
+
+void OzoneChannelHost::OnButtonNotify(unsigned handle,
+                                             ui::EventType type,
+                                             ui::EventFlags flags,
+                                             float x,
+                                             float y) {
+  dispatcher_->ButtonNotify(handle, type, flags, x, y);
+}
+
+void OzoneChannelHost::OnTouchNotify(ui::EventType type,
+                                     float x,
+                                     float y,
+                                     int32_t touch_id,
+                                     uint32_t time_stamp) {
+  dispatcher_->TouchNotify(type, x, y, touch_id, time_stamp);
+}
+
+void OzoneChannelHost::OnAxisNotify(float x,
+                                           float y,
+                                           int xoffset,
+                                           int yoffset) {
+  dispatcher_->AxisNotify(x, y, xoffset, yoffset);
+}
+
+void OzoneChannelHost::OnPointerEnter(unsigned handle,
+                                             float x,
+                                             float y) {
+  dispatcher_->PointerEnter(handle, x, y);
+}
+
+void OzoneChannelHost::OnPointerLeave(unsigned handle,
+                                             float x,
+                                             float y) {
+  dispatcher_->PointerLeave(handle, x, y);
+}
+
+void OzoneChannelHost::OnKeyNotify(ui::EventType type,
+                                          unsigned code,
+                                          unsigned modifiers) {
+  dispatcher_->KeyNotify(type, code, modifiers);
+}
+
+void OzoneChannelHost::OnOutputSizeChanged(unsigned width,
+                                                  unsigned height) {
+  dispatcher_->OutputSizeChanged(width, height);
+}
+
+void OzoneChannelHost::OnCloseWidget(unsigned handle) {
+  dispatcher_->CloseWidget(handle);
+}
+
+void OzoneChannelHost::OnWindowResized(unsigned handle,
+                                              unsigned width,
+                                              unsigned height) {
+  dispatcher_->WindowResized(handle, width, height);
+}
+
+void OzoneChannelHost::OnCommit(unsigned handle, std::string text) {
+  dispatcher_->Commit(handle, text);
+}
+
+void OzoneChannelHost::OnPreeditChanged(unsigned handle, std::string text,
+                                        std::string commit) {
+  dispatcher_->PreeditChanged(handle, text, commit);
+}
+
+void OzoneChannelHost::OnPreeditEnd() {
+}
+
+void OzoneChannelHost::OnPreeditStart() {
+}
+
+void OzoneChannelHost::BrowserChildProcessHostConnected(
+  const ChildProcessData& data) {
+  // we observe GPU process being forked or re-spawned for adding ourselves as
+  // an ipc filter and listen to any relevant messages coming from GpuProcess
+  // side.
+  if (data.process_type == PROCESS_TYPE_GPU)
+    EstablishChannel();
+}
+
+void OzoneChannelHost::BrowserChildProcessHostDisconnected(
+  const ChildProcessData& data) {
+  if (data.process_type == PROCESS_TYPE_GPU) {
+    if (state_handler_) {
+      delete state_handler_;
+      state_handler_ = NULL;
+    }
+  }
+}
+
+void OzoneChannelHost::BrowserChildProcessCrashed(
+  const ChildProcessData& data) {
+  if (data.process_type == PROCESS_TYPE_GPU) {
+    if (state_handler_) {
+      delete state_handler_;
+      state_handler_ = NULL;
+    }
+  }
+}
+
+void OzoneChannelHost::OnMessageReceived(const IPC::Message& message) {
+  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO)) <<
+      "Must handle messages that were dispatched to another thread!";
+
+  IPC_BEGIN_MESSAGE_MAP(OzoneChannelHost, message)
+  IPC_MESSAGE_HANDLER(WaylandInput_MotionNotify, OnMotionNotify)
+  IPC_MESSAGE_HANDLER(WaylandInput_ButtonNotify, OnButtonNotify)
+  IPC_MESSAGE_HANDLER(WaylandInput_TouchNotify, OnTouchNotify)
+  IPC_MESSAGE_HANDLER(WaylandInput_AxisNotify, OnAxisNotify)
+  IPC_MESSAGE_HANDLER(WaylandInput_PointerEnter, OnPointerEnter)
+  IPC_MESSAGE_HANDLER(WaylandInput_PointerLeave, OnPointerLeave)
+  IPC_MESSAGE_HANDLER(WaylandInput_KeyNotify, OnKeyNotify)
+  IPC_MESSAGE_HANDLER(WaylandInput_OutputSize, OnOutputSizeChanged)
+  IPC_MESSAGE_HANDLER(WaylandInput_CloseWidget, OnCloseWidget)
+  IPC_MESSAGE_HANDLER(WaylandWindow_Resized, OnWindowResized)
+  IPC_MESSAGE_HANDLER(WaylandInput_Commit, OnCommit)
+  IPC_MESSAGE_HANDLER(WaylandInput_PreeditChanged, OnPreeditChanged)
+  IPC_MESSAGE_HANDLER(WaylandInput_PreeditEnd, OnPreeditEnd)
+  IPC_MESSAGE_HANDLER(WaylandInput_PreeditStart, OnPreeditStart)
+
+  IPC_END_MESSAGE_MAP()
+}
+
+void OzoneChannelHost::EstablishChannel() {
+  if (state_handler_)
+    return;
+
+  state_handler_ = new RemoteStateChangeHandler();
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&OzoneChannelHost::UpdateConnection,
+          base::Unretained(this)));
+}
+
+void OzoneChannelHost::UpdateConnection() {
+  BrowserGpuChannelHostFactory* hostFactory =
+      BrowserGpuChannelHostFactory::instance();
+  DCHECK(hostFactory);
+  const uint32 kMessagesToFilter[] = { WaylandInput_MotionNotify::ID,
+                                       WaylandInput_ButtonNotify::ID,
+                                       WaylandInput_AxisNotify::ID,
+                                       WaylandInput_PointerEnter::ID,
+                                       WaylandInput_PointerLeave::ID,
+                                       WaylandInput_KeyNotify::ID,
+                                       WaylandInput_OutputSize::ID,
+                                       WaylandInput_CloseWidget::ID,
+                                       WaylandWindow_Resized::ID,
+                                       WaylandInput_TouchNotify::ID,
+                                       WaylandInput_Commit::ID,
+                                       WaylandInput_PreeditChanged::ID,
+                                       WaylandInput_PreeditEnd::ID,
+                                       WaylandInput_PreeditStart::ID,
+                                       };
+  scoped_refptr<base::SingleThreadTaskRunner> compositor_thread_task_runner =
+      base::MessageLoopProxy::current();
+  hostFactory->SetHandlerForControlMessages(
+      kMessagesToFilter, arraysize(kMessagesToFilter),
+          base::Bind(&OzoneChannelHost::OnMessageReceived,
+              base::Unretained(this)), compositor_thread_task_runner.get());
+}
+
+}  // namespace content
--- /dev/null
+++ b/ozone/content/ozone_channel_host.h
@@ -0,0 +1,75 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_CONTENT_OZONE_CHANNEL_HOST_H_
+#define OZONE_CONTENT_OZONE_CHANNEL_HOST_H_
+
+#include <string>
+
+#include "content/browser/gpu/gpu_process_host.h"
+#include "content/public/browser/browser_child_process_observer.h"
+#include "content/public/browser/child_process_data.h"
+#include "ui/events/event_constants.h"
+
+namespace ui {
+class EventConverterOzoneWayland;
+}
+
+namespace content {
+class RemoteStateChangeHandler;
+// OzoneChannelHost is responsible for listening to any relevant messages
+// sent from gpu process(i.e dispatcher and OzoneDisplayChannel). There will
+// always be only one OzoneChannelHost per browser instance. It listens
+// to these messages in IO thread.
+
+class OzoneChannelHost : public BrowserChildProcessObserver {
+ public:
+  OzoneChannelHost();
+  virtual ~OzoneChannelHost();
+
+  void OnMotionNotify(float x, float y);
+  void OnButtonNotify(unsigned handle,
+                      ui::EventType type,
+                      ui::EventFlags flags,
+                      float x,
+                      float y);
+  void OnTouchNotify(ui::EventType type,
+                     float x,
+                     float y,
+                     int32_t touch_id,
+                     uint32_t time_stamp);
+  void OnAxisNotify(float x, float y, int xoffset, int yoffset);
+  void OnPointerEnter(unsigned handle, float x, float y);
+  void OnPointerLeave(unsigned handle, float x, float y);
+  void OnKeyNotify(ui::EventType type, unsigned code, unsigned modifiers);
+  void OnOutputSizeChanged(unsigned width, unsigned height);
+  void OnCloseWidget(unsigned handle);
+  void OnWindowResized(unsigned handle,
+                       unsigned width,
+                       unsigned height);
+  void OnCommit(unsigned handle, std::string text);
+  void OnPreeditChanged(unsigned handle, std::string text, std::string commit);
+  void OnPreeditEnd();
+  void OnPreeditStart();
+
+  // Implement |BrowserChildProcessObserver|.
+  virtual void BrowserChildProcessHostConnected(
+    const ChildProcessData& data) override;
+  virtual void BrowserChildProcessHostDisconnected(
+      const ChildProcessData& data) override;
+  virtual void BrowserChildProcessCrashed(
+      const ChildProcessData& data) override;
+
+ private:
+  void OnMessageReceived(const IPC::Message& message);
+  void EstablishChannel();
+  void UpdateConnection();
+  ui::EventConverterOzoneWayland* dispatcher_;
+  RemoteStateChangeHandler* state_handler_;
+  DISALLOW_COPY_AND_ASSIGN(OzoneChannelHost);
+};
+
+}  // namespace content
+
+#endif  // OZONE_CONTENT_OZONE_CHANNEL_HOST_H_
--- /dev/null
+++ b/ozone/content/ozone_channel_host_factory.cc
@@ -0,0 +1,49 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/content/ozone_channel_host_factory.h"
+
+#include "ozone/content/event_converter_in_process.h"
+#include "ozone/content/ozone_channel_host.h"
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+
+namespace content {
+OzoneChannelHostFactory* OzoneChannelHostFactory::instance_ = NULL;
+
+void OzoneChannelHostFactory::Initialize(bool establish_gpu_channel) {
+  DCHECK(!instance_);
+  instance_ = new OzoneChannelHostFactory(establish_gpu_channel);
+}
+
+void OzoneChannelHostFactory::Terminate() {
+  DCHECK(instance_);
+  delete instance_;
+  instance_ = NULL;
+}
+
+OzoneChannelHostFactory* OzoneChannelHostFactory::instance() {
+  return instance_;
+}
+
+OzoneChannelHostFactory::OzoneChannelHostFactory(bool establish_gpu_channel)
+    : event_converter_(NULL) {
+  event_converter_ = new EventConverterInProcess();
+  ui::EventFactoryOzoneWayland* event_factory =
+    ui::EventFactoryOzoneWayland::GetInstance();
+  event_factory->SetEventConverterOzoneWayland(event_converter_);
+  event_converter_->SetWindowChangeObserver(
+      event_factory->GetWindowChangeObserver());
+  event_converter_->SetOutputChangeObserver(
+      event_factory->GetOutputChangeObserver());
+  if (establish_gpu_channel)
+    host_ = new OzoneChannelHost();
+}
+
+OzoneChannelHostFactory::~OzoneChannelHostFactory() {
+  ui::EventFactoryOzoneWayland::GetInstance()->
+      SetEventConverterOzoneWayland(NULL);
+  delete event_converter_;
+}
+
+}  // namespace content
--- /dev/null
+++ b/ozone/content/ozone_channel_host_factory.h
@@ -0,0 +1,33 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_CONTENT_OZONE_CHANNEL_HOST_FACTORY_H_
+#define OZONE_CONTENT_OZONE_CHANNEL_HOST_FACTORY_H_
+
+#include "ozone/content/ozone_channel_host.h"
+
+namespace content {
+class EventConverterInProcess;
+class OzoneChannelHost;
+// This class is responsible for establishing gpu channel connection between
+// OzoneDisplayChannel and ChannelHost.
+class OzoneChannelHostFactory {
+ public:
+  static void Initialize(bool establish_gpu_channel);
+  static void Terminate();
+  static OzoneChannelHostFactory* instance();
+
+  explicit OzoneChannelHostFactory(bool establish_gpu_channel);
+  virtual ~OzoneChannelHostFactory();
+
+ private:
+  EventConverterInProcess* event_converter_;
+  OzoneChannelHost* host_;
+  static OzoneChannelHostFactory* instance_;
+  DISALLOW_COPY_AND_ASSIGN(OzoneChannelHostFactory);
+};
+
+}  // namespace content
+
+#endif  // OZONE_CONTENT_OZONE_CHANNEL_HOST_FACTORY_H_
--- /dev/null
+++ b/ozone/content/remote_event_dispatcher.cc
@@ -0,0 +1,214 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/content/remote_event_dispatcher.h"
+
+#include <string>
+
+#include "base/bind.h"
+#include "content/child/child_process.h"
+#include "content/child/child_thread.h"
+#include "ozone/content/messages.h"
+
+namespace {
+
+content::ChildThread* GetProcessMainThread() {
+  content::ChildProcess* process = content::ChildProcess::current();
+  DCHECK(process && process->main_thread());
+  return process ? process->main_thread() : NULL;
+}
+
+}
+
+namespace content {
+
+RemoteEventDispatcher::RemoteEventDispatcher()
+    : EventConverterOzoneWayland() {
+}
+
+RemoteEventDispatcher::~RemoteEventDispatcher() {
+}
+
+void RemoteEventDispatcher::MotionNotify(float x, float y) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(
+      base::Bind(&RemoteEventDispatcher::SendMotionNotify, x, y));
+}
+
+void RemoteEventDispatcher::ButtonNotify(unsigned handle,
+                                         ui::EventType type,
+                                         ui::EventFlags flags,
+                                         float x,
+                                         float y) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(
+      base::Bind(&RemoteEventDispatcher::SendButtonNotify, handle, type, flags,
+          x, y));
+}
+
+void RemoteEventDispatcher::AxisNotify(float x,
+                                       float y,
+                                       int xoffset,
+                                       int yoffset) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(
+      base::Bind(&RemoteEventDispatcher::SendAxisNotify, x, y, xoffset,
+          yoffset));
+}
+
+void RemoteEventDispatcher::PointerEnter(unsigned handle,
+                                         float x,
+                                         float y) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(
+      base::Bind(&RemoteEventDispatcher::SendPointerEnter, handle, x, y));
+}
+
+void RemoteEventDispatcher::PointerLeave(unsigned handle,
+                                         float x,
+                                         float y) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(
+      base::Bind(&RemoteEventDispatcher::SendPointerLeave, handle, x, y));
+}
+
+void RemoteEventDispatcher::KeyNotify(ui::EventType state,
+                                      unsigned code,
+                                      unsigned modifiers) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(
+      base::Bind(&RemoteEventDispatcher::SendKeyNotify, state, code,
+          modifiers));
+}
+
+void RemoteEventDispatcher::TouchNotify(ui::EventType type,
+                                        float x,
+                                        float y,
+                                        int32_t touch_id,
+                                        uint32_t time_stamp) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(
+      base::Bind(&RemoteEventDispatcher::SendTouchNotify, type,
+          x, y, touch_id, time_stamp));
+}
+
+void RemoteEventDispatcher::OutputSizeChanged(unsigned width,
+                                              unsigned height) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &RemoteEventDispatcher::SendOutputSizeChanged, width, height));
+}
+
+void RemoteEventDispatcher::WindowResized(unsigned handle,
+                                          unsigned width,
+                                          unsigned height) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &RemoteEventDispatcher::SendWindowResized, handle, width, height));
+}
+
+void RemoteEventDispatcher::CloseWidget(unsigned handle) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &RemoteEventDispatcher::SendCloseWidget, handle));
+}
+
+void RemoteEventDispatcher::Commit(unsigned handle,
+                                   const std::string& text) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &RemoteEventDispatcher::SendCommit, handle, text));
+}
+
+void RemoteEventDispatcher::PreeditChanged(unsigned handle,
+                                           const std::string& text,
+                                           const std::string& commit) {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &RemoteEventDispatcher::SendPreeditChanged, handle, text, commit));
+}
+
+void RemoteEventDispatcher::PreeditEnd() {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &RemoteEventDispatcher::SendPreeditEnd));
+}
+
+void RemoteEventDispatcher::PreeditStart() {
+  ui::EventConverterOzoneWayland::PostTaskOnMainLoop(base::Bind(
+      &RemoteEventDispatcher::SendPreeditStart));
+}
+
+void RemoteEventDispatcher::SendMotionNotify(float x, float y) {
+  Send(new WaylandInput_MotionNotify(x, y));
+}
+
+void RemoteEventDispatcher::SendButtonNotify(unsigned handle,
+                                             ui::EventType type,
+                                             ui::EventFlags flags,
+                                             float x,
+                                             float y) {
+  Send(new WaylandInput_ButtonNotify(handle, type, flags, x, y));
+}
+
+void RemoteEventDispatcher::SendAxisNotify(float x,
+                                           float y,
+                                           int xoffset,
+                                           int yoffset) {
+  Send(new WaylandInput_AxisNotify(x, y, xoffset, yoffset));
+}
+
+void RemoteEventDispatcher::SendPointerEnter(unsigned handle,
+                                             float x,
+                                             float y) {
+  Send(new WaylandInput_PointerEnter(handle, x, y));
+}
+
+void RemoteEventDispatcher::SendPointerLeave(unsigned handle,
+                                             float x,
+                                             float y) {
+  Send(new WaylandInput_PointerLeave(handle, x, y));
+}
+
+void RemoteEventDispatcher::SendKeyNotify(ui::EventType type,
+                                          unsigned code,
+                                          unsigned modifiers) {
+  Send(new WaylandInput_KeyNotify(type, code, modifiers));
+}
+
+void RemoteEventDispatcher::SendTouchNotify(ui::EventType type,
+                                            float x,
+                                            float y,
+                                            int32_t touch_id,
+                                            uint32_t time_stamp) {
+  Send(new WaylandInput_TouchNotify(type, x, y, touch_id, time_stamp));
+}
+
+void RemoteEventDispatcher::SendOutputSizeChanged(unsigned width,
+                                                  unsigned height) {
+  Send(new WaylandInput_OutputSize(width, height));
+}
+
+void RemoteEventDispatcher::SendWindowResized(unsigned handle,
+                                              unsigned width,
+                                              unsigned height) {
+  Send(new WaylandWindow_Resized(handle, width, height));
+}
+
+void RemoteEventDispatcher::SendCloseWidget(unsigned handle) {
+  Send(new WaylandInput_CloseWidget(handle));
+}
+
+void RemoteEventDispatcher::SendCommit(unsigned handle,
+                                       const std::string& text) {
+  Send(new WaylandInput_Commit(handle, text));
+}
+
+void RemoteEventDispatcher::SendPreeditChanged(unsigned handle,
+                                               const std::string& text,
+                                               const std::string& commit) {
+  Send(new WaylandInput_PreeditChanged(handle, text, commit));
+}
+
+void RemoteEventDispatcher::SendPreeditEnd() {
+  Send(new WaylandInput_PreeditEnd());
+}
+
+void RemoteEventDispatcher::SendPreeditStart() {
+  Send(new WaylandInput_PreeditStart());
+}
+
+void RemoteEventDispatcher::Send(IPC::Message* message) {
+  ChildThread* thread = GetProcessMainThread();
+  thread->Send(message);
+}
+
+}  // namespace content
--- /dev/null
+++ b/ozone/content/remote_event_dispatcher.h
@@ -0,0 +1,93 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_CONTENT_REMOTE_EVENT_DISPATCHER_H_
+#define OZONE_CONTENT_REMOTE_EVENT_DISPATCHER_H_
+
+#include <string>
+
+#include "content/browser/gpu/gpu_process_host.h"
+#include "ozone/ui/events/event_converter_ozone_wayland.h"
+
+namespace content {
+
+// RemoteEventDispatcher sends native events from GPU to Browser process over
+// IPC. In Multi-process case, callbacks from Wayland are received in GPU
+// process side. All callbacks related to input need to be handled in Browser
+// process and hence the events are sent to it over IPC.
+class RemoteEventDispatcher : public ui::EventConverterOzoneWayland {
+ public:
+  RemoteEventDispatcher();
+  virtual ~RemoteEventDispatcher();
+
+  virtual void MotionNotify(float x, float y) override;
+  virtual void ButtonNotify(unsigned handle,
+                            ui::EventType type,
+                            ui::EventFlags flags,
+                            float x,
+                            float y) override;
+  virtual void AxisNotify(float x,
+                          float y,
+                          int xoffset,
+                          int yoffset) override;
+  virtual void PointerEnter(unsigned handle, float x, float y) override;
+  virtual void PointerLeave(unsigned handle, float x, float y) override;
+  virtual void KeyNotify(ui::EventType type,
+                         unsigned code,
+                         unsigned modifiers) override;
+  virtual void TouchNotify(ui::EventType type,
+                           float x,
+                           float y,
+                           int32_t touch_id,
+                           uint32_t time_stamp) override;
+
+  virtual void OutputSizeChanged(unsigned width, unsigned height) override;
+  virtual void WindowResized(unsigned handle,
+                             unsigned width,
+                             unsigned height) override;
+  virtual void CloseWidget(unsigned handle) override;
+
+  virtual void Commit(unsigned handle, const std::string& text) override;
+  virtual void PreeditChanged(unsigned handle,
+                              const std::string& text,
+                              const std::string& commit) override;
+  virtual void PreeditEnd() override;
+  virtual void PreeditStart() override;
+
+ private:
+  static void SendMotionNotify(float x, float y);
+  static void SendButtonNotify(unsigned handle,
+                               ui::EventType type,
+                               ui::EventFlags flags,
+                               float x,
+                               float y);
+  static void SendAxisNotify(float x, float y, int xoffset, int yoffset);
+  static void SendPointerEnter(unsigned handle, float x, float y);
+  static void SendPointerLeave(unsigned handle, float x, float y);
+  static void SendKeyNotify(ui::EventType type,
+                            unsigned code,
+                            unsigned modifiers);
+  static void SendTouchNotify(ui::EventType type,
+                              float x,
+                              float y,
+                              int32_t touch_id,
+                              uint32_t time_stamp);
+  static void SendOutputSizeChanged(unsigned width, unsigned height);
+  static void SendWindowResized(unsigned handle,
+                                unsigned width,
+                                unsigned height);
+  static void SendCloseWidget(unsigned handle);
+  static void SendCommit(unsigned handle, const std::string& text);
+  static void SendPreeditChanged(unsigned handle,
+                              const std::string& text,
+                              const std::string& commit);
+  static void SendPreeditEnd();
+  static void SendPreeditStart();
+  static void Send(IPC::Message* message);
+  DISALLOW_COPY_AND_ASSIGN(RemoteEventDispatcher);
+};
+
+}  // namespace content
+
+#endif  // OZONE_CONTENT_REMOTE_EVENT_DISPATCHER_H_
--- /dev/null
+++ b/ozone/content/remote_state_change_handler.cc
@@ -0,0 +1,155 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/content/remote_state_change_handler.h"
+
+#include "base/bind.h"
+#include "content/browser/gpu/browser_gpu_channel_host_factory.h"
+#include "content/public/browser/browser_child_process_host_iterator.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/common/process_type.h"
+#include "ozone/content/messages.h"
+
+namespace content {
+
+// This should be same as defined in display_channel.
+const int CHANNEL_ROUTE_ID = -0x1;
+
+RemoteStateChangeHandler::RemoteStateChangeHandler()
+    : iterator_(NULL) {
+  WindowStateChangeHandler::SetInstance(this);
+  IMEStateChangeHandler::SetInstance(this);
+  BrowserGpuChannelHostFactory* host_factory =
+      BrowserGpuChannelHostFactory::instance();
+  DCHECK(host_factory);
+  // This is a synchronous call and blocks current thread till Channel is
+  // setup.
+  BrowserGpuChannelHostFactory::instance()->EstablishGpuChannelSync(
+      CAUSE_FOR_GPU_LAUNCH_BROWSER_STARTUP);
+
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&RemoteStateChangeHandler::EstablishChannel,
+          base::Unretained(this)));
+}
+
+RemoteStateChangeHandler::~RemoteStateChangeHandler() {
+}
+
+void RemoteStateChangeHandler::SetWidgetState(unsigned w,
+                                              ui::WidgetState state,
+                                              unsigned width,
+                                              unsigned height) {
+  if (!BrowserThread::CurrentlyOn(BrowserThread::IO)) {
+    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+        base::Bind(&RemoteStateChangeHandler::SetWidgetState,
+            base::Unretained(this), w, state, width, height));
+    return;
+  }
+
+  Send(new WaylandWindow_State(CHANNEL_ROUTE_ID, w, state, width, height));
+}
+
+void RemoteStateChangeHandler::SetWidgetTitle(unsigned w,
+                                              const base::string16& title) {
+  if (!BrowserThread::CurrentlyOn(BrowserThread::IO)) {
+    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+        base::Bind(&RemoteStateChangeHandler::SetWidgetTitle,
+            base::Unretained(this), w, title));
+    return;
+  }
+
+  Send(new WaylandWindow_Title(CHANNEL_ROUTE_ID, w, title));
+}
+
+void RemoteStateChangeHandler::SetWidgetCursor(int cursor_type) {
+  if (!BrowserThread::CurrentlyOn(BrowserThread::IO)) {
+    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+        base::Bind(&RemoteStateChangeHandler::SetWidgetCursor,
+            base::Unretained(this), cursor_type));
+    return;
+  }
+
+  Send(new WaylandWindow_Cursor(CHANNEL_ROUTE_ID, cursor_type));
+}
+
+void RemoteStateChangeHandler::SetWidgetAttributes(unsigned widget,
+                                                   unsigned parent,
+                                                   unsigned x,
+                                                   unsigned y,
+                                                   ui::WidgetType type) {
+  if (!BrowserThread::CurrentlyOn(BrowserThread::IO)) {
+    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+        base::Bind(&RemoteStateChangeHandler::SetWidgetAttributes,
+            base::Unretained(this), widget, parent, x, y, type));
+    return;
+  }
+
+  Send(new WaylandWindow_Attributes(CHANNEL_ROUTE_ID,
+                                    widget,
+                                    parent,
+                                    x,
+                                    y,
+                                    type));
+}
+
+void RemoteStateChangeHandler::ResetIme() {
+  if (!BrowserThread::CurrentlyOn(BrowserThread::IO)) {
+    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+        base::Bind(&RemoteStateChangeHandler::ResetIme,
+            base::Unretained(this)));
+    return;
+  }
+
+  Send(new WaylandWindow_ImeReset(CHANNEL_ROUTE_ID));
+}
+
+void RemoteStateChangeHandler::ImeCaretBoundsChanged(gfx::Rect rect) {
+  if (!BrowserThread::CurrentlyOn(BrowserThread::IO)) {
+    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+        base::Bind(&RemoteStateChangeHandler::ImeCaretBoundsChanged,
+            base::Unretained(this), rect));
+    return;
+  }
+
+  VLOG(1) << "Wanted to set IME carat bounds changed, but no Rect templated for IPC messages.";
+  //Send(new WaylandWindow_ImeCaretBoundsChanged(CHANNEL_ROUTE_ID, rect));
+}
+
+void RemoteStateChangeHandler::HideInputPanel() {
+  if (!BrowserThread::CurrentlyOn(BrowserThread::IO)) {
+    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+        base::Bind(&RemoteStateChangeHandler::HideInputPanel,
+            base::Unretained(this)));
+    return;
+  }
+
+  Send(new WaylandWindow_HideInputPanel(CHANNEL_ROUTE_ID));
+}
+
+void RemoteStateChangeHandler::ShowInputPanel() {
+  if (!BrowserThread::CurrentlyOn(BrowserThread::IO)) {
+    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+        base::Bind(&RemoteStateChangeHandler::ShowInputPanel,
+            base::Unretained(this)));
+    return;
+  }
+
+  Send(new WaylandWindow_ShowInputPanel(CHANNEL_ROUTE_ID));
+}
+
+bool RemoteStateChangeHandler::Send(IPC::Message* message) {
+  // The GPU process never sends synchronous IPC, so clear the unblock flag.
+  // This ensures the message is treated as a synchronous one and helps preserve
+  // order. Check set_unblock in ipc_messages.h for explanation.
+  message->set_unblock(true);
+  return iterator_->Send(message);
+}
+
+void RemoteStateChangeHandler::EstablishChannel() {
+  DCHECK(!iterator_);
+  iterator_ = new BrowserChildProcessHostIterator(PROCESS_TYPE_GPU);
+  DCHECK(!iterator_->Done());
+}
+
+}  // namespace content
--- /dev/null
+++ b/ozone/content/remote_state_change_handler.h
@@ -0,0 +1,55 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_CONTENT_REMOTE_STATE_CHANGE_HANDLER_H_
+#define OZONE_CONTENT_REMOTE_STATE_CHANGE_HANDLER_H_
+
+#include "ozone/ui/events/ime_state_change_handler.h"
+#include "ozone/ui/events/window_state_change_handler.h"
+
+namespace IPC {
+class Message;
+}
+
+namespace content {
+class BrowserChildProcessHostIterator;
+// RemoteStateChangeHandler implements WindowStateChangeHandler and
+// IMEStateChangeHandler. It is responsible for sending any Ime/Window state
+// change events from Browser to GPU process (i.e IPC).
+
+class RemoteStateChangeHandler : public ui::WindowStateChangeHandler,
+                                 public ui::IMEStateChangeHandler {
+ public:
+  RemoteStateChangeHandler();
+  virtual ~RemoteStateChangeHandler();
+
+  // WindowStateChangeHandler implementation:
+  virtual void SetWidgetState(unsigned widget,
+                              ui::WidgetState state,
+                              unsigned width = 0,
+                              unsigned height = 0) override;
+  virtual void SetWidgetTitle(unsigned w,
+                              const base::string16& title) override;
+  virtual void SetWidgetCursor(int cursor_type) override;
+  virtual void SetWidgetAttributes(unsigned widget,
+                                   unsigned parent,
+                                   unsigned x,
+                                   unsigned y,
+                                   ui::WidgetType type) override;
+  virtual void ResetIme() override;
+  virtual void ImeCaretBoundsChanged(gfx::Rect rect) override;
+  virtual void ShowInputPanel() override;
+  virtual void HideInputPanel() override;
+
+ private:
+  bool Send(IPC::Message* message);
+  void EstablishChannel();
+
+  content::BrowserChildProcessHostIterator* iterator_;
+  DISALLOW_COPY_AND_ASSIGN(RemoteStateChangeHandler);
+};
+
+}  // namespace content
+
+#endif  // OZONE_CONTENT_EVENTS_REMOTE_STATE_CHANGE_HANDLER_H_
--- /dev/null
+++ b/ozone/mir/mir.gyp
@@ -0,0 +1,67 @@
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Copyright 2013 Intel Corporation. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'variables': {
+    'conditions': [
+      ['sysroot!=""', {
+        'pkg-config': './pkg-config-wrapper "<(sysroot)" "<(target_arch)"',
+      }, {
+        'pkg-config': 'pkg-config'
+      }],
+    ],
+  },
+
+  'targets': [
+    {
+      'target_name': 'mir_toolkit',
+      'type': 'static_library',
+      'variables': {
+        'mir_packages': [
+          'mirclient',
+          'xkbcommon',
+        ],
+      },
+      'cflags': [
+        '<!@(<(pkg-config) --cflags <(mir_packages))',
+        '-Igen',
+        '-std=c++11',
+      ],
+      'direct_dependent_settings': {
+        'cflags': [
+          '<!@(<(pkg-config) --cflags <(mir_packages))',
+        ],
+      },
+      'link_settings': {
+        'ldflags': [
+          '<!@(<(pkg-config) --libs-only-L --libs-only-other <(mir_packages))',
+        ],
+        'libraries': [
+          '<!@(<(pkg-config) --libs-only-l <(mir_packages))',
+        ],
+      },
+      'dependencies': [
+        '../../base/base.gyp:base',
+        #'../../mojo/mojo.gyp:mojo_shell',
+      ],
+      'include_dirs': [
+        '../..',
+      ],
+      #'includes': [
+      #  '../ui/ime/ime.gypi',
+      #],
+      'sources': [
+         'mir_window.cc',
+         'mir_window.h',
+         'mir_display.cc',
+         'mir_display.h',
+         'mir_pointer.cc',
+         'mir_pointer.h',
+         'mir_keyboard.cc',
+         'mir_keyboard.h'
+      ],
+    },
+  ]
+}
--- /dev/null
+++ b/ozone/mir/mir_display.cc
@@ -0,0 +1,319 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Copyright 2014 Canonical LTD. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/mir/mir_display.h"
+#include "ozone/mir/mir_window.h"
+
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/ui/events/output_change_observer.h"
+#include "ozone/ui/events/ime_state_change_handler.h"
+
+#include "base/native_library.h"
+#include "base/files/file_path.h"
+
+#include <EGL/egl.h>
+
+namespace om = ozonemir;
+
+// TODO: Extract
+namespace
+{
+class NullIMEStateChangeHandler : public ui::IMEStateChangeHandler
+{
+  void ResetIme() {}
+  void ImeCaretBoundsChanged(gfx::Rect) {}
+  void ShowInputPanel() {}
+  void HideInputPanel() {}
+};
+}
+
+om::Display::Display() : connection_(NULL) {
+  gfx::OzoneDisplay::SetInstance(this);
+
+  LOG(ERROR) << "ozonemir::Display::ctor  setting window-state-change instance";
+  ui::WindowStateChangeHandler::SetInstance(this);
+  //
+  // TODO: Does this really belong here?
+  LOG(ERROR) << "ozonemir::Display::ctor  setting IME-state-change instance";
+  ui::IMEStateChangeHandler::SetInstance(new NullIMEStateChangeHandler);
+    
+  LOG(ERROR) << "ozonemir::Display::ctor  connecting";
+  connection_ = mir_connect_sync("/tmp/mir_socket", "Chromium");
+  LOG(ERROR) << "ozonemir::Display::ctor  connected!";
+  if (!mir_connection_is_valid(connection_)) {
+    LOG(ERROR) << "SurfaceFactoryMir failed to initialize connection to remote Mir Server: "
+      << mir_connection_get_error_message(connection_);
+  }
+  
+  LOG(ERROR) << "ozonemir::Display::ctor  done, ret INITIALIZED";
+  // TODO: Leak
+}
+
+om::Display::~Display() {
+  LOG(ERROR) << "ozonemir::Display::~Display";
+  Terminate();
+  gfx::OzoneDisplay::SetInstance(NULL);
+// TODO: Need in_gpu_process
+//  ui::WindowStateChangeHandler::SetInstance(NULL);
+}
+
+
+intptr_t om::Display::GetNativeDisplay() {
+  LOG(ERROR) << "ozonemir::Display::GetNativeDisplay";
+  DCHECK(mir_connection_is_valid(connection_));
+  return reinterpret_cast<intptr_t>(mir_connection_get_egl_native_display(connection_));
+}
+
+/*
+gfx::AcceleratedWidget om::Display::GetAcceleratedWidget() {
+  LOG(ERROR) << "ozonemir::Display::GetAccelleratedWidget";
+  static int opaque_handle = 0; // TODO: Can this be called from multiple threads.
+  opaque_handle++;
+
+  // Note in the host process om::Display is not the WindowStateChangeHandler
+  // (as InitializeHardware is never called) rather the ozone IPC channel is.
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(opaque_handle,
+                                                              ui::CREATE,
+                                                              0,
+                                                              0);
+    
+  return (gfx::AcceleratedWidget)opaque_handle;
+}
+*/
+
+scoped_ptr<ui::SurfaceOzoneEGL> om::Display::CreateEGLSurfaceForWidget(
+    gfx::AcceleratedWidget w) {
+  LOG(ERROR) << "ozonemir::Display::CreateEGLSurfaceForWidget";
+  DCHECK(mir_connection_is_valid(connection_));
+  auto widget = GetWidget(w);
+  DCHECK(widget);
+  
+  return widget->CreateOzoneEGLSurface();
+}                                       
+
+// See comment in wayland/display.cc
+void om::Display::LookAheadOutputGeometry() {
+  LOG(ERROR) << "ozonemir::Display::LookAheadOutputGeometry";
+  auto output_observer =
+    ui::EventFactoryOzoneWayland::GetInstance()->GetOutputChangeObserver();
+  DCHECK(output_observer);
+
+  // TODO: Implement for real.
+  unsigned width = 1024;
+  unsigned height = 1024;
+  output_observer->OnOutputSizeChanged(width, height);
+}
+
+void om::Display::Terminate() {
+  LOG(ERROR) << "ozonemir::Display::Terminate";
+  DCHECK(mir_connection_is_valid(connection_));
+}
+
+om::Window* om::Display::GetWidget(unsigned w) {
+  LOG(ERROR) << "ozonemir::Display::GetWidget";
+  std::unique_lock<decltype(widget_map_guard)> lg(widget_map_guard);
+  auto it = widgets.find(w);
+  return it == widgets.end() ? NULL : it->second;
+}
+
+void om::Display::CreateWindow(unsigned w) {
+  LOG(ERROR) << "ozonemir::Display::CreateWindow";
+  // TODO: Error checking if w exists.
+  std::unique_lock<decltype(widget_map_guard)> lg(widget_map_guard);
+  widgets[w] = new om::Window(connection_, w);
+}
+
+void om::Display::DestroyWindow(unsigned w) {
+  LOG(ERROR) << "ozonemir::Display::DestroyWindow";
+  std::unique_lock<decltype(widget_map_guard)> lg(widget_map_guard);
+  auto it = widgets.find(w);
+  if (it == widgets.end())
+    return; // TODO: Error?
+  delete it->second;
+  widgets.erase(it);
+}
+
+void om::Display::ForEachWidget(std::function<void(om::Window*)> const& exec) {
+  LOG(ERROR) << "ozonemir::Display::ForEachWidget";
+  std::unique_lock<decltype(widget_map_guard)> lg(widget_map_guard);
+  for (auto kv : widgets)
+    exec(kv.second);
+}
+
+// TODO: Consider thread safety here.
+void om::Display::StartProcessingEvents() {
+  LOG(ERROR) << "ozonemir::Display::StartProcessingEvents";
+  ForEachWidget([](om::Window* w) {
+      w->StartProcessingEvents();
+    });
+}
+
+void om::Display::StopProcessingEvents() {
+  LOG(ERROR) << "ozonemir::Display::StopProcessingEvents";
+  ForEachWidget([](om::Window* w) {
+      w->StopProcessingEvents();
+    });
+}
+
+bool om::Display::AnyWindowsExist() {
+  LOG(ERROR) << "ozonemir::Display::AnyWindowsExist";
+  return !widgets.empty();
+}
+
+void om::Display::SetWidgetState(unsigned w, ui::WidgetState state, unsigned width, unsigned height) {
+  LOG(ERROR) << "ozonemir::Display::SetWidgetState";
+  switch (state) {
+  case ui::CREATE:
+    {
+      CreateWindow(w);
+      break;
+    }
+  case ui::FULLSCREEN:
+    {
+      om::Window* widget = GetWidget(w);
+      DCHECK(widget);
+
+      widget->SetFullscreen();
+      widget->Resize(width, height);
+      break;
+    }
+  case ui::MAXIMIZED:
+    {
+      om::Window* widget = GetWidget(w);
+      DCHECK(widget);
+
+      widget->Maximize();
+      break;
+    }
+  case ui::MINIMIZED:
+    {
+      om::Window* widget = GetWidget(w);
+      DCHECK(widget);
+
+      widget->Minimize();
+      break;
+    }
+  case ui::RESTORE:
+    {
+      om::Window* widget = GetWidget(w);
+      DCHECK(widget);
+
+      widget->Restore();
+      widget->Resize(width, height);
+      break;
+    }
+  case ui::ACTIVE:
+    NOTIMPLEMENTED() << " ACTIVE " << w;
+    break;
+  case ui::INACTIVE:
+    NOTIMPLEMENTED() << " INACTIVE " << w;
+    break;
+  case ui::SHOW:
+    NOTIMPLEMENTED() << " SHOW " << w;
+    break;
+  case ui::HIDE:
+    NOTIMPLEMENTED() << " HIDE " << w;
+    break;
+  case ui::RESIZE:
+    {
+      om::Window* window = GetWidget(w);
+      DCHECK(window);
+
+      window->Resize(width, height);
+      break;
+    }
+  case ui::DESTROYED:
+    {
+      DestroyWindow(w);
+      if (!AnyWindowsExist())
+        StopProcessingEvents();
+      break;
+    }
+  default:
+    break;
+  }
+}
+
+void om::Display::SetWidgetTitle(unsigned w, const base::string16& title) {
+  LOG(ERROR) << "ozonemir::Display::SetWidgetTitle";
+  auto widget = GetWidget(w);
+  DCHECK(widget);
+  widget->SetWindowTitle(title);
+}
+
+void om::Display::SetWidgetCursor(int cursor_type) {
+  LOG(ERROR) << "ozonemir::Display::SetWidgetCursor";
+  // TODO: Implement
+}
+
+void om::Display::SetWidgetAttributes(unsigned w, unsigned parent,
+                                      unsigned x, unsigned y, ui::WidgetType type) {
+  // TODO: Support popups
+  LOG(ERROR) << "ozonemir::Display::SetWidgetAttributes";
+  auto widget = GetWidget(w);
+  widget->SetWindowType(type);
+}
+
+const int32*
+om::Display::GetEGLSurfaceProperties(const int32* desired_list) {
+  LOG(ERROR) << "ozonemir::Display::GetEGLSurfaceProperties";
+  static const EGLint attribs[] = {
+    EGL_BUFFER_SIZE, 32,
+    EGL_ALPHA_SIZE, 8,
+    EGL_BLUE_SIZE, 8,
+    EGL_GREEN_SIZE, 8,
+    EGL_RED_SIZE, 8,
+    EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+    EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+    EGL_NONE
+  };
+
+  return attribs;
+}
+
+// Should be shared with wayland/display.cc
+bool om::Display::LoadEGLGLES2Bindings(
+    ui::SurfaceFactoryOzone::AddGLLibraryCallback add_gl_library,
+    ui::SurfaceFactoryOzone::SetGLGetProcAddressProcCallback setprocaddress) {
+  LOG(ERROR) << "ozonemir::Display::LoadEGLGLES2Bindings";
+  base::NativeLibraryLoadError error;
+  base::NativeLibrary gles_library = base::LoadNativeLibrary(
+    base::FilePath("libGLESv2.so.2"), &error);
+
+  if (!gles_library) {
+    LOG(WARNING) << "Failed to load GLES library: " << error.ToString();
+    return false;
+  }
+
+  base::NativeLibrary egl_library = base::LoadNativeLibrary(
+    base::FilePath("libEGL.so.1"), &error);
+
+  if (!egl_library) {
+    LOG(WARNING) << "Failed to load EGL library: " << error.ToString();
+    base::UnloadNativeLibrary(gles_library);
+    return false;
+  }
+
+  GLGetProcAddressProc get_proc_address =
+      reinterpret_cast<GLGetProcAddressProc>(
+          base::GetFunctionPointerFromNativeLibrary(
+              egl_library, "eglGetProcAddress"));
+
+  if (!get_proc_address) {
+    LOG(ERROR) << "eglGetProcAddress not found.";
+    base::UnloadNativeLibrary(egl_library);
+    base::UnloadNativeLibrary(gles_library);
+    return false;
+  }
+
+  setprocaddress.Run(get_proc_address);
+  add_gl_library.Run(egl_library);
+  add_gl_library.Run(gles_library);
+  return true;
+}
+
+char const* gfx::OzoneDisplay::GetEGLPlatform() {
+  return "mir";
+}
--- /dev/null
+++ b/ozone/mir/mir_display.h
@@ -0,0 +1,83 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Copyright 2014 Canonical LTD. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_MIR_OZONE_DISPLAY_H_
+#define OZONE_MIR_OZONE_DISPLAY_H_
+
+#include "base/basictypes.h"
+#include "ozone/ui/events/window_state_change_handler.h"
+#include "ozone/ui/gfx/ozone_display.h"
+#include "ui/ozone/public/surface_factory_ozone.h"
+#include "ui/ozone/public/surface_ozone_egl.h"
+
+#include <mir_toolkit/mir_client_library.h>
+
+#include <mutex>
+#include <map>
+#include <functional>
+
+namespace ozonemir {
+
+class Window;
+
+class Display : public gfx::OzoneDisplay, public ui::WindowStateChangeHandler {
+public:
+  Display();
+  virtual ~Display();
+
+  // gfx::OzoneDisplay
+  //virtual HardwareState InitializeHardware() override;
+  //virtual void ShutdownHardware() override;
+  virtual intptr_t GetNativeDisplay() override;
+
+  //virtual gfx::AcceleratedWidget GetAcceleratedWidget() override;
+  scoped_ptr<ui::SurfaceOzoneEGL> CreateEGLSurfaceForWidget(gfx::AcceleratedWidget w) override;
+  virtual void LookAheadOutputGeometry() override;
+  
+  // ui::WindowStateChangeHandler
+  virtual void SetWidgetState(unsigned widget, ui::WidgetState state, unsigned width = 0, unsigned height = 0) override;
+  virtual void SetWidgetTitle(unsigned w,
+                              const base::string16& title) override;
+  virtual void SetWidgetCursor(int cursor_type) override;
+  virtual void SetWidgetAttributes(unsigned widget,
+                                   unsigned parent,
+                                   unsigned x,
+                                   unsigned y,
+                                   ui::WidgetType type) override;
+
+  virtual bool LoadEGLGLES2Bindings(
+    ui::SurfaceFactoryOzone::AddGLLibraryCallback add_gl_library,
+    ui::SurfaceFactoryOzone::SetGLGetProcAddressProcCallback
+        proc_address) override;
+  virtual const int32* GetEGLSurfaceProperties(
+      const int32* desired_list) override;
+
+private:
+  void Terminate();
+
+  MirConnection *connection_;
+
+  std::mutex widget_map_guard;
+  std::map<unsigned, Window*> widgets;
+  
+  Window* GetWidget(unsigned w);
+  void CreateWindow(unsigned w);
+  void DestroyWindow(unsigned w);
+
+  bool AnyWindowsExist();
+
+  void ForEachWidget(std::function<void(Window*)> const& exec);
+  
+  void StartProcessingEvents();
+  void StopProcessingEvents();
+
+
+
+  DISALLOW_COPY_AND_ASSIGN(Display);
+};
+
+}  // namespace ozonemir
+
+#endif  // OZONE_MIR_OZONE_DISPLAY_H_
--- /dev/null
+++ b/ozone/mir/mir_keyboard.cc
@@ -0,0 +1,304 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Copyright 2014 Canonical LTD. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/mir/mir_keyboard.h"
+#include "ozone/ui/events/event_converter_ozone_wayland.h"
+
+#include "ozone/ui/events/keyboard_codes_ozone.h"
+
+#include <xkbcommon/xkbcommon.h>
+
+namespace om = ozonemir;
+
+namespace
+{
+uint32_t TranslateMirModifiers(unsigned mir_modifiers)
+{
+  uint32_t ui_m = 0;
+  
+  if (mir_modifiers & mir_key_modifier_shift)
+    ui_m |= ui::EF_SHIFT_DOWN;
+  if (mir_modifiers & mir_key_modifier_ctrl)
+    ui_m |= ui::EF_CONTROL_DOWN;
+  if (mir_modifiers & mir_key_modifier_meta)
+    ui_m |= ui::EF_ALT_DOWN;
+  if (mir_modifiers & mir_key_modifier_caps_lock)
+    ui_m |= ui::EF_CAPS_LOCK_DOWN;
+  
+  return ui_m;
+}
+
+xkb_keysym_t NormalizeKeysym(xkb_keysym_t keysym)
+{
+  if ((keysym >= XKB_KEY_A && keysym <= XKB_KEY_Z) ||
+       (keysym >= XKB_KEY_a && keysym <= XKB_KEY_z) ||
+         (keysym >= XKB_KEY_0 && keysym <= XKB_KEY_9))
+      return keysym;
+
+  if (keysym >= XKB_KEY_KP_0 && keysym <= XKB_KEY_KP_9) {
+    // Numpad Number-keys can be represented by a keysym value of 0-9 nos.
+    return  XKB_KEY_0 + (keysym - XKB_KEY_KP_0);
+  } else if (keysym > 0x01000100 && keysym < 0x01ffffff) {
+    // Any UCS character in this range will simply be the character's
+    // Unicode number plus 0x01000000.
+    return  keysym - 0x001000000;
+  } else if (keysym >= XKB_KEY_F1 && keysym <= XKB_KEY_F24) {
+    return  ui::OZONEACTIONKEY_F1 + (keysym - XKB_KEY_F1);
+  } else if (keysym >= XKB_KEY_KP_F1 && keysym <= XKB_KEY_KP_F4) {
+      return  ui::OZONEACTIONKEY_F1 + (keysym - XKB_KEY_KP_F1);
+  } else {
+      switch (keysym) {
+        case XKB_KEY_dead_circumflex:
+          return  ui::OZONECHARCODE_CARET_CIRCUMFLEX;
+        case XKB_KEY_dead_diaeresis:
+          return  ui::OZONECHARCODE_SPACING_DIAERESIS;
+        case XKB_KEY_dead_perispomeni:
+          return  ui::OZONECHARCODE_TILDE;
+        case XKB_KEY_dead_acute:
+          return  ui::OZONECHARCODE_SPACING_ACUTE;
+        case XKB_KEY_dead_grave:
+          return  ui::OZONECHARCODE_GRAVE_ASSCENT;
+        case XKB_KEY_endash:
+          return  ui::OZONECHARCODE_ENDASH;
+        case XKB_KEY_singlelowquotemark:
+          return  ui::OZONECHARCODE_SINGLE_LOW_QUOTATION_MARK;
+        case XKB_KEY_dead_cedilla:
+          return  ui::OZONECHARCODE_SPACING_CEDILLA;
+        case XKB_KEY_KP_Equal:
+          return  ui::OZONECHARCODE_EQUAL;
+        case XKB_KEY_KP_Multiply:
+          return  ui::OZONECHARCODE_MULTIPLY;
+        case XKB_KEY_KP_Add:
+          return  ui::OZONECHARCODE_PLUS;
+        case XKB_KEY_KP_Separator:
+          return  ui::OZONECHARCODE_COMMA;
+        case XKB_KEY_KP_Subtract:
+          return  ui::OZONECHARCODE_MINUS;
+        case XKB_KEY_KP_Decimal:
+        case XKB_KEY_period:
+          return  ui::OZONECHARCODE_PERIOD;
+        case XKB_KEY_KP_Divide:
+          return  ui::OZONECHARCODE_DIVISION;
+        case XKB_KEY_Delete:
+        case XKB_KEY_KP_Delete:
+          return  ui::OZONEACTIONKEY_DELETE;
+        case XKB_KEY_KP_Tab:
+        case XKB_KEY_ISO_Left_Tab:
+        case XKB_KEY_Tab:
+        case XKB_KEY_3270_BackTab:
+          return  ui::OZONEACTIONKEY_TAB;
+        case XKB_KEY_Sys_Req:
+        case XKB_KEY_Escape:
+          return  ui::OZONEACTIONKEY_ESCAPE;
+        case XKB_KEY_Linefeed:
+          return  ui::OZONECHARCODE_LINEFEED;
+        case XKB_KEY_Return:
+        case XKB_KEY_KP_Enter:
+        case XKB_KEY_ISO_Enter:
+          return  ui::OZONEACTIONKEY_RETURN;
+        case XKB_KEY_KP_Space:
+        case XKB_KEY_space:
+          return  ui::OZONEACTIONKEY_SPACE;
+        case XKB_KEY_dead_caron:
+          return  ui::OZONECHARCODE_CARON;
+        case XKB_KEY_BackSpace:
+          return  ui::OZONEACTIONKEY_BACK;
+        case XKB_KEY_dead_doubleacute:
+          return  ui::OZONECHARCODE_DOUBLE_ACUTE_ACCENT;
+        case XKB_KEY_dead_horn:
+          return  ui::OZONECHARCODE_COMBINING_HORN;
+        case XKB_KEY_oe:
+          return  ui::OZONECHARCODE_LSMALL_OE;
+        case XKB_KEY_OE:
+          return  ui::OZONECHARCODE_LOE;
+        case XKB_KEY_idotless:
+          return  ui::OZONECHARCODE_LSMALL_DOT_LESS_I;
+        case XKB_KEY_kra:
+          return  ui::OZONECHARCODE_LSMALL_KRA;
+        case XKB_KEY_dead_stroke:
+          return  ui::OZONECHARCODE_MINUS;
+        case XKB_KEY_eng:
+          return  ui::OZONECHARCODE_LSMALL_ENG;
+        case XKB_KEY_ENG:
+          return  ui::OZONECHARCODE_LENG;
+        case XKB_KEY_leftsinglequotemark:
+          return  ui::OZONECHARCODE_LEFT_SINGLE_QUOTATION_MARK;
+        case XKB_KEY_rightsinglequotemark:
+          return  ui::OZONECHARCODE_RIGHT_SINGLE_QUOTATION_MARK;
+        case XKB_KEY_dead_belowdot:
+          return  ui::OZONECHARCODE_COMBINING_DOT_BELOW;
+        case XKB_KEY_dead_belowdiaeresis:
+          return  ui::OZONECHARCODE_COMBINING_DIAERESIS_BELOW;
+        case XKB_KEY_Clear:
+        case XKB_KEY_KP_Begin:
+          return  ui::OZONEACTIONKEY_CLEAR;
+        case XKB_KEY_Home:
+        case XKB_KEY_KP_Home:
+          return  ui::OZONEACTIONKEY_HOME;
+        case XKB_KEY_End:
+        case XKB_KEY_KP_End:
+          return  ui::OZONEACTIONKEY_END;
+        case XKB_KEY_Page_Up:
+        case XKB_KEY_KP_Page_Up:  // aka XKB_KEY_KP_Prior
+          return  ui::OZONEACTIONKEY_PRIOR;
+        case XKB_KEY_Page_Down:
+        case XKB_KEY_KP_Page_Down:  // aka XKB_KEY_KP_Next
+          return  ui::OZONEACTIONKEY_NEXT;
+        case XKB_KEY_Left:
+        case XKB_KEY_KP_Left:
+          return  ui::OZONEACTIONKEY_LEFT;
+        case XKB_KEY_Right:
+        case XKB_KEY_KP_Right:
+          return  ui::OZONEACTIONKEY_RIGHT;
+        case XKB_KEY_Down:
+        case XKB_KEY_KP_Down:
+          return  ui::OZONEACTIONKEY_DOWN;
+        case XKB_KEY_Up:
+        case XKB_KEY_KP_Up:
+          return  ui::OZONEACTIONKEY_UP;
+        case XKB_KEY_Kana_Lock:
+        case XKB_KEY_Kana_Shift:
+          return  ui::OZONEACTIONKEY_KANA;
+        case XKB_KEY_Hangul:
+          return  ui::OZONEACTIONKEY_HANGUL;
+        case XKB_KEY_Hangul_Hanja:
+          return  ui::OZONEACTIONKEY_HANJA;
+        case XKB_KEY_Kanji:
+          return  ui::OZONEACTIONKEY_KANJI;
+        case XKB_KEY_Henkan:
+          return  ui::OZONEACTIONKEY_CONVERT;
+        case XKB_KEY_Muhenkan:
+          return  ui::OZONEACTIONKEY_NONCONVERT;
+        case XKB_KEY_Zenkaku_Hankaku:
+          return  ui::OZONEACTIONKEY_DBE_DBCSCHAR;
+        case XKB_KEY_ISO_Level5_Shift:
+          return  ui::OZONEACTIONKEY_OEM_8;
+        case XKB_KEY_Shift_L:
+        case XKB_KEY_Shift_R:
+          return  ui::OZONEACTIONKEY_SHIFT;
+        case XKB_KEY_Control_L:
+        case XKB_KEY_Control_R:
+          return  ui::OZONEACTIONKEY_CONTROL;
+        case XKB_KEY_Meta_L:
+        case XKB_KEY_Meta_R:
+        case XKB_KEY_Alt_L:
+        case XKB_KEY_Alt_R:
+          return  ui::OZONEACTIONKEY_MENU;
+        case XKB_KEY_ISO_Level3_Shift:
+          return  ui::OZONEACTIONKEY_ALTGR;
+        case XKB_KEY_Multi_key:
+          return  0xE6;
+        case XKB_KEY_Pause:
+          return  ui::OZONEACTIONKEY_PAUSE;
+        case XKB_KEY_Caps_Lock:
+          return  ui::OZONEACTIONKEY_CAPITAL;
+        case XKB_KEY_Num_Lock:
+          return  ui::OZONEACTIONKEY_NUMLOCK;
+        case XKB_KEY_Scroll_Lock:
+          return  ui::OZONEACTIONKEY_SCROLL;
+        case XKB_KEY_Select:
+          return  ui::OZONEACTIONKEY_SELECT;
+        case XKB_KEY_Print:
+          return  ui::OZONEACTIONKEY_PRINT;
+        case XKB_KEY_Execute:
+          return  ui::OZONEACTIONKEY_EXECUTE;
+        case XKB_KEY_Insert:
+        case XKB_KEY_KP_Insert:
+          return  ui::OZONEACTIONKEY_INSERT;
+        case XKB_KEY_Help:
+          return  ui::OZONEACTIONKEY_HELP;
+        case XKB_KEY_Super_L:
+          return  ui::OZONEACTIONKEY_LWIN;
+        case XKB_KEY_Super_R:
+          return  ui::OZONEACTIONKEY_RWIN;
+        case XKB_KEY_Menu:
+          return  ui::OZONEACTIONKEY_APPS;
+        case XKB_KEY_XF86Tools:
+          return  ui::OZONEACTIONKEY_F13;
+        case XKB_KEY_XF86Launch5:
+          return  ui::OZONEACTIONKEY_F14;
+        case XKB_KEY_XF86Launch6:
+          return  ui::OZONEACTIONKEY_F15;
+        case XKB_KEY_XF86Launch7:
+          return  ui::OZONEACTIONKEY_F16;
+        case XKB_KEY_XF86Launch8:
+          return  ui::OZONEACTIONKEY_F17;
+        case XKB_KEY_XF86Launch9:
+          return  ui::OZONEACTIONKEY_F18;
+
+        // For supporting multimedia buttons on a USB keyboard.
+        case XKB_KEY_XF86Back:
+          return  ui::OZONEACTIONKEY_BROWSER_BACK;
+        case XKB_KEY_XF86Forward:
+          return  ui::OZONEACTIONKEY_BROWSER_FORWARD;
+        case XKB_KEY_XF86Reload:
+          return  ui::OZONEACTIONKEY_BROWSER_REFRESH;
+        case XKB_KEY_XF86Stop:
+          return  ui::OZONEACTIONKEY_BROWSER_STOP;
+        case XKB_KEY_XF86Search:
+          return  ui::OZONEACTIONKEY_BROWSER_SEARCH;
+        case XKB_KEY_XF86Favorites:
+          return  ui::OZONEACTIONKEY_BROWSER_FAVORITES;
+        case XKB_KEY_XF86HomePage:
+          return  ui::OZONEACTIONKEY_BROWSER_HOME;
+        case XKB_KEY_XF86AudioMute:
+          return  ui::OZONEACTIONKEY_VOLUME_MUTE;
+        case XKB_KEY_XF86AudioLowerVolume:
+          return  ui::OZONEACTIONKEY_VOLUME_DOWN;
+        case XKB_KEY_XF86AudioRaiseVolume:
+          return  ui::OZONEACTIONKEY_VOLUME_UP;
+        case XKB_KEY_XF86AudioNext:
+          return  ui::OZONEACTIONKEY_MEDIA_NEXT_TRACK;
+        case XKB_KEY_XF86AudioPrev:
+          return  ui::OZONEACTIONKEY_MEDIA_PREV_TRACK;
+        case XKB_KEY_XF86AudioStop:
+          return  ui::OZONEACTIONKEY_MEDIA_STOP;
+        case XKB_KEY_XF86AudioPlay:
+          return  ui::OZONEACTIONKEY_MEDIA_PLAY_PAUSE;
+        case XKB_KEY_XF86Mail:
+          return  ui::OZONEACTIONKEY_MEDIA_LAUNCH_MAIL;
+        case XKB_KEY_XF86LaunchA:
+          return  ui::OZONEACTIONKEY_MEDIA_LAUNCH_APP1;
+        case XKB_KEY_XF86LaunchB:
+        case XKB_KEY_XF86Calculator:
+          return  ui::OZONEACTIONKEY_MEDIA_LAUNCH_APP2;
+        case XKB_KEY_XF86WLAN:
+          return  ui::OZONEACTIONKEY_WLAN;
+        case XKB_KEY_XF86PowerOff:
+          return  ui::OZONEACTIONKEY_POWER;
+        case XKB_KEY_XF86MonBrightnessDown:
+          return  ui::OZONEACTIONKEY_BRIGHTNESS_DOWN;
+        case XKB_KEY_XF86MonBrightnessUp:
+          return  ui::OZONEACTIONKEY_BRIGHTNESS_UP;
+        case XKB_KEY_XF86KbdBrightnessDown:
+          return  ui::OZONEACTIONKEY_KBD_BRIGHTNESS_DOWN;
+        case XKB_KEY_XF86KbdBrightnessUp:
+          return  ui::OZONEACTIONKEY_KBD_BRIGHTNESS_UP;
+        case XKB_KEY_emptyset:
+        case XKB_KEY_NoSymbol:
+          return  ui::OZONECHARCODE_NULL;
+        default:
+          break;
+    }
+  }
+}
+}
+
+// TODO: Is handle really needed?
+om::Keyboard::Keyboard(ui::EventConverterOzoneWayland *sink, unsigned handle)
+  : sink(sink),
+    handle(handle) {
+    }
+
+om::Keyboard::~Keyboard() {
+}
+
+void om::Keyboard::handle_key_event(MirKeyEvent const& kev) {
+  ui::EventType type = kev.action == mir_key_action_down ? ui::ET_KEY_PRESSED : ui::ET_KEY_RELEASED;
+    
+  sink->KeyNotify(type, NormalizeKeysym(kev.key_code),
+                  TranslateMirModifiers(kev.modifiers));
+
+}
--- /dev/null
+++ b/ozone/mir/mir_keyboard.h
@@ -0,0 +1,37 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Copyright 2014 Canonical LTD. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_MIR_KEYBOARD_H_
+#define OZONE_MIR_KEYBOARD_H_
+
+#include "base/basictypes.h"
+
+#include <mir_toolkit/mir_client_library.h>
+
+namespace ui
+{
+class EventConverterOzoneWayland;
+}
+
+namespace ozonemir {
+
+class Keyboard {
+public:
+  Keyboard(ui::EventConverterOzoneWayland *sink, unsigned handle);
+  ~Keyboard();
+
+  void handle_key_event(MirKeyEvent const& kev);
+    
+protected:
+  DISALLOW_COPY_AND_ASSIGN(Keyboard);
+
+private:
+  ui::EventConverterOzoneWayland* const sink;
+  unsigned const handle;
+};
+
+}  // namespace ozonemir
+
+#endif  // OZONE_MIR_KEYBOARD_H_
--- /dev/null
+++ b/ozone/mir/mir_pointer.cc
@@ -0,0 +1,63 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Copyright 2014 Canonical LTD. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/mir/mir_pointer.h"
+#include "ozone/ui/events/event_converter_ozone_wayland.h"
+
+namespace om = ozonemir;
+
+om::Pointer::Pointer(ui::EventConverterOzoneWayland *sink, unsigned handle)
+  : sink(sink),
+    handle(handle) {
+  for (int i = 0; i < num_buttons; i++)
+    button_depressed[i] = false;
+}
+
+om::Pointer::~Pointer() {
+}
+
+void om::Pointer::handle_motion_event(MirMotionEvent const& mev) {
+  // TODO: Tracking the button state like this is a pain...
+  static int const num_buttons = 3;
+  static MirMotionButton buttons[3] = {mir_motion_button_primary,
+                                       mir_motion_button_secondary,
+                                       mir_motion_button_tertiary};
+  static ui::EventFlags ozone_buttons[3] = {ui::EF_LEFT_MOUSE_BUTTON,
+                                            ui::EF_RIGHT_MOUSE_BUTTON,
+                                            ui::EF_MIDDLE_MOUSE_BUTTON};
+                                    
+  if (mev.action == mir_motion_action_down ||
+      mev.action == mir_motion_action_up)
+    {
+      for (int i = 0; i < num_buttons; i++)
+        {
+          auto state = mev.button_state & buttons[i];
+          if (state != button_depressed[i])
+            {
+              // TODO: Modifiers?
+              ui::EventFlags flags;
+              flags = ozone_buttons[i];
+
+              ui::EventType type = mev.action == mir_motion_action_down ? ui::ET_MOUSE_PRESSED : ui::ET_MOUSE_RELEASED;
+
+              sink->ButtonNotify(handle, type, 
+                                 flags, mev.pointer_coordinates[0].x,
+                                 mev.pointer_coordinates[0].y);
+
+            }
+          button_depressed[i] = state;
+        }
+    }
+  else if (mev.action == mir_motion_action_move) {
+    sink->MotionNotify(mev.pointer_coordinates[0].x,
+                       mev.pointer_coordinates[0].y);
+  }
+  else if (mev.action == mir_motion_action_hover_enter) {
+    sink->PointerEnter(handle, mev.pointer_coordinates[0].x, mev.pointer_coordinates[0].y);
+  }
+  else if (mev.action == mir_motion_action_hover_exit) {
+    sink->PointerLeave(handle, mev.pointer_coordinates[0].x, mev.pointer_coordinates[0].y);
+  }
+}
--- /dev/null
+++ b/ozone/mir/mir_pointer.h
@@ -0,0 +1,41 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Copyright 2014 Canonical LTD. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_MIR_POINTER_H_
+#define OZONE_MIR_POINTER_H_
+
+#include "base/basictypes.h"
+
+#include <mir_toolkit/mir_client_library.h>
+
+namespace ui
+{
+class EventConverterOzoneWayland;
+}
+
+namespace ozonemir {
+
+class Pointer {
+public:
+  Pointer(ui::EventConverterOzoneWayland *sink, unsigned handle);
+  ~Pointer();
+
+  void handle_motion_event(MirMotionEvent const& mev);
+    
+protected:
+  DISALLOW_COPY_AND_ASSIGN(Pointer);
+
+private:
+  ui::EventConverterOzoneWayland* const sink;
+  unsigned const handle;
+  
+  // We only support the basic 3 buttons in ozone...
+  static int const num_buttons = 3;
+  bool button_depressed[num_buttons];
+};
+
+}  // namespace ozonemir
+
+#endif  // OZONE_MIR_POINTER_H_
--- /dev/null
+++ b/ozone/mir/mir_window.cc
@@ -0,0 +1,235 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Copyright 2014 Canonical LTD. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/mir/mir_window.h"
+#include "ozone/mir/mir_pointer.h"
+#include "ozone/mir/mir_keyboard.h"
+
+#include "base/memory/scoped_ptr.h"
+#include "ui/events/event.h"
+
+#include "content/child/child_thread.h"
+#include "content/child/child_process.h"
+
+#include "ui/ozone/public/surface_ozone_egl.h"
+
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/ui/events/event_converter_ozone_wayland.h"
+// TODO: #include "ozone/ui/ime/keyboard_engine_xkb.h"
+
+// TODO: This is in the wrong place.
+#include "ozone/ui/gfx/vsync_provider_wayland.h"
+
+namespace om = ozonemir;
+
+namespace
+{
+MirPixelFormat choose_pixel_format(MirConnection *connection) {
+  MirPixelFormat format;
+  unsigned int got_formats;
+  mir_connection_get_available_surface_formats(connection, &format, 1, &got_formats);
+  DCHECK(got_formats > 0);
+
+  return format;
+}
+}
+
+om::Window::Window(MirConnection *connection, unsigned handle)
+  : connection_(connection),
+    handle_(handle),
+    surface_(0),
+    processing_events_(false),
+    motion_event_handler_(new om::Pointer(ui::EventFactoryOzoneWayland::GetInstance()->EventConverter(), handle)),
+    key_event_handler_(new om::Keyboard(ui::EventFactoryOzoneWayland::GetInstance()->EventConverter(), handle)) {
+  
+  LOG(ERROR) << "ozonemir::Window::Window";
+  DCHECK(mir_connection_is_valid(connection_));
+
+  MirSurfaceParameters parameters = {
+      "Ozone", // TODO: Mir needs to support changing window title
+      0, 0, // Let WM Choose initial width/height
+      choose_pixel_format(connection),
+      mir_buffer_usage_hardware,
+      mir_display_output_id_invalid
+  };
+  surface_ = mir_connection_create_surface_sync(connection, &parameters);
+
+  NotifyResize();
+}
+
+om::Window::~Window() {
+  LOG(ERROR) << "ozonemir::Window::~Window";
+  DCHECK(mir_surface_is_valid(surface_));
+
+  mir_surface_release_sync(surface_);
+
+  delete motion_event_handler_;
+  delete key_event_handler_;
+}
+
+void om::Window::SetWindowType(ui::WidgetType type) {
+  LOG(ERROR) << "ozonemir::Window::SetWindowType";
+  DCHECK(mir_surface_is_valid(surface_));
+
+  switch (type)
+  {
+  case ui::WINDOW:
+    mir_surface_set_type(surface_, mir_surface_type_normal);
+    break;
+  case ui::WINDOWFRAMELESS: // ?
+    mir_surface_set_type(surface_, mir_surface_type_freestyle);
+    break;
+  case ui::POPUP:
+    // TODO: ~racarr
+    break;
+  default:
+    // TODO: ~racarr
+    break;
+  }
+}
+
+void om::Window::SetWindowTitle(base::string16 const& title) {
+  LOG(ERROR) << "ozonemir::Window::SetWindowTitle";
+  // TODO: Mir needs to support this
+}
+
+
+/* TODO: Does this block of state changing need to be synchronous? ~racarr */
+void om::Window::Maximize() {
+  DCHECK(mir_surface_is_valid(surface_));
+  mir_surface_set_state(surface_, mir_surface_state_maximized);
+}
+
+void om::Window::Minimize() {
+  DCHECK(mir_surface_is_valid(surface_));
+  mir_surface_set_state(surface_, mir_surface_state_minimized);
+}
+
+void om::Window::Restore() {
+  DCHECK(mir_surface_is_valid(surface_));
+  mir_surface_set_state(surface_, mir_surface_state_restored);
+}
+
+void om::Window::SetFullscreen() {
+  DCHECK(mir_surface_is_valid(surface_));
+  mir_surface_set_state(surface_, mir_surface_state_fullscreen);
+}
+
+unsigned om::Window::Handle() const {
+  return handle_;
+}
+
+void om::Window::RealizeAcceleratedWidget() {
+// TODO: Remove?
+}
+
+intptr_t om::Window::egl_window() {
+  DCHECK(mir_surface_is_valid(surface_));
+  
+  // We use this as like a realize step..for whatever reason
+  StartProcessingEvents();
+
+  return reinterpret_cast<intptr_t>(mir_surface_get_egl_native_window(surface_));
+}
+
+void om::Window::Resize(unsigned width, unsigned height) {
+  LOG(INFO) << __PRETTY_FUNCTION__;
+  // TODO
+}
+
+gfx::Rect om::Window::GetBounds() const {
+  LOG(ERROR) << "ozonemir::Window::GetBounds";
+  DCHECK(mir_surface_is_valid(surface_));
+  MirSurfaceParameters params;
+  mir_surface_get_parameters(surface_, &params);
+  // TODO: Why do we want X/Y ~racarr
+  // TODO: Does chromium require any sort of guarantees on X/Y for relative windos?
+  return gfx::Rect(0,0, params.width, params.height);
+}
+
+void om::Window::StartProcessingEvents() {
+  LOG(ERROR) << "ozonemir::Window::StartProcessingEvents";
+  processing_events_ = true;
+
+  MirEventDelegate d = {&om::Window::HandleEvent, this};
+  mir_surface_set_event_handler(surface_, &d);
+}
+
+void om::Window::StopProcessingEvents() {
+  processing_events_ = false;
+}
+
+void om::Window::HandleEvent(MirSurface *surface, MirEvent const *ev, void *context) {
+  om::Window *w = static_cast<om::Window*>(context);
+    
+  // TODO: Maybe it would be nice if Mir let us unregister the callback.
+  if (w->processing_events_ == false)
+    return;
+
+  switch(ev->type)
+  {
+  case mir_event_type_motion:
+    w->motion_event_handler_->handle_motion_event(ev->motion);
+    break;
+  case mir_event_type_key:
+    w->key_event_handler_->handle_key_event(ev->key);
+    break;
+  break;
+  default:
+    break;
+  }
+}
+
+void om::Window::NotifyResize() {
+  DCHECK(mir_surface_is_valid(surface_));
+
+  MirSurfaceParameters params;
+  mir_surface_get_parameters(surface_, &params);
+
+  ui::EventConverterOzoneWayland  *sink = ui::EventFactoryOzoneWayland::GetInstance()
+      ->EventConverter();
+
+  DCHECK(sink);
+
+  sink->WindowResized(Handle(), params.width, params.height);
+}
+
+namespace
+{
+class SurfaceOzoneMir : public ui::SurfaceOzoneEGL
+{
+public:
+  explicit SurfaceOzoneMir(om::Window *w) :
+      window(w) {
+  }
+  
+  intptr_t GetNativeWindow() {
+      DCHECK(window);
+      return window->egl_window();
+  }
+
+  bool ResizeNativeWindow(const gfx::Size& viewport_size) {
+      DCHECK(window);
+      window->Resize(viewport_size.width(), viewport_size.height());
+  }
+
+  bool OnSwapBuffers() {
+      return true; // ?
+  }
+
+  scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider() {
+      // This does nothing for now so we just use waylands last stub.
+      return scoped_ptr<gfx::VSyncProvider>(new gfx::WaylandSyncProvider());        
+  }
+
+private:
+  // Consider using shared_ptr or id + display instance
+  om::Window *window; // TODO: Ownership?
+};
+}
+
+scoped_ptr<ui::SurfaceOzoneEGL> om::Window::CreateOzoneEGLSurface() {
+  return make_scoped_ptr<ui::SurfaceOzoneEGL>(new SurfaceOzoneMir(this));
+}
--- /dev/null
+++ b/ozone/mir/mir_window.h
@@ -0,0 +1,70 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Copyright 2014 Canonical LTD. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_MIR_WINDOW_H_
+#define OZONE_MIR_WINDOW_H_
+
+#include "ui/gfx/geometry/rect.h"
+#include "base/strings/string16.h"
+#include "ui/ozone/public/surface_ozone_egl.h" // TODO: Forward decl?
+
+#include "ozone/ui/events/window_constants.h"
+
+#include <mir_toolkit/mir_client_library.h>
+
+namespace ozonemir {
+class Pointer;
+class Keyboard;
+
+class Window {
+public:
+  Window(MirConnection *connection, unsigned handle);
+  ~Window();
+    
+  void Maximize();
+  void Minimize();
+  void Restore();
+  void SetFullscreen();
+    
+  unsigned Handle() const;
+    
+  void RealizeAcceleratedWidget();
+    
+  intptr_t egl_window();
+   
+  void Resize(unsigned width, unsigned height);
+  gfx::Rect GetBounds() const;
+
+  void StartProcessingEvents();
+  void StopProcessingEvents();
+
+  void SetWindowTitle(const base::string16& title);
+
+  void SetWindowType(ui::WidgetType type);
+  
+  scoped_ptr<ui::SurfaceOzoneEGL> CreateOzoneEGLSurface();
+
+protected:
+  DISALLOW_COPY_AND_ASSIGN(Window);
+
+private:
+  MirConnection *connection_;
+  unsigned handle_;
+
+  MirSurface *surface_;
+  
+  bool processing_events_;
+
+  ozonemir::Pointer *motion_event_handler_;
+  ozonemir::Keyboard *key_event_handler_;
+
+  static void HandleEvent(MirSurface *surface, MirEvent const* ev, void *context);
+
+  void NotifyResize();
+};
+
+}  // namespace ozonemir
+
+#endif  // OZONE_MIR_WINDOW_H_
--- /dev/null
+++ b/ozone/ozone_impl.gyp
@@ -0,0 +1,55 @@
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Copyright 2013 Intel Corporation. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'targets': [
+    {
+      'target_name': 'wayland',
+      'type': '<(component)',
+      'dependencies': [
+        '<(DEPTH)/skia/skia.gyp:skia',
+        '<(DEPTH)/base/third_party/dynamic_annotations/dynamic_annotations.gyp:dynamic_annotations',
+      ],
+      'variables': { 'use_ozone_mir%' : 1, 'use_ozone_wayland%' : 0},
+      'conditions': [
+        ['use_ozone_mir==1', {            
+          'dependencies': [ 'mir/mir.gyp:mir_toolkit',
+                            'wayland/wayland.gyp:wayland_toolkit',
+          ],
+          'sources': [
+              'platform/ozone_export_wayland.h',
+              'platform/ozone_platform_mir.cc',
+              'platform/ozone_platform_mir.h',
+              'platform/ozone_platform_wayland.cc',
+              'platform/ozone_platform_wayland.h',
+           ],
+           'cflags': [
+              '-std=c++11',
+              '-Igen',
+           ],
+        }],
+        ['use_ozone_wayland==1', {
+          'dependencies': [ 'wayland/wayland.gyp:wayland_toolkit'
+          ],
+          'sources': [
+              'platform/ozone_export_wayland.h',
+              'platform/ozone_platform_wayland.cc',
+              'platform/ozone_platform_wayland.h',
+           ],
+        }],          
+      ],
+      'include_dirs': [
+        '..',
+      ],
+      'includes': [
+        'ui/ui.gypi',
+        #'media/video.gypi',
+      ],
+      'defines': [
+        'OZONE_WAYLAND_IMPLEMENTATION',
+      ],
+    },
+  ]
+}
--- /dev/null
+++ b/ozone/platform/DEPS
@@ -0,0 +1,7 @@
+include_rules = [
+  "+ozone/platform",
+  "+ozone/ui/desktop_aura/",
+  "+ozone/ui/events",
+  "+ozone/ui/gfx",
+  "+ui/ozone",
+]
--- /dev/null
+++ b/ozone/platform/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/platform/ozone_export_wayland.h
@@ -0,0 +1,14 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_EXPORT_H_
+#define OZONE_EXPORT_H_
+
+#if defined(COMPONENT_BUILD) && defined(OZONE_WAYLAND_IMPLEMENTATION)
+  #define OZONE_WAYLAND_EXPORT __attribute__ ((visibility ("default")))
+#else
+  #define OZONE_WAYLAND_EXPORT
+#endif
+
+#endif  // OZONE_EXPORT_H_
--- /dev/null
+++ b/ozone/platform/ozone_platform_mir.cc
@@ -0,0 +1,15 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/platform/ozone_platform_mir.h"
+
+namespace ui {
+
+OzonePlatformMir::OzonePlatformMir() {}
+
+OzonePlatformMir::~OzonePlatformMir() {}
+
+OzonePlatform* CreateOzonePlatformMir() { return new OzonePlatformMir; }
+
+}  // namespace ui
--- /dev/null
+++ b/ozone/platform/ozone_platform_mir.h
@@ -0,0 +1,76 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_PLATFORM_OZONE_PLATFORM_MIR_H_
+#define OZONE_PLATFORM_OZONE_PLATFORM_MIR_H_
+
+#include "ozone/ui/cursor/cursor_factory_ozone_wayland.h"
+#if defined(TOOLKIT_VIEWS) && !defined(OS_CHROMEOS)
+#include "ozone/ui/desktop_aura/desktop_factory_wayland.h"
+#endif
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+//#include "ozone/ui/ime/input_method_context_factory_wayland.h"
+#include "ozone/mir/mir_display.h"
+#include "ui/ozone/public/cursor_factory_ozone.h"
+//#include "ui/ozone/ime/input_method_context_factory_ozone.h"
+#include "ui/ozone/public/ozone_platform.h"
+
+namespace ui {
+
+// OzonePlatform for Mir
+//
+// This platform is Linux with the mir display server.
+class OzonePlatformMir : public OzonePlatform {
+ public:
+  OzonePlatformMir();
+  ~OzonePlatformMir();
+
+  virtual scoped_ptr<PlatformWindow> CreatePlatformWindow(
+      PlatformWindowDelegate* delegate,
+      const gfx::Rect& bounds) override {
+    // FIXME(chad): implement
+  }
+
+  virtual inline ui::SurfaceFactoryOzone* GetSurfaceFactoryOzone() override {
+      return &hardware_display_;
+  }
+
+  virtual inline ui::CursorFactoryOzone* GetCursorFactoryOzone() override {
+    return NULL; // FIXME(chad)   def?    &cursor_factory_ozone_;
+  }
+
+#if 0
+  virtual inline ui::InputMethodContextFactoryOzone* GetInputMethodContextFactoryOzone() override {
+    return &input_method_context_factory_ozone_;
+  }
+#endif
+
+  virtual void InitializeGPU() override {}
+
+  virtual void InitializeUI() override {}
+
+  virtual ui::GpuPlatformSupport* GetGpuPlatformSupport() { return NULL; }
+
+  virtual ui::GpuPlatformSupportHost* GetGpuPlatformSupportHost() { return NULL; }
+  
+ private:
+  ozonemir::Display hardware_display_;
+#if 0
+  ui::EventFactoryOzoneWayland event_factory_ozone_;
+  ui::CursorFactoryOzoneWayland cursor_factory_ozone_;
+  ui::InputMethodContextFactoryOzone input_method_context_factory_ozone_;
+#endif
+#if defined(TOOLKIT_VIEWS) && !defined(OS_CHROMEOS)
+  views::DesktopFactoryWayland desktop_factory_ozone_;
+#endif
+
+  DISALLOW_COPY_AND_ASSIGN(OzonePlatformMir);
+};
+
+// Constructor hook for use in ozone_platform_list.cc
+OZONE_WAYLAND_EXPORT OzonePlatform* CreateOzonePlatformMir();
+
+}  // namespace ui
+
+#endif  // OZONE_PLATFORM_OZONE_PLATFORM_MIR_H_
--- /dev/null
+++ b/ozone/platform/ozone_platform_wayland.cc
@@ -0,0 +1,96 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/platform/ozone_platform_wayland.h"
+
+#include "ozone/ui/cursor/cursor_factory_ozone_wayland.h"
+#if defined(TOOLKIT_VIEWS) && !defined(OS_CHROMEOS)
+#include "ozone/ui/desktop_aura/desktop_factory_wayland.h"
+#endif
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/ui/ime/input_method_context_factory_wayland.h"
+#include "ozone/wayland/display.h"
+#include "ozone/wayland/proxy_display.h"
+#include "ui/ozone/public/cursor_factory_ozone.h"
+#include "ui/ozone/public/ozone_platform.h"
+
+namespace ui {
+
+namespace {
+
+// OzonePlatform for Wayland
+//
+// This platform is Linux with the Wayland display server.
+class OzonePlatformWayland : public OzonePlatform {
+ public:
+  OzonePlatformWayland() : wayland_proxy_display_(NULL) {}
+
+  virtual ~OzonePlatformWayland() {
+    delete wayland_proxy_display_;
+  }
+
+  // OzonePlatform:
+  virtual ui::SurfaceFactoryOzone* GetSurfaceFactoryOzone() override {
+    return wayland_display_.get();
+  }
+  virtual ui::CursorFactoryOzone* GetCursorFactoryOzone() override {
+    return cursor_factory_ozone_.get();
+  }
+
+  virtual void InitializeUI() override {
+    input_method_factory_.reset(
+        new ui::InputMethodContextFactoryWayland());
+    event_factory_ozone_.reset(
+        new ui::EventFactoryOzoneWayland());
+    cursor_factory_ozone_.reset(new ui::CursorFactoryOzoneWayland());
+    wayland_proxy_display_ = new ozonewayland::WaylandProxyDisplay();
+  }
+
+  virtual GpuPlatformSupport* GetGpuPlatformSupport() override {
+    return NULL;
+    //return gpu_platform_support_.get();
+  }
+  virtual GpuPlatformSupportHost* GetGpuPlatformSupportHost() override {
+    return NULL;
+    //return gpu_platform_support_host_.get();
+  }
+
+  virtual void InitializeGPU() override {
+    // We don't need proxy display in case of Single process.
+    // TODO(kalyan): Find a better way to handle this.
+    if (wayland_proxy_display_) {
+      delete wayland_proxy_display_;
+      wayland_proxy_display_ = NULL;
+    }
+
+    wayland_display_.reset(new ozonewayland::WaylandDisplay());
+    if (!event_factory_ozone_)
+      event_factory_ozone_.reset(new ui::EventFactoryOzoneWayland());
+  }
+
+  virtual scoped_ptr<PlatformWindow> CreatePlatformWindow(
+      PlatformWindowDelegate* delegate,
+      const gfx::Rect& bounds) override {
+    // FIXME(chad): implement
+  }
+  //
+  //virtual bool IsTranslucentWindowOpacitySupported() const { return true; }
+
+ private:
+#if defined(TOOLKIT_VIEWS) && !defined(OS_CHROMEOS)
+  views::DesktopFactoryWayland desktop_factory_ozone_;
+#endif
+  ozonewayland::WaylandProxyDisplay* wayland_proxy_display_;
+  scoped_ptr<ui::InputMethodContextFactoryWayland> input_method_factory_;
+  scoped_ptr<ui::EventFactoryOzoneWayland> event_factory_ozone_;
+  scoped_ptr<ui::CursorFactoryOzoneWayland> cursor_factory_ozone_;
+  scoped_ptr<ozonewayland::WaylandDisplay> wayland_display_;
+  DISALLOW_COPY_AND_ASSIGN(OzonePlatformWayland);
+};
+
+}  // namespace
+
+OzonePlatform* CreateOzonePlatformWayland() { return new OzonePlatformWayland; }
+
+}  // namespace ui
--- /dev/null
+++ b/ozone/platform/ozone_platform_wayland.h
@@ -0,0 +1,19 @@
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_PLATFORM_OZONE_PLATFORM_WAYLAND_H_
+#define OZONE_PLATFORM_OZONE_PLATFORM_WAYLAND_H_
+
+#include "ozone/platform/ozone_export_wayland.h"
+
+namespace ui {
+
+class OzonePlatform;
+
+// Constructor hook for use in ozone_platform_list.cc
+OZONE_WAYLAND_EXPORT OzonePlatform* CreateOzonePlatformWayland();
+
+}  // namespace ui
+
+#endif  // OZONE_PLATFORM_OZONE_PLATFORM_WAYLAND_H_
--- /dev/null
+++ b/ozone/supplement.gypi
@@ -0,0 +1,41 @@
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Copyright 2013 Intel Corporation. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'variables':  {
+    'ozone_platform_wayland%': 1,
+    'ozone_platform_mir%': 1,
+  },
+  'conditions': [
+    ['<(ozone_platform_wayland) == 1 or <(ozone_platform_mir) == 1', {
+      'variables':  {
+        'external_ozone_platform_deps': [
+          '<(DEPTH)/ozone/ozone_impl.gyp:wayland',
+        ],
+        'external_ozone_views_files': [
+          '<(DEPTH)/ozone/ui/desktop_aura/desktop_drag_drop_client_wayland.cc',
+          '<(DEPTH)/ozone/ui/desktop_aura/desktop_drag_drop_client_wayland.h',
+          '<(DEPTH)/ozone/ui/desktop_aura/desktop_factory_wayland.cc',
+          '<(DEPTH)/ozone/ui/desktop_aura/desktop_factory_wayland.h',
+          '<(DEPTH)/ozone/ui/desktop_aura/desktop_screen_wayland.cc',
+          '<(DEPTH)/ozone/ui/desktop_aura/desktop_screen_wayland.h',
+          '<(DEPTH)/ozone/ui/desktop_aura/desktop_window_tree_host_wayland.cc',
+          '<(DEPTH)/ozone/ui/desktop_aura/desktop_window_tree_host_wayland.h',
+          '<(DEPTH)/ozone/ui/desktop_aura/ozone_util.cc',
+          '<(DEPTH)/ozone/ui/desktop_aura/ozone_util.h',
+          '<(DEPTH)/ozone/ui/desktop_aura/window_tree_host_delegate_wayland.cc',
+          '<(DEPTH)/ozone/ui/desktop_aura/window_tree_host_delegate_wayland.h',
+        ],
+        'external_ozone_platforms': [
+          'mir', 'wayland',
+        ],
+        'ozone_platform%': 'mir',
+      },
+    }],
+  ],
+}
+
+
+
--- /dev/null
+++ b/ozone/tools/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/tools/check-coding-style.sh
@@ -0,0 +1,30 @@
+#!/bin/bash
+# Copyright (c) 2014 Intel Corporation. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# stolen from https://github.com/crosswalk-project/tizen-extensions-crosswalk
+
+if [ ! `which cpplint.py` ]; then
+   echo -en "\nPlease make sure cpplint.py is in your PATH. "
+   echo -e "It is part of depot_tools inside Chromium repository."
+   exit 1
+fi
+
+# Store current dir and change to repository root dir.
+OLD_PWD=$PWD
+SELF_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+cd $SELF_DIR/..
+
+# TODO(vignatti): maybe we should remove the OZONE_ prefix from all header
+# guards and activate
+FILTERS="+build,-build/header_guard,+whitespace,+readability,+legal,+runtime"
+
+cpplint.py --filter="$FILTERS" $(find \
+                               \( -name '*.h' -o -name '*.cc' \) | grep -v text-client-protocol.h \
+                                                                 | grep -v xdg-shell-client-protocol.h)
+
+# Return to previous dir and return the code returned by cpplint.py
+RET_VAL=$?
+cd $OLD_PWD
+exit $RET_VAL
--- /dev/null
+++ b/ozone/tools/export-chromium-browser-binary.txt
@@ -0,0 +1,23 @@
+# This file shows a very simple way to create a tarball (tar.gz) with a few
+# essential files including the Chromium binary, in which a regular user will
+# be able to play around with Chromium Wayland Browser.
+#
+# IMPORTANT: by no means this is a definitive solution for packaging Chromium
+# Wayland Browser in your distribution. Please refer to this link for more
+# information:
+#
+# https://github.com/01org/ozone-wayland/wiki/Packaging-and-Release-Process
+#
+# TODO(vignatti): build a python script and automate the instructions mentioned
+# below.
+
+first I've made sure everything inside src/out/Release/ concerns Chromium only,
+i.e. only chrome target was compiled and nothing else before.
+
+$ cd src/out/
+
+$ mkdir chromium-wayland/
+
+$ rsync -a -v --exclude=content_shell* --exclude=gen --exclude=obj Release/ chromium-wayland/
+
+$ tar czvf chromium-wayland.tar.gz chromium-wayland/
--- /dev/null
+++ b/ozone/ui/DEPS
@@ -0,0 +1,4 @@
+include_rules = [
+  # Components within ui must state their dependencies explicitly.
+  "-ui",
+]
--- /dev/null
+++ b/ozone/ui/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/ui/cursor/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/ui/cursor/cursor.gypi
@@ -0,0 +1,13 @@
+# Copyright 2014 Intel Corporation. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'dependencies': [
+    '<(DEPTH)/ui/base/ui_base.gyp:ui_base',
+  ],
+  'sources': [
+    'cursor_factory_ozone_wayland.h',
+    'cursor_factory_ozone_wayland.cc',
+  ],
+}
--- /dev/null
+++ b/ozone/ui/cursor/cursor_factory_ozone_wayland.cc
@@ -0,0 +1,33 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/cursor/cursor_factory_ozone_wayland.h"
+
+namespace ui {
+
+CursorFactoryOzoneWayland::CursorFactoryOzoneWayland() {}
+
+CursorFactoryOzoneWayland::~CursorFactoryOzoneWayland() {}
+
+PlatformCursor CursorFactoryOzoneWayland::GetDefaultCursor(int type) {
+  return NULL;
+}
+
+PlatformCursor CursorFactoryOzoneWayland::CreateImageCursor(
+    const SkBitmap& bitmap,
+    const gfx::Point& hotspot) {
+  return NULL;
+}
+
+void CursorFactoryOzoneWayland::RefImageCursor(PlatformCursor cursor) {
+}
+
+void CursorFactoryOzoneWayland::UnrefImageCursor(PlatformCursor cursor) {
+}
+
+//void CursorFactoryOzoneWayland::SetCursor(gfx::AcceleratedWidget widget,
+                                   //PlatformCursor cursor) {
+//}
+
+}  // namespace ui
--- /dev/null
+++ b/ozone/ui/cursor/cursor_factory_ozone_wayland.h
@@ -0,0 +1,28 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_CURSOR_CURSOR_FACTORY_OZONE_WAYLAND_H_
+#define OZONE_UI_CURSOR_CURSOR_FACTORY_OZONE_WAYLAND_H_
+
+#include "ui/ozone/public/cursor_factory_ozone.h"
+
+namespace ui {
+
+class CursorFactoryOzoneWayland : public CursorFactoryOzone {
+ public:
+  CursorFactoryOzoneWayland();
+  virtual ~CursorFactoryOzoneWayland();
+
+  virtual PlatformCursor GetDefaultCursor(int type) override;
+  virtual PlatformCursor CreateImageCursor(const SkBitmap& bitmap,
+                                           const gfx::Point& hotspot) override;
+  virtual void RefImageCursor(PlatformCursor cursor) override;
+  virtual void UnrefImageCursor(PlatformCursor cursor) override;
+  //virtual void SetCursor(gfx::AcceleratedWidget widget,
+                         //PlatformCursor cursor) override;
+};
+
+}  // namespace ui
+
+#endif  // OZONE_UI_CURSOR_CURSOR_FACTORY_OZONE_WAYLAND_H_
--- /dev/null
+++ b/ozone/ui/desktop_aura/DEPS
@@ -0,0 +1,16 @@
+include_rules = [
+  "+grit/ui_resources.h",
+  "+grit/ui_strings.h",
+  "+skia/ext",
+  "+third_party/iaccessible2",
+  "+third_party/skia",
+  "+ui/accessibility",
+  "+ui/aura",
+  "+ui/base",
+  "+ui/compositor",
+  "+ui/events",
+  "+ui/gfx",
+  "+ui/native_theme",
+  "+ui/ozone",
+  "+ui/wm/public",
+]
--- /dev/null
+++ b/ozone/ui/desktop_aura/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/ui/desktop_aura/desktop_drag_drop_client_wayland.cc
@@ -0,0 +1,49 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/desktop_aura/desktop_drag_drop_client_wayland.h"
+
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/dragdrop/drop_target_event.h"
+
+namespace views {
+
+DesktopDragDropClientWayland::DesktopDragDropClientWayland(
+    aura::Window* root_window) {
+  NOTIMPLEMENTED();
+}
+
+DesktopDragDropClientWayland::~DesktopDragDropClientWayland() {
+}
+
+int DesktopDragDropClientWayland::StartDragAndDrop(
+    const ui::OSExchangeData& data,
+    aura::Window* root_window,
+    aura::Window* source_window,
+    const gfx::Point& root_location,
+    int operation,
+    ui::DragDropTypes::DragEventSource source) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+void DesktopDragDropClientWayland::DragUpdate(aura::Window* target,
+                                              const ui::LocatedEvent& event) {
+  NOTIMPLEMENTED();
+}
+
+void DesktopDragDropClientWayland::Drop(aura::Window* target,
+                                        const ui::LocatedEvent& event) {
+  NOTIMPLEMENTED();
+}
+
+void DesktopDragDropClientWayland::DragCancel() {
+  NOTIMPLEMENTED();
+}
+
+bool DesktopDragDropClientWayland::IsDragDropInProgress() {
+  return false;
+}
+
+}  // namespace views
--- /dev/null
+++ b/ozone/ui/desktop_aura/desktop_drag_drop_client_wayland.h
@@ -0,0 +1,41 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_IMPL_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_WAYLAND_H_
+#define OZONE_IMPL_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_WAYLAND_H_
+
+#include "base/compiler_specific.h"
+#include "ui/views/views_export.h"
+#include "ui/wm/public/drag_drop_client.h"
+
+namespace views {
+
+class VIEWS_EXPORT DesktopDragDropClientWayland
+    : public aura::client::DragDropClient {
+ public:
+  explicit DesktopDragDropClientWayland(aura::Window* root_window);
+  virtual ~DesktopDragDropClientWayland();
+
+  // Overridden from aura::client::DragDropClient:
+  virtual int StartDragAndDrop(
+      const ui::OSExchangeData& data,
+      aura::Window* root_window,
+      aura::Window* source_window,
+      const gfx::Point& root_location,
+      int operation,
+      ui::DragDropTypes::DragEventSource source) override;
+  virtual void DragUpdate(aura::Window* target,
+                          const ui::LocatedEvent& event) override;
+  virtual void Drop(aura::Window* target,
+                    const ui::LocatedEvent& event) override;
+  virtual void DragCancel() override;
+  virtual bool IsDragDropInProgress() override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(DesktopDragDropClientWayland);
+};
+
+}  // namespace views
+
+#endif  // OZONE_IMPL_DESKTOP_AURA_DESKTOP_DRAG_DROP_CLIENT_WAYLAND_H_
--- /dev/null
+++ b/ozone/ui/desktop_aura/desktop_factory_wayland.cc
@@ -0,0 +1,43 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/desktop_aura/desktop_factory_wayland.h"
+
+#include "ozone/ui/desktop_aura/desktop_screen_wayland.h"
+#include "ozone/ui/desktop_aura/desktop_window_tree_host_wayland.h"
+#include "ui/views/window/non_client_view.h"
+#include "ozone/ui/gfx/ozone_display.h"
+
+namespace views {
+
+DesktopFactoryWayland::DesktopFactoryWayland() : views::DesktopFactoryOzone(),
+    desktop_screen_(NULL) {
+  LOG(INFO) << "Ozone: DesktopFactoryWayland";
+  DesktopFactoryOzone::SetInstance(this);
+}
+
+DesktopFactoryWayland::~DesktopFactoryWayland() {
+  DesktopFactoryOzone::SetInstance(NULL);
+  delete desktop_screen_;
+}
+
+DesktopWindowTreeHost* DesktopFactoryWayland::CreateWindowTreeHost(
+    internal::NativeWidgetDelegate* native_widget_delegate,
+    DesktopNativeWidgetAura* desktop_native_widget_aura) {
+  return new DesktopWindowTreeHostWayland(native_widget_delegate,
+                                          desktop_native_widget_aura);
+}
+
+//bool DesktopFactoryWayland::IsTranslucentWindowOpacitySupported() const { return true; }
+
+gfx::Screen* DesktopFactoryWayland::CreateDesktopScreen() {
+  if (!desktop_screen_) {
+    desktop_screen_ = new DesktopScreenWayland();
+    gfx::OzoneDisplay::GetInstance()->LookAheadOutputGeometry();
+  }
+
+  return desktop_screen_;
+}
+
+}  // namespace views
--- /dev/null
+++ b/ozone/ui/desktop_aura/desktop_factory_wayland.h
@@ -0,0 +1,43 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_IMPL_DESKTOP_AURA_DESKTOP_FACTORY_WAYLAND_H_
+#define OZONE_IMPL_DESKTOP_AURA_DESKTOP_FACTORY_WAYLAND_H_
+
+#include "base/compiler_specific.h"
+#include "ui/views/views_export.h"
+#include "ui/views/widget/desktop_aura/desktop_factory_ozone.h"
+#include "ui/views/window/non_client_view.h"
+
+namespace views {
+
+class DesktopScreenWayland;
+
+// Desktop support for wayland
+//
+// TODO(spang): Chromium needs to move desktop support into ui/base so we don't
+// reference views from ozone platform code. This module has an undeclared
+// dependency on views.
+class VIEWS_EXPORT DesktopFactoryWayland
+    : public DesktopFactoryOzone {
+ public:
+  DesktopFactoryWayland();
+  virtual ~DesktopFactoryWayland();
+
+  // views::DesktopFactoryOzone
+  virtual DesktopWindowTreeHost* CreateWindowTreeHost(
+      internal::NativeWidgetDelegate* native_widget_delegate,
+      DesktopNativeWidgetAura* desktop_native_widget_aura) override;
+
+  virtual gfx::Screen* CreateDesktopScreen() override;
+
+  //virtual bool IsTranslucentWindowOpacitySupported() const override;
+
+ private:
+  DesktopScreenWayland* desktop_screen_;
+};
+
+}  // namespace views
+
+#endif  //  OZONE_IMPL_DESKTOP_AURA_DESKTOP_FACTORY_WAYLAND_H_
--- /dev/null
+++ b/ozone/ui/desktop_aura/desktop_screen_wayland.cc
@@ -0,0 +1,152 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/desktop_aura/desktop_screen_wayland.h"
+
+#include "ozone/ui/desktop_aura/desktop_window_tree_host_wayland.h"
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ui/aura/window.h"
+
+namespace views {
+
+DesktopScreenWayland::DesktopScreenWayland()
+    : gfx::Screen(),
+      rect_(0, 0, 0, 0),
+      displays_() {
+  ui::EventFactoryOzoneWayland::GetInstance()->SetOutputChangeObserver(this);
+}
+
+DesktopScreenWayland::~DesktopScreenWayland() {
+}
+
+void DesktopScreenWayland::SetGeometry(const gfx::Rect& geometry) {
+  rect_ = geometry;
+  int max_area = 0;
+  const gfx::Display* matching = NULL;
+  for (std::vector<gfx::Display>::const_iterator it = displays_.begin();
+       it != displays_.end(); ++it) {
+    gfx::Rect intersect = gfx::IntersectRects(it->bounds(), rect_);
+    int area = intersect.width() * intersect.height();
+    if (area > max_area) {
+      max_area = area;
+      matching = &*it;
+    }
+  }
+
+  if (!matching)
+    displays_.push_back(gfx::Display(displays_.size(), rect_));
+}
+
+bool DesktopScreenWayland::IsDIPEnabled() {
+  return false;
+}
+
+gfx::Point DesktopScreenWayland::GetCursorScreenPoint() {
+  return gfx::Point();
+}
+
+gfx::NativeWindow DesktopScreenWayland::GetWindowUnderCursor() {
+  return NULL;
+}
+
+gfx::NativeWindow DesktopScreenWayland::GetWindowAtScreenPoint(
+    const gfx::Point& point) {
+  const std::vector<aura::Window*>& windows =
+      views::DesktopWindowTreeHostWayland::GetAllOpenWindows();
+  for (std::vector<aura::Window*>::const_iterator it = windows.begin();
+         it != windows.end(); ++it) {
+    if ((*it)->GetBoundsInScreen().Contains(point))
+      return *it;
+  }
+
+  return NULL;
+}
+
+int DesktopScreenWayland::GetNumDisplays() const {
+  return displays_.size();
+}
+
+std::vector<gfx::Display> DesktopScreenWayland::GetAllDisplays() const {
+  return displays_;
+}
+
+gfx::Display DesktopScreenWayland::GetDisplayNearestWindow(
+    gfx::NativeView window) const {
+  DCHECK(!rect_.IsEmpty());
+  if (displays_.size() == 1)
+    return displays_.front();
+  // Getting screen bounds here safely is hard.
+  //
+  // You'd think we'd be able to just call window->GetBoundsInScreen(), but we
+  // can't because |window| (and the associated RootWindow*) can be partially
+  // initialized at this point; RootWindow initializations call through into
+  // GetDisplayNearestWindow(). But the wayland resources are created before we
+  // create the aura::RootWindow. So we ask what the DRWH believes the
+  // window bounds are instead of going through the aura::Window's screen
+  // bounds.
+  aura::WindowTreeHost* host = window->GetHost();
+  if (host) {
+    DesktopWindowTreeHostWayland* rwh =
+        DesktopWindowTreeHostWayland::GetHostForAcceleratedWidget(
+            host->GetAcceleratedWidget());
+    if (rwh)
+      return GetDisplayMatching(rwh->GetBoundsInScreen());
+  }
+
+  return GetPrimaryDisplay();
+}
+
+gfx::Display DesktopScreenWayland::GetDisplayNearestPoint(
+    const gfx::Point& point) const {
+  if (displays_.size() == 1)
+    return displays_.front();
+
+  for (std::vector<gfx::Display>::const_iterator it = displays_.begin();
+         it != displays_.end(); ++it) {
+    if (it->bounds().Contains(point))
+      return *it;
+  }
+
+  return GetPrimaryDisplay();
+}
+
+gfx::Display DesktopScreenWayland::GetDisplayMatching(
+    const gfx::Rect& match_rect) const {
+  if (displays_.size() == 1)
+    return displays_.front();
+
+  DCHECK(!rect_.IsEmpty());
+  int max_area = 0;
+  const gfx::Display* matching = NULL;
+  for (std::vector<gfx::Display>::const_iterator it = displays_.begin();
+       it != displays_.end(); ++it) {
+    gfx::Rect intersect = gfx::IntersectRects(it->bounds(), match_rect);
+    int area = intersect.width() * intersect.height();
+    if (area > max_area) {
+      max_area = area;
+      matching = &*it;
+    }
+  }
+
+  // Fallback to the primary display if there is no matching display.
+  return matching ? *matching : GetPrimaryDisplay();
+}
+
+gfx::Display DesktopScreenWayland::GetPrimaryDisplay() const {
+  DCHECK(!rect_.IsEmpty());
+  return displays_.front();
+}
+
+void DesktopScreenWayland::AddObserver(gfx::DisplayObserver* observer) {
+}
+
+void DesktopScreenWayland::RemoveObserver(gfx::DisplayObserver* observer) {
+}
+
+void DesktopScreenWayland::OnOutputSizeChanged(unsigned width,
+                                               unsigned height) {
+  SetGeometry(gfx::Rect(0, 0, width, height));
+}
+
+}  // namespace views
--- /dev/null
+++ b/ozone/ui/desktop_aura/desktop_screen_wayland.h
@@ -0,0 +1,56 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_IMPL_DESKTOP_AURA_DESKTOP_SCREEN_WAYLAND_H__
+#define OZONE_IMPL_DESKTOP_AURA_DESKTOP_SCREEN_WAYLAND_H__
+
+#include <vector>
+
+#include "ozone/ui/events/output_change_observer.h"
+#include "ui/gfx/screen.h"
+
+namespace aura {
+class Window;
+}
+
+namespace views {
+
+class DesktopScreenWayland : public gfx::Screen,
+                             public ui::OutputChangeObserver {
+ public:
+  DesktopScreenWayland();
+  virtual ~DesktopScreenWayland();
+
+  // OutputChangeObserver overrides.
+  virtual void OnOutputSizeChanged(unsigned width, unsigned height) override;
+
+ private:
+  void SetGeometry(const gfx::Rect& geometry);
+  // Overridden from gfx::Screen:
+  virtual bool IsDIPEnabled() override;
+  virtual gfx::Point GetCursorScreenPoint() override;
+  virtual gfx::NativeWindow GetWindowUnderCursor() override;
+  virtual gfx::NativeWindow GetWindowAtScreenPoint(const gfx::Point& point)
+      override;
+  virtual int GetNumDisplays() const override;
+  virtual std::vector<gfx::Display> GetAllDisplays() const override;
+  virtual gfx::Display GetDisplayNearestWindow(
+      gfx::NativeView window) const override;
+  virtual gfx::Display GetDisplayNearestPoint(
+      const gfx::Point& point) const override;
+  virtual gfx::Display GetDisplayMatching(
+      const gfx::Rect& match_rect) const override;
+  virtual gfx::Display GetPrimaryDisplay() const override;
+  virtual void AddObserver(gfx::DisplayObserver* observer) override;
+  virtual void RemoveObserver(gfx::DisplayObserver* observer) override;
+
+  gfx::Rect rect_;
+  // The display objects we present to chrome.
+  std::vector<gfx::Display> displays_;
+  DISALLOW_COPY_AND_ASSIGN(DesktopScreenWayland);
+};
+
+}  // namespace views
+
+#endif  // OZONE_IMPL_DESKTOP_AURA_DESKTOP_SCREEN_WAYLAND_H__
--- /dev/null
+++ b/ozone/ui/desktop_aura/desktop_window_tree_host_wayland.cc
@@ -0,0 +1,820 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/desktop_aura/desktop_window_tree_host_wayland.h"
+
+#include <string>
+
+#include "base/bind.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ozone/ui/desktop_aura/desktop_drag_drop_client_wayland.h"
+#include "ozone/ui/desktop_aura/desktop_screen_wayland.h"
+#include "ozone/ui/desktop_aura/window_tree_host_delegate_wayland.h"
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/ui/events/window_state_change_handler.h"
+#include "ui/aura/client/cursor_client.h"
+#include "ui/aura/client/focus_client.h"
+#include "ui/aura/window_property.h"
+#include "ui/base/dragdrop/os_exchange_data_provider_aura.h"
+#include "ui/base/ime/composition_text.h"
+#include "ui/base/ime/input_method.h"
+#include "ui/base/ime/input_method_auralinux.h"
+#include "ui/events/event_utils.h"
+#include "ui/gfx/insets.h"
+#include "ui/ozone/public/surface_factory_ozone.h"
+#include "ui/native_theme/native_theme.h"
+#include "ui/views/corewm/tooltip_aura.h"
+#include "ui/views/ime/input_method.h"
+#include "ui/views/linux_ui/linux_ui.h"
+#include "ui/views/views_export.h"
+#include "ui/views/widget/desktop_aura/desktop_dispatcher_client.h"
+#include "ui/views/widget/desktop_aura/desktop_native_cursor_manager.h"
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+#include "ui/views/widget/desktop_aura/desktop_screen_position_client.h"
+#include "ui/wm/core/input_method_event_filter.h"
+#include "ui/wm/core/window_util.h"
+#include "ui/wm/public/window_move_client.h"
+
+namespace views {
+
+WindowTreeHostDelegateWayland*
+    DesktopWindowTreeHostWayland::g_delegate_ozone_wayland_ = NULL;
+
+DEFINE_WINDOW_PROPERTY_KEY(
+    aura::Window*, kViewsWindowForRootWindow, NULL);
+
+DEFINE_WINDOW_PROPERTY_KEY(
+    DesktopWindowTreeHostWayland*, kHostForRootWindow, NULL);
+
+DesktopWindowTreeHostWayland::DesktopWindowTreeHostWayland(
+    internal::NativeWidgetDelegate* native_widget_delegate,
+    DesktopNativeWidgetAura* desktop_native_widget_aura)
+    : aura::WindowTreeHost(),
+      state_(Uninitialized),
+      bounds_(0, 0, 0, 0),
+      previous_bounds_(0, 0, 0, 0),
+      previous_maximize_bounds_(0, 0, 0, 0),
+      window_(0),
+      title_(base::string16()),
+      close_widget_factory_(this),
+      drag_drop_client_(NULL),
+      native_widget_delegate_(native_widget_delegate),
+      content_window_(NULL),
+      desktop_native_widget_aura_(desktop_native_widget_aura),
+      window_parent_(NULL),
+      window_children_() {
+}
+
+DesktopWindowTreeHostWayland::~DesktopWindowTreeHostWayland() {
+  window()->ClearProperty(kHostForRootWindow);
+  aura::client::SetWindowMoveClient(window(), NULL);
+  desktop_native_widget_aura_->OnDesktopWindowTreeHostDestroyed(this);
+  DestroyDispatcher();
+}
+
+// static
+DesktopWindowTreeHostWayland*
+DesktopWindowTreeHostWayland::GetHostForAcceleratedWidget(
+    gfx::AcceleratedWidget widget) {
+  aura::WindowTreeHost* host =
+      aura::WindowTreeHost::GetForAcceleratedWidget(widget);
+
+  return host ? host->window()->GetProperty(kHostForRootWindow) : NULL;
+}
+
+// static
+const std::vector<aura::Window*>&
+DesktopWindowTreeHostWayland::GetAllOpenWindows() {
+  DCHECK(g_delegate_ozone_wayland_);
+  return g_delegate_ozone_wayland_->GetAllOpenWindows();
+}
+
+// static
+aura::Window*
+DesktopWindowTreeHostWayland::GetContentWindowForAcceleratedWidget(
+    gfx::AcceleratedWidget widget) {
+  aura::WindowTreeHost* host =
+      aura::WindowTreeHost::GetForAcceleratedWidget(widget);
+
+  return host ?
+      host->window()->GetProperty(kViewsWindowForRootWindow) : NULL;
+}
+
+gfx::Rect DesktopWindowTreeHostWayland::GetBoundsInScreen() const {
+  return bounds_;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostWayland, private:
+
+void DesktopWindowTreeHostWayland::InitWaylandWindow(
+    const Widget::InitParams& params) {
+  //ui::SurfaceFactoryOzone* surface_factory = ui::SurfaceFactoryOzone::GetInstance();
+  //window_ = surface_factory->GetAcceleratedWidget();
+  
+  // Maintain parent child relation as done in X11 version.
+  // If we have a parent, record the parent/child relationship. We use this
+  // data during destruction to make sure that when we try to close a parent
+  // window, we also destroy all child windows.
+  if (params.parent && params.parent->GetHost()) {
+    gfx::AcceleratedWidget windowId = params.parent->GetHost()->
+        GetAcceleratedWidget();
+    window_parent_ = GetHostForAcceleratedWidget(windowId);
+    DCHECK(window_parent_);
+    window_parent_->window_children_.insert(this);
+  }
+
+  bounds_ = params.bounds;
+  ui::WindowStateChangeHandler* state_handler =
+      ui::WindowStateChangeHandler::GetInstance();
+  switch (params.type) {
+    case Widget::InitParams::TYPE_TOOLTIP:
+    case Widget::InitParams::TYPE_POPUP:
+    case Widget::InitParams::TYPE_MENU: {
+      // Wayland surfaces don't know their position on the screen and transient
+      // surfaces always require a parent surface for relative placement. Here
+      // there's a catch because content_shell menus don't have parent and
+      // therefore we use root window to calculate their position.
+      DesktopWindowTreeHostWayland* parent = window_parent_;
+      if (!parent)
+        parent = GetHostForAcceleratedWidget(
+                     g_delegate_ozone_wayland_->GetActiveWindow()->window_);
+
+      // Transient type expects a position relative to the parent
+      gfx::Point transientPos(bounds_.x() - parent->bounds_.x(),
+                              bounds_.y() - parent->bounds_.y());
+
+      // Different platforms implement different input grab pointer behaviors
+      // on Chromium. While the Linux GTK+ grab button clicks but not the
+      // pointer movement, the MS Windows implementation don't implement any
+      // pointer grab. In here we're using another different behavior for
+      // Chromium, but which is the common sense on most Wayland UI
+      // environments, where the input pointer is grabbed as a whole when a
+      // menu type of window is opened. I.e. both pointer clicks and movements
+      // will be routed only to the newly created window (grab installed). For
+      // more information please refer to the Wayland protocol.
+      state_handler->SetWidgetAttributes(window_,
+                                         parent->window_,
+                                         transientPos.x(),
+                                         transientPos.y(),
+                                         ui::POPUP);
+      break;
+    }
+    case Widget::InitParams::TYPE_BUBBLE:
+    case Widget::InitParams::TYPE_WINDOW:
+      state_handler->SetWidgetAttributes(window_,
+                                         0,
+                                         0,
+                                         0,
+                                         ui::WINDOW);
+      break;
+    case Widget::InitParams::TYPE_WINDOW_FRAMELESS:
+      NOTIMPLEMENTED();
+      break;
+    default:
+      break;
+  }
+
+  CreateCompositor(GetAcceleratedWidget());
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostWayland, DesktopWindowTreeHost implementation:
+
+void DesktopWindowTreeHostWayland::Init(
+    aura::Window* content_window,
+    const Widget::InitParams& params) {
+  content_window_ = content_window;
+  // In some situations, views tries to make a zero sized window, and that
+  // makes us crash. Make sure we have valid sizes.
+  Widget::InitParams sanitized_params = params;
+  if (sanitized_params.bounds.width() == 0)
+    sanitized_params.bounds.set_width(100);
+  if (sanitized_params.bounds.height() == 0)
+    sanitized_params.bounds.set_height(100);
+
+  InitWaylandWindow(sanitized_params);
+}
+
+void DesktopWindowTreeHostWayland::OnNativeWidgetCreated(
+    const Widget::InitParams& params) {
+  window()->SetProperty(kViewsWindowForRootWindow, content_window_);
+  window()->SetProperty(kHostForRootWindow, this);
+
+  // If we're given a parent, we need to mark ourselves as transient to another
+  // window. Otherwise activation gets screwy.
+  gfx::NativeView parent = params.parent;
+  if (!params.child && params.parent)
+    wm::AddTransientChild(parent, content_window_);
+
+  native_widget_delegate_->OnNativeWidgetCreated(true);
+
+  if (!g_delegate_ozone_wayland_)
+    g_delegate_ozone_wayland_ = new WindowTreeHostDelegateWayland();
+
+  g_delegate_ozone_wayland_->OnRootWindowCreated(window_);
+
+  // Add DesktopWindowTreeHostWayland as dispatcher.
+  bool root_window = params.type == Widget::InitParams::TYPE_BUBBLE ||
+      params.type == Widget::InitParams::TYPE_WINDOW ||
+      params.type == Widget::InitParams::TYPE_WINDOW_FRAMELESS;
+  if (!window_parent_ && root_window)
+    g_delegate_ozone_wayland_->SetActiveWindow(this);
+}
+
+scoped_ptr<corewm::Tooltip>
+DesktopWindowTreeHostWayland::CreateTooltip() {
+  return scoped_ptr<corewm::Tooltip>(
+             new corewm::TooltipAura(gfx::SCREEN_TYPE_NATIVE));
+}
+
+scoped_ptr<aura::client::DragDropClient>
+DesktopWindowTreeHostWayland::CreateDragDropClient(
+    DesktopNativeCursorManager* cursor_manager) {
+  drag_drop_client_ = new DesktopDragDropClientWayland(window());
+  return scoped_ptr<aura::client::DragDropClient>(drag_drop_client_).Pass();
+}
+
+void DesktopWindowTreeHostWayland::Close() {
+  if (!close_widget_factory_.HasWeakPtrs()) {
+    // And we delay the close so that if we are called from an ATL callback,
+    // we don't destroy the window before the callback returned (as the caller
+    // may delete ourselves on destroy and the ATL callback would still
+    // dereference us when the callback returns).
+    base::MessageLoop::current()->PostTask(
+        FROM_HERE,
+        base::Bind(&DesktopWindowTreeHostWayland::CloseNow,
+                   close_widget_factory_.GetWeakPtr()));
+  }
+}
+
+void DesktopWindowTreeHostWayland::CloseNow() {
+  DCHECK(g_delegate_ozone_wayland_);
+  unsigned widgetId = window_;
+  native_widget_delegate_->OnNativeWidgetDestroying();
+
+  // If we have children, close them. Use a copy for iteration because they'll
+  // remove themselves.
+  std::set<DesktopWindowTreeHostWayland*> window_children_copy =
+      window_children_;
+  for (std::set<DesktopWindowTreeHostWayland*>::iterator it =
+           window_children_copy.begin(); it != window_children_copy.end();
+       ++it) {
+    (*it)->CloseNow();
+  }
+  DCHECK(window_children_.empty());
+
+  // If we have a parent, remove ourselves from its children list.
+  if (window_parent_)
+    window_parent_->window_children_.erase(this);
+
+  g_delegate_ozone_wayland_->OnRootWindowClosed(widgetId);
+  // Destroy the compositor before destroying the window since shutdown
+  // may try to swap, and the swap without a window causes an error, which
+  // causes a crash with in-process renderer.
+  DestroyCompositor();
+  window_parent_ = NULL;
+  if (!g_delegate_ozone_wayland_->GetActiveWindow()) {
+    // We have no open windows, free g_delegate_ozone_wayland_.
+    delete g_delegate_ozone_wayland_;
+    g_delegate_ozone_wayland_ = NULL;
+  }
+
+  desktop_native_widget_aura_->OnHostClosed();
+}
+
+//views::NonClientFrameView* DesktopWindowTreeHostWayland::CreateNonClientFrameView() { return NULL; }
+
+aura::WindowTreeHost* DesktopWindowTreeHostWayland::AsWindowTreeHost() {
+  return this;
+}
+
+void DesktopWindowTreeHostWayland::ShowWindowWithState(
+    ui::WindowShowState show_state) {
+  if (show_state != ui::SHOW_STATE_DEFAULT &&
+      show_state != ui::SHOW_STATE_NORMAL) {
+    // Only forwarding to Show().
+    NOTIMPLEMENTED();
+  }
+
+  Show();
+  if (show_state == ui::SHOW_STATE_MAXIMIZED)
+    Maximize();
+
+  // Set initial focus for root window.
+  if (!window_parent_)
+    native_widget_delegate_->AsWidget()->SetInitialFocus(show_state);
+}
+
+void DesktopWindowTreeHostWayland::ShowMaximizedWithBounds(
+    const gfx::Rect& restored_bounds) {
+  Maximize();
+  previous_bounds_ = restored_bounds;
+  Show();
+}
+
+bool DesktopWindowTreeHostWayland::IsVisible() const {
+  return state_ & Visible;
+}
+
+void DesktopWindowTreeHostWayland::SetSize(const gfx::Size& size) {
+  gfx::Rect new_bounds = bounds_;
+  new_bounds.set_size(size);
+  SetBounds(new_bounds);
+}
+
+void DesktopWindowTreeHostWayland::StackAtTop() {
+}
+
+void DesktopWindowTreeHostWayland::CenterWindow(const gfx::Size& size) {
+  gfx::Rect parent_bounds = GetWorkAreaBoundsInScreen();
+
+  // If |window_|'s transient parent bounds are big enough to contain |size|,
+  // use them instead.
+  if (wm::GetTransientParent(content_window_)) {
+    gfx::Rect transient_parent_rect =
+        wm::GetTransientParent(content_window_)->GetBoundsInScreen();
+    if (transient_parent_rect.height() >= size.height() &&
+        transient_parent_rect.width() >= size.width()) {
+      parent_bounds = transient_parent_rect;
+    }
+  }
+
+  gfx::Rect window_bounds(
+      parent_bounds.x() + (parent_bounds.width() - size.width()) / 2,
+      parent_bounds.y() + (parent_bounds.height() - size.height()) / 2,
+      size.width(),
+      size.height());
+  // Don't size the window bigger than the parent, otherwise the user may not be
+  // able to close or move it.
+  window_bounds.AdjustToFit(parent_bounds);
+  SetBounds(window_bounds);
+}
+
+void DesktopWindowTreeHostWayland::GetWindowPlacement(
+    gfx::Rect* bounds,
+    ui::WindowShowState* show_state) const {
+  *bounds = GetRestoredBounds();
+
+  if (IsFullscreen()) {
+    *show_state = ui::SHOW_STATE_FULLSCREEN;
+  } else if (IsMinimized()) {
+    *show_state = ui::SHOW_STATE_MINIMIZED;
+  } else if (IsMaximized()) {
+    *show_state = ui::SHOW_STATE_MAXIMIZED;
+  } else if (!IsActive()) {
+    *show_state = ui::SHOW_STATE_INACTIVE;
+  } else {
+    *show_state = ui::SHOW_STATE_NORMAL;
+  }
+}
+
+gfx::Rect DesktopWindowTreeHostWayland::GetWindowBoundsInScreen() const {
+  return bounds_;
+}
+
+gfx::Rect DesktopWindowTreeHostWayland::GetClientAreaBoundsInScreen() const {
+  // TODO(erg): The NativeWidgetAura version returns |bounds_|, claiming its
+  // needed for View::ConvertPointToScreen() to work
+  // correctly. DesktopWindowTreeHostWin::GetClientAreaBoundsInScreen() just
+  // asks windows what it thinks the client rect is.
+  //
+  // Attempts to calculate the rect by asking the NonClientFrameView what it
+  // thought its GetBoundsForClientView() were broke combobox drop down
+  // placement.
+  return bounds_;
+}
+
+gfx::Rect DesktopWindowTreeHostWayland::GetRestoredBounds() const {
+  if (!previous_bounds_.IsEmpty())
+    return previous_bounds_;
+
+  return GetWindowBoundsInScreen();
+}
+
+gfx::Rect DesktopWindowTreeHostWayland::GetWorkAreaBoundsInScreen() const {
+  // TODO(kalyan): Take into account wm decorations. i.e Dock, panel etc.
+  gfx::Screen *screen = gfx::Screen::GetScreenByType(gfx::SCREEN_TYPE_NATIVE);
+  if (!screen)
+    NOTREACHED() << "Unable to retrieve valid gfx::Screen";
+
+  gfx::Display display = screen->GetPrimaryDisplay();
+  return display.bounds();
+}
+
+void DesktopWindowTreeHostWayland::SetShape(gfx::NativeRegion native_region) {
+  // TODO(erg):
+  NOTIMPLEMENTED();
+}
+
+void DesktopWindowTreeHostWayland::Activate() {
+  if (state_ & Active)
+    return;
+
+  state_ |= Active;
+  if (state_ & Visible)
+    ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(window_,
+                                                                ui::ACTIVE);
+}
+
+void DesktopWindowTreeHostWayland::Deactivate() {
+  if (!(state_ & Active))
+    return;
+
+  state_ &= ~Active;
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(window_,
+                                                              ui::INACTIVE);
+}
+
+bool DesktopWindowTreeHostWayland::IsActive() const {
+  return state_ & Active;
+}
+
+void DesktopWindowTreeHostWayland::Maximize() {
+  if (state_ & Maximized)
+    return;
+  if (IsMinimized() && !window_parent_)
+    native_widget_delegate_->AsWidget()->SetInitialFocus(ui::SHOW_STATE_NORMAL);
+
+  state_ |= Maximized;
+  state_ &= ~Minimized;
+  state_ &= ~Normal;
+  previous_bounds_ = bounds_;
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(window_,
+                                                              ui::MAXIMIZED);
+}
+
+void DesktopWindowTreeHostWayland::Minimize() {
+  if (state_ & Minimized)
+    return;
+
+  state_ &= ~Maximized;
+  state_ |= Minimized;
+  state_ &= ~Normal;
+  previous_bounds_ = bounds_;
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(window_,
+                                                              ui::MINIMIZED);
+}
+
+void DesktopWindowTreeHostWayland::Restore() {
+  if (state_ & Normal)
+    return;
+
+  if (IsMinimized() && !window_parent_)
+    native_widget_delegate_->AsWidget()->SetInitialFocus(ui::SHOW_STATE_NORMAL);
+  state_ &= ~Maximized;
+  state_ &= ~Minimized;
+  state_ |= Normal;
+  bounds_ = previous_bounds_;
+  previous_bounds_ = gfx::Rect();
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(
+      window_, ui::RESTORE, bounds_.width(), bounds_.height());
+  native_widget_delegate_->AsWidget()->OnNativeWidgetMove();
+  OnHostResized(bounds_.size());
+}
+
+bool DesktopWindowTreeHostWayland::IsMaximized() const {
+  return state_ & Maximized;
+}
+
+bool DesktopWindowTreeHostWayland::IsMinimized() const {
+  return state_ & Minimized;
+}
+
+void DesktopWindowTreeHostWayland::OnCaptureReleased() {
+  OnHostLostWindowCapture();
+  native_widget_delegate_->OnMouseCaptureLost();
+}
+
+bool DesktopWindowTreeHostWayland::HasCapture() const {
+  return g_delegate_ozone_wayland_->GetCurrentCapture() == this;
+}
+
+bool DesktopWindowTreeHostWayland::IsAlwaysOnTop() const {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+void DesktopWindowTreeHostWayland::SetVisibleOnAllWorkspaces(
+    bool always_visible) {
+  NOTIMPLEMENTED();
+}
+
+void DesktopWindowTreeHostWayland::SetAlwaysOnTop(bool always_on_top) {
+  // TODO(erg):
+  NOTIMPLEMENTED();
+}
+
+bool DesktopWindowTreeHostWayland::SetWindowTitle(const base::string16& title) {
+  if (title.compare(title_)) {
+    ui::WindowStateChangeHandler::GetInstance()->SetWidgetTitle(window_, title);
+    title_ = title;
+    return true;
+  }
+
+  return false;
+}
+
+void DesktopWindowTreeHostWayland::ClearNativeFocus() {
+  // This method is weird and misnamed. Instead of clearing the native focus,
+  // it sets the focus to our |content_window_|, which will trigger a cascade
+  // of focus changes into views.
+  if (content_window_ && aura::client::GetFocusClient(content_window_) &&
+      content_window_->Contains(
+          aura::client::GetFocusClient(content_window_)->GetFocusedWindow())) {
+    aura::client::GetFocusClient(content_window_)->FocusWindow(content_window_);
+  }
+}
+
+Widget::MoveLoopResult DesktopWindowTreeHostWayland::RunMoveLoop(
+    const gfx::Vector2d& drag_offset,
+    Widget::MoveLoopSource source,
+    Widget::MoveLoopEscapeBehavior escape_behavior) {
+  NOTIMPLEMENTED();
+  return Widget::MOVE_LOOP_SUCCESSFUL;
+}
+
+void DesktopWindowTreeHostWayland::EndMoveLoop() {
+  NOTIMPLEMENTED();
+}
+
+void DesktopWindowTreeHostWayland::SetVisibilityChangedAnimationsEnabled(
+    bool value) {
+  // Much like the previous NativeWidgetGtk, we don't have anything to do here.
+}
+
+bool DesktopWindowTreeHostWayland::ShouldUseNativeFrame() const {
+  return false;
+}
+
+bool DesktopWindowTreeHostWayland::ShouldWindowContentsBeTransparent() const {
+  return false;
+}
+
+void DesktopWindowTreeHostWayland::FrameTypeChanged() {
+  Widget::FrameType new_type =
+    native_widget_delegate_->AsWidget()->frame_type();
+  if (new_type == Widget::FRAME_TYPE_DEFAULT) {
+    // The default is determined by Widget::InitParams::remove_standard_frame
+    // and does not change.
+    return;
+  }
+
+  // Replace the frame and layout the contents. Even though we don't have a
+  // swapable glass frame like on Windows, we still replace the frame because
+  // the button assets don't update otherwise.
+  native_widget_delegate_->AsWidget()->non_client_view()->UpdateFrame();
+}
+
+void DesktopWindowTreeHostWayland::SetFullscreen(bool fullscreen) {
+  if ((state_ & FullScreen) == fullscreen)
+    return;
+
+  if (fullscreen) {
+    state_ |= FullScreen;
+    state_ &= ~Normal;
+  } else {
+    state_ &= ~FullScreen;
+  }
+
+  if (!(state_ & FullScreen)) {
+    if (state_ & Maximized) {
+      previous_bounds_ = previous_maximize_bounds_;
+      previous_maximize_bounds_ = gfx::Rect();
+      ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(
+          window_, ui::MAXIMIZED);
+    } else {
+      Restore();
+    }
+  } else {
+    if (state_ & Maximized)
+      previous_maximize_bounds_ = previous_bounds_;
+
+    previous_bounds_ = bounds_;
+    gfx::Screen *screen = gfx::Screen::GetScreenByType(gfx::SCREEN_TYPE_NATIVE);
+    if (!screen)
+      NOTREACHED() << "Unable to retrieve valid gfx::Screen";
+
+    bounds_ = screen->GetPrimaryDisplay().bounds();
+    // We could use HandleConfigure in ShellSurface to set the correct bounds of
+    // egl window associated with this opaque handle. How ever, this would need
+    // to handle race conditions and ensure correct size is set for
+    // wl_egl_window_resize before eglsurface is resized. Passing window size
+    // attributes already here, ensures that wl_egl_window_resize is resized
+    // before eglsurface is resized. This doesn't add any extra overhead as the
+    // IPC call needs to be done.
+    ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(
+        window_, ui::FULLSCREEN, bounds_.width(), bounds_.height());
+    OnHostResized(bounds_.size());
+  }
+}
+
+bool DesktopWindowTreeHostWayland::IsFullscreen() const {
+  return state_ & FullScreen;
+}
+
+void DesktopWindowTreeHostWayland::SetOpacity(unsigned char opacity) {
+  // TODO(erg):
+  NOTIMPLEMENTED();
+}
+
+void DesktopWindowTreeHostWayland::SetWindowIcons(
+    const gfx::ImageSkia& window_icon, const gfx::ImageSkia& app_icon) {
+  // TODO(erg):
+  NOTIMPLEMENTED();
+}
+
+void DesktopWindowTreeHostWayland::InitModalType(ui::ModalType modal_type) {
+  switch (modal_type) {
+    case ui::MODAL_TYPE_NONE:
+      break;
+    default:
+      // TODO(erg): Figure out under what situations |modal_type| isn't
+      // none. The comment in desktop_native_widget_aura.cc suggests that this
+      // is rare.
+      NOTIMPLEMENTED();
+  }
+}
+
+void DesktopWindowTreeHostWayland::FlashFrame(bool flash_frame) {
+  // TODO(erg):
+  NOTIMPLEMENTED();
+}
+
+//void DesktopWindowTreeHostWayland::OnRootViewLayout() const { NOTIMPLEMENTED(); }
+
+void DesktopWindowTreeHostWayland::OnNativeWidgetFocus() {
+  native_widget_delegate_->AsWidget()->GetInputMethod()->OnFocus();
+}
+
+void DesktopWindowTreeHostWayland::OnNativeWidgetBlur() {
+  if (window_)
+    native_widget_delegate_->AsWidget()->GetInputMethod()->OnBlur();
+}
+
+bool DesktopWindowTreeHostWayland::IsAnimatingClosed() const {
+  return false;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostWayland, aura::WindowTreeHost implementation:
+
+ui::EventSource* DesktopWindowTreeHostWayland::GetEventSource() {
+  NOTIMPLEMENTED();
+  return NULL;
+}
+
+gfx::AcceleratedWidget DesktopWindowTreeHostWayland::GetAcceleratedWidget() {
+  return window_;
+}
+
+void DesktopWindowTreeHostWayland::Show() {
+  if (state_ & Visible)
+    return;
+
+  // Window is being shown, set the state as active to be able to handle events.
+  Activate();
+
+  state_ |= Visible;
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(window_,
+                                                              ui::SHOW);
+  native_widget_delegate_->OnNativeWidgetVisibilityChanged(true);
+}
+
+void DesktopWindowTreeHostWayland::Hide() {
+  if (!(state_ & Visible))
+    return;
+
+  state_ &= ~Visible;
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(window_,
+                                                              ui::HIDE);
+  native_widget_delegate_->OnNativeWidgetVisibilityChanged(false);
+}
+
+gfx::Rect DesktopWindowTreeHostWayland::GetBounds() const {
+  return bounds_;
+}
+
+void DesktopWindowTreeHostWayland::SetBounds(const gfx::Rect& bounds) {
+  bool origin_changed = bounds_.origin() != bounds.origin();
+  bool size_changed = bounds_.size() != bounds.size();
+
+  bounds_ = bounds;
+
+  if (origin_changed)
+    native_widget_delegate_->AsWidget()->OnNativeWidgetMove();
+  if (size_changed)
+    OnHostResized(bounds.size());
+  else
+    compositor()->ScheduleRedrawRect(bounds);
+}
+
+gfx::Point DesktopWindowTreeHostWayland::GetLocationOnNativeScreen() const {
+  return bounds_.origin();
+}
+
+void DesktopWindowTreeHostWayland::SetCapture() {
+  g_delegate_ozone_wayland_->SetCapture(this);
+}
+
+void DesktopWindowTreeHostWayland::ReleaseCapture() {
+  g_delegate_ozone_wayland_->SetCapture(NULL);
+}
+
+void DesktopWindowTreeHostWayland::SetCursorNative(gfx::NativeCursor cursor) {
+  // TODO(kalyan): Add support for custom cursor.
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetCursor(
+      cursor.native_type());
+}
+
+void DesktopWindowTreeHostWayland::OnCursorVisibilityChangedNative(bool show) {
+  // TODO(erg): Conditional on us enabling touch on desktop linux builds, do
+  // the same tap-to-click disabling here that chromeos does.
+}
+
+void DesktopWindowTreeHostWayland::MoveCursorToNative(
+    const gfx::Point& location) {
+  NOTIMPLEMENTED();
+}
+
+void DesktopWindowTreeHostWayland::PostNativeEvent(
+    const base::NativeEvent& native_event) {
+  NOTIMPLEMENTED();
+}
+
+//void DesktopWindowTreeHostWayland::OnDeviceScaleFactorChanged( float device_scale_factor) { }
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostWayland, Private implementation:
+
+void DesktopWindowTreeHostWayland::HandleNativeWidgetActivationChanged(
+    bool active) {
+  // We can skip during initialization phase.
+  if (!state_)
+    return;
+
+  if (active)
+    OnHostActivated();
+
+  desktop_native_widget_aura_->HandleActivationChanged(active);
+  native_widget_delegate_->AsWidget()->GetRootView()->SchedulePaint();
+}
+
+void DesktopWindowTreeHostWayland::HandleWindowResize(unsigned width,
+                                                      unsigned height) {
+  unsigned current_width = bounds_.width();
+  unsigned current_height = bounds_.height();
+  if ((current_width == width) && (current_height == height)) {
+    compositor()->ScheduleRedrawRect(bounds_);
+  } else {
+    bounds_ = gfx::Rect(bounds_.x(), bounds_.y(), width, height);
+    OnHostResized(bounds_.size());
+    Widget* widget = native_widget_delegate_->AsWidget();
+    NonClientView* non_client_view = widget->non_client_view();
+    // non_client_view may be NULL, especially during creation.
+    if (non_client_view) {
+      non_client_view->client_view()->InvalidateLayout();
+      non_client_view->InvalidateLayout();
+    }
+    widget->GetRootView()->Layout();
+  }
+}
+
+void DesktopWindowTreeHostWayland::HandleCommit(const std::string& text) {
+  ui::InputMethodAuraLinux* inputMethod =
+      static_cast<ui::InputMethodAuraLinux*>(desktop_native_widget_aura_->
+      input_method_event_filter()->input_method());
+  inputMethod->OnCommit(base::string16(base::ASCIIToUTF16(text.c_str())));
+}
+
+void DesktopWindowTreeHostWayland::HandlePreeditChanged(const std::string& text,
+  const std::string& commit) {
+  ui::CompositionText composition_text;
+  composition_text.text = base::string16(base::ASCIIToUTF16(text.c_str()));
+  ui::InputMethodAuraLinux* inputMethod =
+      static_cast<ui::InputMethodAuraLinux*>(desktop_native_widget_aura_->
+      input_method_event_filter()->input_method());
+  inputMethod->OnPreeditChanged(composition_text);
+}
+
+// static
+VIEWS_EXPORT ui::NativeTheme*
+DesktopWindowTreeHost::GetNativeTheme(aura::Window* window) {
+  const views::LinuxUI* linux_ui = views::LinuxUI::instance();
+  if (linux_ui) {
+    ui::NativeTheme* native_theme = linux_ui->GetNativeTheme(window);
+    if (native_theme)
+      return native_theme;
+  }
+
+  return ui::NativeTheme::instance();
+}
+
+bool DesktopWindowTreeHostWayland::IsTranslucentWindowOpacitySupported() const { return true; }
+
+void DesktopWindowTreeHostWayland::SizeConstraintsChanged() {}
+void DesktopWindowTreeHostWayland::OnRootViewLayout() {}
+
+}  // namespace views
--- /dev/null
+++ b/ozone/ui/desktop_aura/desktop_window_tree_host_wayland.h
@@ -0,0 +1,193 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_IMPL_DESKTOP_AURA_DESKTOP_WINDOW_TREE_HOST_WAYLAND_H_
+#define OZONE_IMPL_DESKTOP_AURA_DESKTOP_WINDOW_TREE_HOST_WAYLAND_H_
+
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/basictypes.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host.h"
+
+namespace views {
+
+namespace corewm {
+class Tooltip;
+}
+
+class DesktopDragDropClientWayland;
+class WindowTreeHostDelegateWayland;
+
+class VIEWS_EXPORT DesktopWindowTreeHostWayland
+    : public DesktopWindowTreeHost,
+      public aura::WindowTreeHost {
+ public:
+  DesktopWindowTreeHostWayland(
+      internal::NativeWidgetDelegate* native_widget_delegate,
+      DesktopNativeWidgetAura* desktop_native_widget_aura);
+  virtual ~DesktopWindowTreeHostWayland();
+
+  // Accepts a opaque handle widget and returns associated
+  // DesktopWindowTreeHostWayland.
+  static DesktopWindowTreeHostWayland* GetHostForAcceleratedWidget(
+      gfx::AcceleratedWidget widget);
+
+  // Get all open top-level windows. This includes windows that may not be
+  // visible. This list is sorted in their stacking order, i.e. the first window
+  // is the topmost window.
+  static const std::vector<aura::Window*>& GetAllOpenWindows();
+
+  // Accepts a opaque handle widget and returns associated aura::Window.
+    static aura::Window* GetContentWindowForAcceleratedWidget(
+      gfx::AcceleratedWidget widget);
+
+  // Returns window bounds. This is used by Screen to determine if a point
+  // belongs to a particular window.
+  gfx::Rect GetBoundsInScreen() const;
+
+  virtual void OnRootViewLayout() override;
+  virtual void SizeConstraintsChanged() override;
+
+ private:
+  enum {
+    Uninitialized = 0x00,
+    Visible = 0x01,  // Window is Visible.
+    FullScreen = 0x02,  // Window is in fullscreen mode.
+    Maximized = 0x04,  // Window is maximized,
+    Minimized = 0x08,  // Window is minimized.
+    Normal = 0x10,  // Window is in Normal Mode.
+    Active = 0x20  // Window is Active.
+  };
+
+  typedef unsigned RootWindowState;
+
+  // Initializes our Ozone surface to draw on. This method performs all
+  // initialization related to talking to the Ozone server.
+  void InitWaylandWindow(const views::Widget::InitParams& params);
+
+  // Called when another DRWHL takes capture, or when capture is released
+  // entirely.
+  void OnCaptureReleased();
+
+  // Overridden from DesktopWindowTreeHost:
+  virtual void Init(
+      aura::Window* content_window,
+      const views::Widget::InitParams& params) override;
+  virtual void OnNativeWidgetCreated(
+      const views::Widget::InitParams& params) override;
+  virtual scoped_ptr<views::corewm::Tooltip> CreateTooltip() override;
+  virtual scoped_ptr<aura::client::DragDropClient> CreateDragDropClient(
+      views::DesktopNativeCursorManager* cursor_manager) override;
+  virtual void Close() override;
+  virtual void CloseNow() override;
+  virtual aura::WindowTreeHost* AsWindowTreeHost() override;
+  virtual void ShowWindowWithState(ui::WindowShowState show_state) override;
+  virtual void ShowMaximizedWithBounds(
+      const gfx::Rect& restored_bounds) override;
+  virtual bool IsVisible() const override;
+  virtual void SetSize(const gfx::Size& size) override;
+  virtual void StackAtTop() override;
+  virtual void CenterWindow(const gfx::Size& size) override;
+  virtual void GetWindowPlacement(
+      gfx::Rect* bounds,
+      ui::WindowShowState* show_state) const override;
+  virtual gfx::Rect GetWindowBoundsInScreen() const override;
+  virtual gfx::Rect GetClientAreaBoundsInScreen() const override;
+  virtual gfx::Rect GetRestoredBounds() const override;
+  virtual gfx::Rect GetWorkAreaBoundsInScreen() const override;
+  virtual void SetShape(gfx::NativeRegion native_region) override;
+  virtual void Activate() override;
+  virtual void Deactivate() override;
+  virtual bool IsActive() const override;
+  virtual void Maximize() override;
+  virtual void Minimize() override;
+  virtual void Restore() override;
+  virtual bool IsMaximized() const override;
+  virtual bool IsMinimized() const override;
+  virtual bool HasCapture() const override;
+  virtual bool IsAlwaysOnTop() const override;
+  virtual void SetVisibleOnAllWorkspaces(bool always_visible) override;
+  virtual void SetAlwaysOnTop(bool always_on_top) override;
+  virtual bool SetWindowTitle(const base::string16& title) override;
+  virtual void ClearNativeFocus() override;
+  virtual views::Widget::MoveLoopResult RunMoveLoop(
+      const gfx::Vector2d& drag_offset,
+      views::Widget::MoveLoopSource source,
+      views::Widget::MoveLoopEscapeBehavior escape_behavior) override;
+  virtual void EndMoveLoop() override;
+  //virtual NonClientFrameView* CreateNonClientFrameView() override;
+  virtual void SetVisibilityChangedAnimationsEnabled(bool value) override;
+  virtual bool ShouldUseNativeFrame() const override;
+  virtual bool ShouldWindowContentsBeTransparent() const override;
+  virtual void FrameTypeChanged() override;
+  virtual void SetFullscreen(bool fullscreen) override;
+  virtual bool IsFullscreen() const override;
+  virtual void SetOpacity(unsigned char opacity) override;
+  virtual void SetWindowIcons(const gfx::ImageSkia& window_icon,
+                              const gfx::ImageSkia& app_icon) override;
+  virtual void InitModalType(ui::ModalType modal_type) override;
+  virtual void FlashFrame(bool flash_frame) override;
+  //virtual void OnRootViewLayout() const override;
+  virtual void OnNativeWidgetFocus() override;
+  virtual void OnNativeWidgetBlur() override;
+  virtual bool IsAnimatingClosed() const override;
+
+  // Overridden from aura::WindowTreeHost:
+  virtual ui::EventSource* GetEventSource() override;
+  virtual gfx::AcceleratedWidget GetAcceleratedWidget() override;
+  virtual void Show() override;
+  virtual void Hide() override;
+  virtual gfx::Rect GetBounds() const override;
+  virtual void SetBounds(const gfx::Rect& bounds) override;
+  virtual gfx::Point GetLocationOnNativeScreen() const override;
+  virtual void SetCapture() override;
+  virtual void ReleaseCapture() override;
+  virtual void SetCursorNative(gfx::NativeCursor cursor) override;
+  virtual void OnCursorVisibilityChangedNative(bool show) override;
+  virtual void MoveCursorToNative(const gfx::Point& location) override;
+  virtual void PostNativeEvent(const base::NativeEvent& native_event) override;
+  //virtual void OnDeviceScaleFactorChanged(float device_scale_factor) override;
+  virtual bool IsTranslucentWindowOpacitySupported() const override;
+
+  void HandleNativeWidgetActivationChanged(bool active);
+  void HandleWindowResize(unsigned width, unsigned height);
+
+  void HandlePreeditChanged(const std::string& text, const std::string& commit);
+  void HandleCommit(const std::string& text);
+
+  RootWindowState state_;
+
+  // Current bounds of DRWH.
+  gfx::Rect bounds_;
+  // Original bounds of DRWH.
+  gfx::Rect previous_bounds_;
+  gfx::Rect previous_maximize_bounds_;
+  gfx::AcceleratedWidget window_;
+  base::string16 title_;
+
+  base::WeakPtrFactory<DesktopWindowTreeHostWayland> close_widget_factory_;
+
+  // Owned by DesktopNativeWidgetAura.
+  DesktopDragDropClientWayland* drag_drop_client_;
+  views::internal::NativeWidgetDelegate* native_widget_delegate_;
+  aura::Window* content_window_;
+
+  views::DesktopNativeWidgetAura* desktop_native_widget_aura_;
+  // We can optionally have a parent which can order us to close, or own
+  // children who we're responsible for closing when we CloseNow().
+  DesktopWindowTreeHostWayland* window_parent_;
+  std::set<DesktopWindowTreeHostWayland*> window_children_;
+
+  static WindowTreeHostDelegateWayland* g_delegate_ozone_wayland_;
+  friend class WindowTreeHostDelegateWayland;
+  DISALLOW_COPY_AND_ASSIGN(DesktopWindowTreeHostWayland);
+};
+
+}  // namespace views
+
+#endif  // OZONE_IMPL_DESKTOP_AURA_DESKTOP_WINDOW_TREE_HOST_WAYLAND_H_
--- /dev/null
+++ b/ozone/ui/desktop_aura/impl_view.gypi
@@ -0,0 +1,19 @@
+# Copyright 2014 Intel Corporation. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+{
+  'sources': [
+    'desktop_drag_drop_client_wayland.cc',
+    'desktop_drag_drop_client_wayland.h',
+    'desktop_factory_wayland.cc',
+    'desktop_factory_wayland.h',
+    'desktop_screen_wayland.cc',
+    'desktop_screen_wayland.h',
+    'desktop_window_tree_host_wayland.cc',
+    'desktop_window_tree_host_wayland.h',
+    'ozone_util.cc',
+    'ozone_util.h',
+    'window_tree_host_delegate_wayland.cc',
+    'window_tree_host_delegate_wayland.h',
+  ],
+}
--- /dev/null
+++ b/ozone/ui/desktop_aura/ozone_util.cc
@@ -0,0 +1,42 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/desktop_aura/ozone_util.h"
+
+#include <set>
+#include <vector>
+
+#include "chrome/browser/ui/views/tabs/window_finder.h"
+#include "ozone/ui/desktop_aura/desktop_window_tree_host_wayland.h"
+
+namespace ui {
+
+VIEWS_EXPORT bool GetCustomFramePrefDefault() {
+  return true;
+}
+
+}  // namespace ui
+
+VIEWS_EXPORT bool IsFullScreenMode() {
+  std::vector<aura::Window*> all_windows =
+      views::DesktopWindowTreeHostWayland::GetAllOpenWindows();
+  // Only the topmost window is checked. This works fine in the most cases, but
+  // it may return false when there are multiple displays and one display has
+  // a fullscreen window but others don't. See: crbug.com/345484
+  if (all_windows.empty())
+    return false;
+
+  views::Widget* widget =
+      views::Widget::GetWidgetForNativeWindow(all_windows[0]);
+  return widget && widget->IsFullscreen();
+}
+
+// TODO(Kalyan): Remove this once https://codereview.chromium.org/176893002/
+// is fixed.
+VIEWS_EXPORT aura::Window* GetLocalProcessWindowAtPoint(
+    chrome::HostDesktopType host_desktop_type,
+    const gfx::Point& screen_point,
+    const std::set<aura::Window*>& ignore) {
+  return NULL;
+}
--- /dev/null
+++ b/ozone/ui/desktop_aura/ozone_util.h
@@ -0,0 +1,20 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_IMPL_DESKTOP_AURA_OZONE_UTIL_H_
+#define OZONE_IMPL_DESKTOP_AURA_OZONE_UTIL_H_
+
+#include "base/basictypes.h"
+
+#include "ui/views/views_export.h"
+
+namespace ui {
+
+// Determine whether we should default to native decorations or the custom
+// frame based on the currently-running window manager.
+VIEWS_EXPORT bool GetCustomFramePrefDefault();
+
+}  // namespace ui
+
+#endif  // OZONE_IMPL_DESKTOP_AURA_OZONE_UTIL_H_
--- /dev/null
+++ b/ozone/ui/desktop_aura/window_tree_host_delegate_wayland.cc
@@ -0,0 +1,312 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/desktop_aura/window_tree_host_delegate_wayland.h"
+
+#include <string>
+
+#include "ozone/ui/desktop_aura/desktop_window_tree_host_wayland.h"
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ui/events/event_utils.h"
+#include "ui/events/platform/platform_event_source.h"
+#include "ui/views/window/non_client_view.h"
+
+namespace views {
+
+WindowTreeHostDelegateWayland::WindowTreeHostDelegateWayland()
+    : current_focus_window_(0),
+      handle_event_(true),
+      stop_propogation_(false),
+      current_dispatcher_(NULL),
+      current_capture_(NULL),
+      current_active_window_(NULL),
+      open_windows_(NULL),
+      aura_windows_(NULL) {
+  if (ui::PlatformEventSource::GetInstance())
+    ui::PlatformEventSource::GetInstance()->AddPlatformEventDispatcher(this);
+  ui::EventFactoryOzoneWayland::GetInstance()->SetWindowChangeObserver(this);
+}
+
+WindowTreeHostDelegateWayland::~WindowTreeHostDelegateWayland() {
+}
+
+void WindowTreeHostDelegateWayland::OnRootWindowCreated(unsigned handle) {
+  open_windows().push_back(handle);
+
+  if (aura_windows_) {
+    aura_windows_->clear();
+    delete aura_windows_;
+    aura_windows_ = NULL;
+  }
+}
+
+//NonClientFrameView* WindowTreeHostDelegateWayland::CreateNonClientFrameView() { return NULL; }
+
+void WindowTreeHostDelegateWayland::OnRootWindowClosed(unsigned handle) {
+  open_windows().remove(handle);
+  if (open_windows().empty()) {
+    delete open_windows_;
+    open_windows_ = NULL;
+    SetActiveWindow(NULL);
+
+    ui::PlatformEventSource* event_source =
+        ui::PlatformEventSource::GetInstance();
+    if (event_source)
+      event_source->RemovePlatformEventDispatcher(this);
+    ui::EventFactoryOzoneWayland::GetInstance()->SetWindowChangeObserver(NULL);
+  }
+
+  if (aura_windows_) {
+    aura_windows_->clear();
+    delete aura_windows_;
+    aura_windows_ = NULL;
+  }
+
+  if (!current_active_window_ ||
+      GetWindowHandle(current_active_window_->window_) != handle ||
+      !open_windows_) {
+     return;
+  }
+
+  DCHECK(!current_active_window_->window_parent_);
+  // Set first top level window in the list of open windows as dispatcher.
+  // This is just a guess of the window which would eventually be focussed.
+  // We should set the correct root window as dispatcher in OnWindowFocused.
+  const std::list<unsigned>& windows = open_windows();
+  DesktopWindowTreeHostWayland* rootWindow =
+      DesktopWindowTreeHostWayland::GetHostForAcceleratedWidget(
+          windows.front());
+  SetActiveWindow(rootWindow);
+  rootWindow->HandleNativeWidgetActivationChanged(true);
+}
+
+void WindowTreeHostDelegateWayland::SetActiveWindow(
+    DesktopWindowTreeHostWayland* dispatcher) {
+  current_active_window_ = dispatcher;
+  current_dispatcher_ = current_active_window_;
+  if (!current_active_window_)
+    return;
+
+  // Make sure the stacking order is correct. The activated window should be
+  // first one in list of open windows.
+  std::list<unsigned>& windows = open_windows();
+  DCHECK(windows.size());
+  unsigned window_handle = current_active_window_->window_;
+  if (windows.front() != window_handle) {
+    windows.remove(window_handle);
+    windows.insert(windows.begin(), window_handle);
+  }
+
+  current_active_window_->Activate();
+}
+
+DesktopWindowTreeHostWayland*
+WindowTreeHostDelegateWayland::GetActiveWindow() const {
+  return current_active_window_;
+}
+
+void WindowTreeHostDelegateWayland::SetCapture(
+    DesktopWindowTreeHostWayland* dispatcher) {
+  if (current_capture_)
+    current_capture_->OnCaptureReleased();
+
+  current_capture_ = dispatcher;
+  stop_propogation_ = current_capture_ ? true : false;
+  current_dispatcher_ = current_capture_;
+  if (!current_dispatcher_)
+    current_dispatcher_ = current_active_window_;
+}
+
+DesktopWindowTreeHostWayland*
+WindowTreeHostDelegateWayland::GetCurrentCapture() const {
+  return current_capture_;
+}
+
+const std::vector<aura::Window*>&
+WindowTreeHostDelegateWayland::GetAllOpenWindows() {
+  if (!aura_windows_) {
+    const std::list<unsigned>& windows = open_windows();
+    DCHECK(windows.size());
+    aura_windows_ = new std::vector<aura::Window*>(windows.size());
+    std::transform(
+        windows.begin(), windows.end(), aura_windows_->begin(),
+            DesktopWindowTreeHostWayland::GetContentWindowForAcceleratedWidget);
+  }
+
+  return *aura_windows_;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// WindowTreeHostDelegateWayland, Private implementation:
+void WindowTreeHostDelegateWayland::DispatchMouseEvent(
+         ui::MouseEvent* event) {
+  if (handle_event_)
+    SendEventToProcessor(event);
+  else if (event->type() == ui::ET_MOUSE_PRESSED)
+    SetCapture(NULL);
+
+  // Stop event propogation as this window is acting as event grabber. All
+  // event's we create are "cancelable". If in future we use events that are not
+  // cancelable, then a check for cancelable events needs to be added here.
+  if (stop_propogation_)
+    event->StopPropagation();
+}
+
+std::list<unsigned>&
+WindowTreeHostDelegateWayland::open_windows() {
+  if (!open_windows_)
+    open_windows_ = new std::list<unsigned>();
+
+  return *open_windows_;
+}
+
+unsigned
+WindowTreeHostDelegateWayland::GetWindowHandle(gfx::AcceleratedWidget widget) {
+  return static_cast<unsigned>(widget);
+}
+
+ui::EventProcessor* WindowTreeHostDelegateWayland::GetEventProcessor() {
+  return current_dispatcher_->dispatcher();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// WindowTreeHostDelegateWayland, ui::PlatformEventDispatcher implementation:
+bool WindowTreeHostDelegateWayland::CanDispatchEvent(
+    const ui::PlatformEvent& ne) {
+  DCHECK(ne);
+  return true;
+}
+
+uint32_t WindowTreeHostDelegateWayland::DispatchEvent(
+    const ui::PlatformEvent& ne) {
+  ui::EventType type = ui::EventTypeFromNative(ne);
+  DCHECK(current_dispatcher_);
+
+  switch (type) {
+    case ui::ET_TOUCH_MOVED:
+    case ui::ET_TOUCH_PRESSED:
+    case ui::ET_TOUCH_CANCELLED:
+    case ui::ET_TOUCH_RELEASED: {
+      ui::TouchEvent* touchev = static_cast<ui::TouchEvent*>(ne);
+      SendEventToProcessor(touchev);
+      break;
+    }
+    case ui::ET_KEY_PRESSED: {
+      ui::KeyEvent* keydown_event = static_cast<ui::KeyEvent*>(ne);
+      SendEventToProcessor(keydown_event);
+      break;
+    }
+    case ui::ET_KEY_RELEASED: {
+      ui::KeyEvent* keyup_event = static_cast<ui::KeyEvent*>(ne);
+      SendEventToProcessor(keyup_event);
+      break;
+    }
+    case ui::ET_MOUSEWHEEL: {
+      ui::MouseWheelEvent* wheelev = static_cast<ui::MouseWheelEvent*>(ne);
+      DispatchMouseEvent(wheelev);
+      break;
+    }
+    case ui::ET_MOUSE_MOVED:
+    case ui::ET_MOUSE_DRAGGED:
+    case ui::ET_MOUSE_PRESSED:
+    case ui::ET_MOUSE_RELEASED:
+    case ui::ET_MOUSE_ENTERED:
+    case ui::ET_MOUSE_EXITED: {
+      ui::MouseEvent* mouseev = static_cast<ui::MouseEvent*>(ne);
+      DispatchMouseEvent(mouseev);
+      break;
+    }
+    case ui::ET_SCROLL_FLING_START:
+    case ui::ET_SCROLL_FLING_CANCEL:
+    case ui::ET_SCROLL: {
+      ui::ScrollEvent* scrollev = static_cast<ui::ScrollEvent*>(ne);
+      SendEventToProcessor(scrollev);
+      break;
+    }
+    case ui::ET_UMA_DATA:
+      break;
+    case ui::ET_UNKNOWN:
+      break;
+    default:
+      NOTIMPLEMENTED() << "WindowTreeHostDelegateWayland: unknown event type.";
+  }
+  return ui::POST_DISPATCH_STOP_PROPAGATION;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostWayland, WindowChangeObserver implementation:
+void WindowTreeHostDelegateWayland::OnWindowFocused(unsigned handle) {
+  current_focus_window_ = handle;
+  // Don't dispatch events in case a window has installed itself as capture
+  // window but doesn't have the focus.
+  handle_event_ = current_capture_ ? current_focus_window_ ==
+          GetWindowHandle(current_capture_->GetAcceleratedWidget()) : true;
+  if (GetWindowHandle(current_active_window_->window_) == handle)
+    return;
+
+  // A new window should not steal focus in case the current window has a open
+  // popup.
+  if (current_capture_ && current_capture_ != current_active_window_)
+    return;
+
+  DesktopWindowTreeHostWayland* window = NULL;
+  if (handle)
+    window = DesktopWindowTreeHostWayland::GetHostForAcceleratedWidget(handle);
+
+  if (!window || window->window_parent_)
+    return;
+
+  current_active_window_->HandleNativeWidgetActivationChanged(false);
+
+  SetActiveWindow(window);
+  window->HandleNativeWidgetActivationChanged(true);
+}
+
+void WindowTreeHostDelegateWayland::OnWindowEnter(unsigned handle) {
+  OnWindowFocused(handle);
+}
+
+void WindowTreeHostDelegateWayland::OnWindowLeave(unsigned handle) {
+}
+
+void WindowTreeHostDelegateWayland::OnWindowClose(unsigned handle) {
+  // we specially treat grabbed windows in this function, thus the need for
+  // current_capture_ always be a valid pointer.
+  if (!handle || !current_capture_)
+    return;
+  if (GetWindowHandle(current_capture_->window_) != handle)
+    return;
+  DesktopWindowTreeHostWayland* window = NULL;
+  window = DesktopWindowTreeHostWayland::GetHostForAcceleratedWidget(handle);
+  window->OnCaptureReleased();
+  window->Close();
+}
+
+void WindowTreeHostDelegateWayland::OnWindowResized(unsigned handle,
+                                                    unsigned width,
+                                                    unsigned height) {
+  DesktopWindowTreeHostWayland* window =
+      DesktopWindowTreeHostWayland::GetHostForAcceleratedWidget(handle);
+  DCHECK(window);
+  window->HandleWindowResize(width, height);
+}
+
+void WindowTreeHostDelegateWayland::OnCommit(unsigned handle,
+                                             const std::string& text) {
+  DesktopWindowTreeHostWayland* window =
+      DesktopWindowTreeHostWayland::GetHostForAcceleratedWidget(handle);
+  DCHECK(window);
+  window->HandleCommit(text);
+}
+
+void WindowTreeHostDelegateWayland::OnPreeditChanged(unsigned handle,
+                                                   const std::string& text,
+                                                   const std::string& commit) {
+  DesktopWindowTreeHostWayland* window =
+      DesktopWindowTreeHostWayland::GetHostForAcceleratedWidget(handle);
+  DCHECK(window);
+  window->HandlePreeditChanged(text, commit);
+}
+
+}  // namespace views
--- /dev/null
+++ b/ozone/ui/desktop_aura/window_tree_host_delegate_wayland.h
@@ -0,0 +1,93 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_IMPL_DESKTOP_AURA_WINDOW_TREE_HOST_DELEGATE_WAYLAND_H_
+#define OZONE_IMPL_DESKTOP_AURA_WINDOW_TREE_HOST_DELEGATE_WAYLAND_H_
+
+#include <list>
+#include <string>
+#include <vector>
+
+#include "base/basictypes.h"
+#include "base/message_loop/message_loop.h"
+#include "ozone/ui/events/window_change_observer.h"
+#include "ui/events/event.h"
+#include "ui/events/event_source.h"
+#include "ui/events/platform/platform_event_dispatcher.h"
+#include "ui/gfx/native_widget_types.h"
+#include "ui/views/window/non_client_view.h"
+
+namespace views {
+
+class DesktopWindowTreeHostWayland;
+
+// A static class used by DesktopWindowTreeHostWayland to dispatch native events
+// and basic window management.
+class WindowTreeHostDelegateWayland
+    : public ui::PlatformEventDispatcher,
+      public ui::EventSource,
+      public ui::WindowChangeObserver {
+ public:
+  WindowTreeHostDelegateWayland();
+  virtual ~WindowTreeHostDelegateWayland();
+
+  void OnRootWindowCreated(unsigned handle);
+  void OnRootWindowClosed(unsigned handle);
+
+  void SetActiveWindow(DesktopWindowTreeHostWayland* dispatcher);
+  DesktopWindowTreeHostWayland* GetActiveWindow() const;
+
+  void SetCapture(DesktopWindowTreeHostWayland* dispatcher);
+  DesktopWindowTreeHostWayland* GetCurrentCapture() const;
+
+  const std::vector<aura::Window*>& GetAllOpenWindows();
+
+  // Overridden frm ui::EventSource
+  virtual ui::EventProcessor* GetEventProcessor() override;
+ private:
+  // ui::PlatformEventDispatcher:
+  virtual bool CanDispatchEvent(const ui::PlatformEvent& event) override;
+  virtual uint32_t DispatchEvent(const ui::PlatformEvent& event) override;
+
+  // Window Change Observer.
+  virtual void OnWindowFocused(unsigned handle) override;
+  virtual void OnWindowEnter(unsigned handle) override;
+  virtual void OnWindowLeave(unsigned handle) override;
+  virtual void OnWindowClose(unsigned handle) override;
+  virtual void OnWindowResized(unsigned windowhandle,
+                               unsigned width,
+                               unsigned height) override;
+  virtual void OnPreeditChanged(unsigned handle,
+                                const std::string& text,
+                                const std::string& commit) override;
+  virtual void OnCommit(unsigned handle, const std::string& text) override;
+
+  // Dispatches a mouse event.
+  void DispatchMouseEvent(ui::MouseEvent* event);
+  std::list<unsigned>& open_windows();
+  unsigned GetWindowHandle(gfx::AcceleratedWidget widget);
+
+  unsigned current_focus_window_;
+  bool handle_event_ :1;
+  bool stop_propogation_ :1;
+
+  //virtual NonClientFrameView* CreateNonClientFrameView() override;
+
+  // Current dispatcher.
+  DesktopWindowTreeHostWayland* current_dispatcher_;
+  // The current root window host that has capture. We need to track this so we
+  // can notify widgets when they have lost capture, which controls a bunch of
+  // things in views like hiding menus.
+  DesktopWindowTreeHostWayland* current_capture_;
+  DesktopWindowTreeHostWayland* current_active_window_;
+  // List of all open windows.
+  std::list<unsigned>* open_windows_;
+  // List of all open aura::Window.
+  std::vector<aura::Window*>* aura_windows_;
+  DISALLOW_COPY_AND_ASSIGN(WindowTreeHostDelegateWayland);
+};
+
+}  // namespace views
+
+#endif  // OZONE_IMPL_DESKTOP_AURA_WINDOW_TREE_HOST_DELEGATE_WAYLAND_H_
--- /dev/null
+++ b/ozone/ui/events/DEPS
@@ -0,0 +1,3 @@
+include_rules = [
+  "+ui/events",
+]
--- /dev/null
+++ b/ozone/ui/events/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/ui/events/event.gypi
@@ -0,0 +1,24 @@
+# Copyright 2014 Intel Corporation. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+{
+  'dependencies': [
+    '<(DEPTH)/ui/events/events.gyp:events',
+  ],
+  'sources': [
+    'event_converter_ozone_wayland.h',
+    'event_converter_ozone_wayland.cc',
+    'event_factory_ozone_wayland.h',
+    'event_factory_ozone_wayland.cc',
+    'ime_state_change_handler.h',
+    'ime_state_change_handler.cc',
+    'keyboard_codes_ozone.h',
+    'keyboard_code_conversion_ozone.h',
+    'keyboard_code_conversion_ozone.cc',
+    'output_change_observer.h',
+    'window_change_observer.h',
+    'window_constants.h',
+    'window_state_change_handler.h',
+    'window_state_change_handler.cc',
+   ],
+}
--- /dev/null
+++ b/ozone/ui/events/event_converter_ozone_wayland.cc
@@ -0,0 +1,32 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/events/event_converter_ozone_wayland.h"
+
+#include "base/bind.h"
+
+namespace ui {
+
+EventConverterOzoneWayland::EventConverterOzoneWayland()
+    : loop_(base::MessageLoop::current()) {
+  DCHECK(loop_);
+}
+
+EventConverterOzoneWayland::~EventConverterOzoneWayland() {
+}
+
+void EventConverterOzoneWayland::SetWindowChangeObserver(
+    WindowChangeObserver* observer) {
+}
+
+void EventConverterOzoneWayland::SetOutputChangeObserver(
+    OutputChangeObserver* observer) {
+}
+
+void EventConverterOzoneWayland::PostTaskOnMainLoop(const base::Closure& task) {
+  DCHECK(loop_);
+  loop_->message_loop_proxy()->PostTask(FROM_HERE, task);
+}
+
+}  // namespace ui
--- /dev/null
+++ b/ozone/ui/events/event_converter_ozone_wayland.h
@@ -0,0 +1,71 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_EVENTS_EVENT_CONVERTER_OZONE_WAYLAND_H_
+#define OZONE_UI_EVENTS_EVENT_CONVERTER_OZONE_WAYLAND_H_
+
+#include <string>
+
+#include "base/message_loop/message_loop.h"
+#include "ozone/platform/ozone_export_wayland.h"
+#include "ui/events/event_constants.h"
+
+namespace ui {
+
+class WindowChangeObserver;
+class OutputChangeObserver;
+
+// In OzoneWayland, Chrome relies on Wayland protocol to recieve callback of
+// any input/surface events. This class is responsible for the following:
+// 1) Convert native input events to |ui::Event| and dispatching to aura.
+// 2) Convert native events related to Window Activation and dispatch it to
+//    WindowChangeObserver
+class OZONE_WAYLAND_EXPORT EventConverterOzoneWayland {
+ public:
+  EventConverterOzoneWayland();
+  virtual ~EventConverterOzoneWayland();
+
+  virtual void MotionNotify(float x, float y) = 0;
+  virtual void ButtonNotify(unsigned handle,
+                            EventType type,
+                            EventFlags flags,
+                            float x,
+                            float y) = 0;
+  virtual void AxisNotify(float x, float y, int xoffset, int yoffset) = 0;
+  virtual void PointerEnter(unsigned handle, float x, float y) = 0;
+  virtual void PointerLeave(unsigned handle, float x, float y) = 0;
+  virtual void KeyNotify(ui::EventType type,
+                         unsigned code,
+                         unsigned modifiers) = 0;
+  virtual void TouchNotify(ui::EventType type,
+                           float x,
+                           float y,
+                           int32_t touch_id,
+                           uint32_t time_stamp) = 0;
+
+  virtual void OutputSizeChanged(unsigned width, unsigned height) = 0;
+  virtual void WindowResized(unsigned windowhandle,
+                             unsigned width,
+                             unsigned height) = 0;
+  virtual void CloseWidget(unsigned handle) = 0;
+  virtual void Commit(unsigned handle, const std::string& text) = 0;
+  virtual void PreeditChanged(unsigned handle, const std::string& text,
+                              const std::string& commit) = 0;
+  virtual void PreeditEnd() = 0;
+  virtual void PreeditStart() = 0;
+
+  // Sets the window change observer. Ownership is retained by the caller.
+  virtual void SetWindowChangeObserver(WindowChangeObserver* observer);
+  // Sets the output change observer. Ownership is retained by the caller.
+  virtual void SetOutputChangeObserver(OutputChangeObserver* observer);
+
+ protected:
+  // Posts task to main loop of the thread on which Dispatcher was initialized.
+  virtual void PostTaskOnMainLoop(const base::Closure& task);
+  base::MessageLoop* loop_;
+};
+
+}  // namespace ui
+
+#endif  // OZONE_UI_EVENTS_EVENT_CONVERTER_OZONE_WAYLAND_H_
--- /dev/null
+++ b/ozone/ui/events/event_factory_ozone_wayland.cc
@@ -0,0 +1,68 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "base/bind.h"
+
+
+namespace ui {
+
+// static
+EventFactoryOzoneWayland* EventFactoryOzoneWayland::impl_ = NULL;
+
+EventFactoryOzoneWayland::EventFactoryOzoneWayland()
+    : event_converter_(NULL),
+      observer_(NULL),
+      output_observer_(NULL) {
+  EventFactoryOzoneWayland::SetInstance(this);
+}
+
+EventFactoryOzoneWayland::~EventFactoryOzoneWayland() {
+}
+
+EventFactoryOzoneWayland* EventFactoryOzoneWayland::GetInstance() {
+  CHECK(impl_) << "No EventFactoryOzoneWayland implementation set.";
+  return impl_;
+}
+
+void EventFactoryOzoneWayland::SetInstance(EventFactoryOzoneWayland* impl) {
+  CHECK(!impl_) << "Replacing set EventFactoryOzoneWayland implementation.";
+  impl_ = impl;
+}
+
+void EventFactoryOzoneWayland::SetWindowChangeObserver(
+    WindowChangeObserver* observer) {
+  observer_ = observer;
+  if (event_converter_)
+    event_converter_->SetWindowChangeObserver(observer_);
+}
+
+WindowChangeObserver*
+EventFactoryOzoneWayland::GetWindowChangeObserver() const {
+  return observer_;
+}
+
+void EventFactoryOzoneWayland::SetOutputChangeObserver(
+    OutputChangeObserver* observer) {
+  output_observer_ = observer;
+  if (event_converter_)
+    event_converter_->SetOutputChangeObserver(output_observer_);
+}
+
+OutputChangeObserver*
+EventFactoryOzoneWayland::GetOutputChangeObserver() const {
+  return output_observer_;
+}
+
+void EventFactoryOzoneWayland::SetEventConverterOzoneWayland(
+    EventConverterOzoneWayland* converter) {
+  event_converter_ = converter;
+}
+
+EventConverterOzoneWayland* EventFactoryOzoneWayland::EventConverter() const {
+  CHECK(impl_) << "EventConverterOzoneWayland is not initialized yet.";
+  return event_converter_;
+}
+
+}  // namespace ui
--- /dev/null
+++ b/ozone/ui/events/event_factory_ozone_wayland.h
@@ -0,0 +1,50 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_EVENTS_EVENT_FACTORY_OZONE_WAYLAND_H_
+#define OZONE_UI_EVENTS_EVENT_FACTORY_OZONE_WAYLAND_H_
+
+#include "ozone/ui/events/event_converter_ozone_wayland.h"
+#include "ozone/platform/ozone_export_wayland.h"
+//#include "ui/ozone/public/event_factory_ozone.h"
+
+namespace ui {
+
+class WindowChangeObserver;
+class OutputChangeObserver;
+
+class OZONE_WAYLAND_EXPORT EventFactoryOzoneWayland /*: public EventFactoryOzone */ {
+ public:
+  EventFactoryOzoneWayland();
+  virtual ~EventFactoryOzoneWayland();
+
+  // Returns the static instance last set using SetInstance().
+  static EventFactoryOzoneWayland* GetInstance();
+
+  // Sets the implementation delegate. Ownership is retained by the caller.
+  static void SetInstance(EventFactoryOzoneWayland* instance);
+
+  // Sets the window change observer. Ownership is retained by the caller.
+  void SetWindowChangeObserver(WindowChangeObserver* observer);
+  WindowChangeObserver* GetWindowChangeObserver() const;
+  // Sets the output change observer. Ownership is retained by the caller.
+  void SetOutputChangeObserver(OutputChangeObserver* observer);
+  // Registered OutputChangeObserver. Ownership is not passed to the caller.
+  OutputChangeObserver* GetOutputChangeObserver() const;
+  void SetEventConverterOzoneWayland(EventConverterOzoneWayland* converter);
+  // EventConverter used to convert native input events to |ui::Event|.
+  // Ownership is not passed to the caller.
+  EventConverterOzoneWayland* EventConverter() const;
+
+ protected:
+  EventConverterOzoneWayland* event_converter_;
+  WindowChangeObserver* observer_;
+  OutputChangeObserver* output_observer_;
+  static EventFactoryOzoneWayland* impl_;  // not owned
+};
+
+
+}  // namespace ui
+
+#endif  // OZONE_UI_EVENTS_EVENT_FACTORY_OZONE_WAYLAND_H_
--- /dev/null
+++ b/ozone/ui/events/ime_state_change_handler.cc
@@ -0,0 +1,30 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/events/ime_state_change_handler.h"
+
+#include "base/logging.h"
+
+namespace ui {
+
+// static
+IMEStateChangeHandler* IMEStateChangeHandler::impl_ = NULL;
+
+IMEStateChangeHandler::IMEStateChangeHandler() {
+}
+
+IMEStateChangeHandler::~IMEStateChangeHandler() {
+}
+
+IMEStateChangeHandler* IMEStateChangeHandler::GetInstance() {
+  CHECK(impl_) << "No IMEStateChangeHandler implementation set.";
+  return impl_;
+}
+
+void IMEStateChangeHandler::SetInstance(IMEStateChangeHandler* impl) {
+  CHECK(!impl_) << "Replacing set IMEStateChangeHandler implementation.";
+  impl_ = impl;
+}
+
+}  // namespace ui
--- /dev/null
+++ b/ozone/ui/events/ime_state_change_handler.h
@@ -0,0 +1,43 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_IME_IME_STATE_CHANGE_HANDLER_H_
+#define OZONE_UI_IME_IME_STATE_CHANGE_HANDLER_H_
+
+#include "base/basictypes.h"
+#include "ozone/platform/ozone_export_wayland.h"
+#include "ui/gfx/geometry/rect.h"
+
+namespace ui {
+
+// A simple interface for passing IME state change notifications coming from
+// Aura to Wayland.
+class OZONE_WAYLAND_EXPORT IMEStateChangeHandler {
+ public:
+  IMEStateChangeHandler();
+  virtual ~IMEStateChangeHandler();
+
+  // Returns the static instance last set using SetInstance().
+  static IMEStateChangeHandler* GetInstance();
+
+  // Sets the implementation delegate. Ownership is retained by the caller.
+  static void SetInstance(IMEStateChangeHandler* instance);
+
+  // This is called with IMEContext needs to be reset.
+  virtual void ResetIme() = 0;
+
+  // Notifies the context that the caret bounds have changed.  |rect| is
+  // relative to screen coordinates.
+  virtual void ImeCaretBoundsChanged(gfx::Rect rect) = 0;
+
+  virtual void ShowInputPanel() = 0;
+  virtual void HideInputPanel() = 0;
+
+ private:
+  static IMEStateChangeHandler* impl_;  // not owned
+};
+
+}  // namespace ui
+
+#endif  // OZONE_UI_IME_IME_STATE_CHANGE_HANDLER_H_
--- /dev/null
+++ b/ozone/ui/events/keyboard_code_conversion_ozone.cc
@@ -0,0 +1,114 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/events/keyboard_code_conversion_ozone.h"
+
+#include "base/logging.h"
+#include "base/strings/stringprintf.h"
+#include "ui/events/event_constants.h"
+
+namespace ui {
+
+KeyboardCode KeyboardCodeFromNativeKeysym(unsigned keysym) {
+  if (keysym >= OZONECHARCODE_a && keysym <= OZONECHARCODE_z) {
+    return static_cast<KeyboardCode>(
+               OZONECHARCODE_A + (keysym - OZONECHARCODE_a));
+  }
+
+  // Check if it's an alphabet or number we can directly cast it in this case.
+  if ((keysym >= OZONECHARCODE_A && keysym <= OZONECHARCODE_Z) ||
+       (keysym >= OZONECHARCODE_0 && keysym <= OZONECHARCODE_9))
+    return static_cast<KeyboardCode>(keysym);
+
+  if (keysym >= OZONEACTIONKEY_BACK && keysym <= OZONEACTIONKEY_OEM_CLEAR)
+    return static_cast<KeyboardCode>(keysym - OZONEACTIONKEY_START);
+
+  if (keysym >= OZONECHARCODE_FILE_SEPARATOR &&
+       keysym <= OZONECHARCODE_TRADEMARK)
+    return VKEY_OEM_102;
+
+  // Empty KeyCode.
+  if (keysym == OZONECHARCODE_NULL)
+    return VKEY_UNKNOWN;
+
+  DLOG(WARNING) << "Unknown keysym: " << base::StringPrintf("0x%x", keysym);
+  return VKEY_UNKNOWN;
+}
+
+uint16 CharacterCodeFromNativeKeySym(unsigned sym, unsigned flags) {
+  const bool ctrl = (flags & EF_CONTROL_DOWN) != 0;
+
+  // Other ctrl characters
+  if (ctrl) {
+    unsigned keysym = sym;
+    if (keysym >= OZONECHARCODE_a && keysym <= OZONECHARCODE_z)
+      keysym = OZONECHARCODE_A + (keysym - OZONECHARCODE_a);
+
+    if (keysym >= OZONECHARCODE_A && keysym <= OZONECHARCODE_Z)
+      return keysym - OZONECHARCODE_A + 1;
+
+    if ((flags & EF_SHIFT_DOWN) != 0) {
+      // following graphics chars require shift key to input.
+      switch (keysym) {
+        // ctrl-@ maps to \x00 (Null byte)
+        case OZONECHARCODE_AT:
+          return OZONECHARCODE_NULL;
+        // ctrl-^ maps to \x1E (Record separator, Information separator two)
+        case OZONECHARCODE_CARET_CIRCUMFLEX:
+          return OZONECHARCODE_RECORD_SEPARATOR;
+        // ctrl-_ maps to \x1F (Unit separator, Information separator one)
+        case OZONECHARCODE_MINUS:
+        case OZONECHARCODE_UNDER_SCORE:
+          return OZONECHARCODE_UNIT_SEPARATOR;
+        default:
+          return OZONECHARCODE_NULL;
+      }
+    } else {
+      switch (keysym) {
+        // ctrl-[ maps to \x1B (Escape)
+        case OZONECHARCODE_LEFT_BRACKET:
+          return OZONECHARCODE_ESCAPE;
+        // ctrl-\ maps to \x1C (File separator, Information separator four)
+        case OZONECHARCODE_BACK_SLASH:
+          return OZONECHARCODE_FILE_SEPARATOR;
+        // ctrl-] maps to \x1D (Group separator, Information separator three)
+        case OZONECHARCODE_RIGHT_BRACKET:
+          return OZONECHARCODE_GROUP_SEPARATOR;
+        // ctrl-Enter maps to \x0A (Line feed)
+        case OZONECHARCODE_RETURN:
+          return OZONECHARCODE_LINEFEED;
+        default:
+          return OZONECHARCODE_NULL;
+      }
+    }
+  }
+
+  if ((sym >= OZONECHARCODE_a && sym <= OZONECHARCODE_z) ||
+       (sym >= OZONECHARCODE_A && sym <= OZONECHARCODE_Z) ||
+         (sym >= OZONECHARCODE_0 && sym <= OZONECHARCODE_9))
+    return sym;
+
+  if (sym >= OZONEACTIONKEY_BACK && sym <= OZONEACTIONKEY_OEM_CLEAR) {
+    switch (sym) {
+      case OZONEACTIONKEY_TAB:
+        return OZONECHARCODE_TAB;
+      case OZONEACTIONKEY_ESCAPE:
+        return OZONECHARCODE_ESCAPE;
+      case OZONEACTIONKEY_RETURN:
+        return OZONECHARCODE_RETURN;
+      case OZONEACTIONKEY_SPACE:
+        return OZONECHARCODE_SPACE;
+      case OZONEACTIONKEY_BACK:
+        return OZONECHARCODE_BACKSPACE;
+        break;
+      default:
+        return OZONECHARCODE_NULL;
+    }
+  }
+
+  return sym;
+}
+
+}  // namespace ui
--- /dev/null
+++ b/ozone/ui/events/keyboard_code_conversion_ozone.h
@@ -0,0 +1,21 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_EVENTS_KEYBOARD_CODE_CONVERSION_OZONE_H_
+#define OZONE_UI_EVENTS_KEYBOARD_CODE_CONVERSION_OZONE_H_
+
+#include "base/basictypes.h"
+#include "ozone/platform/ozone_export_wayland.h"
+#include "ozone/ui/events/keyboard_codes_ozone.h"
+
+namespace ui {
+
+  // A helper function to convert Ozone-WL types to ui::KeyboardCode type.
+  OZONE_WAYLAND_EXPORT KeyboardCode KeyboardCodeFromNativeKeysym(unsigned key);
+  OZONE_WAYLAND_EXPORT uint16 CharacterCodeFromNativeKeySym(unsigned sym,
+                                                            unsigned flags);
+
+}  // namespace ui
+
+#endif  // OZONE_UI_EVENTS_KEYBOARD_CODE_CONVERSION_OZONE_H_
--- /dev/null
+++ b/ozone/ui/events/keyboard_codes_ozone.h
@@ -0,0 +1,409 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_EVENTS_KEYBOARD_CODES_OZONE_H_
+#define OZONE_UI_EVENTS_KEYBOARD_CODES_OZONE_H_
+
+#include "ui/events/keycodes/keyboard_codes_posix.h"
+
+namespace ui {
+
+// This is unfiy the keycodes used in Chromium and XKB/any backend used in
+// Ozone-Wayland.
+
+// Standard ASCII set, HTML Entity names, ISO 10646, ISO 8879, ISO 8859-1.
+enum OZONECHARCODE {
+  OZONECHARCODE_NULL = 0x0000,
+  OZONECHARCODE_PAUSE = 0x0004,
+  OZONECHARCODE_BACKSPACE = 0x0008,
+  OZONECHARCODE_TAB = 0x0009,
+  OZONECHARCODE_LINEFEED = 0x000A,
+  OZONECHARCODE_RETURN = 0x000D,
+  OZONECHARCODE_ESCAPE = 0x001B,
+  OZONECHARCODE_FILE_SEPARATOR = 0x001C,  // SEPARATOR
+  OZONECHARCODE_GROUP_SEPARATOR = 0x001D,
+  OZONECHARCODE_RECORD_SEPARATOR = 0x001E,
+  OZONECHARCODE_UNIT_SEPARATOR = 0x001F,
+  OZONECHARCODE_SPACE = 0x0020,
+  OZONECHARCODE_EXCLAMATORY = 0x0021,  // !
+  OZONECHARCODE_DOUBLE_QUOTES = 0x0022,  // "
+  OZONECHARCODE_NUMBER = 0x0023,  // #
+  OZONECHARCODE_DOLLAR = 0x0024,  // $
+  OZONECHARCODE_PERCENT = 0x0025,  // %
+  OZONECHARCODE_AMPERSAND = 0x0026,  // &
+  OZONECHARCODE_SINGLEQUOTE = 0x0027,  // '
+  OZONECHARCODE_OPEN_PARENTHESIS = 0x0028,  // (
+  OZONECHARCODE_CLOSED_PARENTHESIS = 0x0029,  // )
+  OZONECHARCODE_ASTERISK = 0x002A,  // *
+  OZONECHARCODE_PLUS = 0x002B,  // +
+  OZONECHARCODE_COMMA = 0x002C,  // ,
+  OZONECHARCODE_MINUS = 0x002D,  // -
+  OZONECHARCODE_PERIOD = 0x002E,  // .
+  OZONECHARCODE_SLASH = 0x002F,  // /
+  OZONECHARCODE_0 = 0x0030,  // Numbers.
+  OZONECHARCODE_1 = 0x0031,
+  OZONECHARCODE_2 = 0x0032,
+  OZONECHARCODE_3 = 0x0033,
+  OZONECHARCODE_4 = 0x0034,
+  OZONECHARCODE_5 = 0x0035,
+  OZONECHARCODE_6 = 0x0036,
+  OZONECHARCODE_7 = 0x0037,
+  OZONECHARCODE_8 = 0x0038,
+  OZONECHARCODE_9 = 0x0039,
+  OZONECHARCODE_COLON = 0x003A,  // :
+  OZONECHARCODE_SEMI_COLON = 0x003B,  // ;
+  OZONECHARCODE_LESS_THAN = 0x003C,  // <
+  OZONECHARCODE_EQUAL = 0x003D,  // =
+  OZONECHARCODE_GREATER_THAN = 0x003E,  // >
+  OZONECHARCODE_QUESTION_MARK = 0x003F,  // ?
+  OZONECHARCODE_AT = 0x0040,  // @
+  OZONECHARCODE_A = 0x0041,  // Alphabets.
+  OZONECHARCODE_B = 0x0042,
+  OZONECHARCODE_C = 0x0043,
+  OZONECHARCODE_D = 0x0044,
+  OZONECHARCODE_E = 0x0045,
+  OZONECHARCODE_F = 0x0046,
+  OZONECHARCODE_G = 0x0047,
+  OZONECHARCODE_H = 0x0048,
+  OZONECHARCODE_I = 0x0049,
+  OZONECHARCODE_J = 0x004A,
+  OZONECHARCODE_K = 0x004B,
+  OZONECHARCODE_L = 0x004C,
+  OZONECHARCODE_M = 0x004D,
+  OZONECHARCODE_N = 0x004E,
+  OZONECHARCODE_O = 0x004F,
+  OZONECHARCODE_P = 0x0050,
+  OZONECHARCODE_Q = 0x0051,
+  OZONECHARCODE_R = 0x0052,
+  OZONECHARCODE_S = 0x0053,
+  OZONECHARCODE_T = 0x0054,
+  OZONECHARCODE_U = 0x0055,
+  OZONECHARCODE_V = 0x0056,
+  OZONECHARCODE_W = 0x0057,
+  OZONECHARCODE_X = 0x0058,
+  OZONECHARCODE_Y = 0x0059,
+  OZONECHARCODE_Z = 0x005A,
+  OZONECHARCODE_LEFT_BRACKET = 0x005B,  // [
+  OZONECHARCODE_BACK_SLASH = 0x005C,  // /
+  OZONECHARCODE_RIGHT_BRACKET = 0x005D,  // ]
+  OZONECHARCODE_CARET_CIRCUMFLEX = 0x005E,  // ^
+  OZONECHARCODE_UNDER_SCORE = 0x005F,  // _
+  OZONECHARCODE_GRAVE_ASSCENT = 0x0060,  // `
+  OZONECHARCODE_a = 0x0061,  // Alphabets small case.
+  OZONECHARCODE_b = 0x0062,
+  OZONECHARCODE_c = 0x0063,
+  OZONECHARCODE_d = 0x0064,
+  OZONECHARCODE_e = 0x0065,
+  OZONECHARCODE_f = 0x0066,
+  OZONECHARCODE_g = 0x0067,
+  OZONECHARCODE_h = 0x0068,
+  OZONECHARCODE_i = 0x0069,
+  OZONECHARCODE_j = 0x006A,
+  OZONECHARCODE_k = 0x006B,
+  OZONECHARCODE_l = 0x006C,
+  OZONECHARCODE_m = 0x006D,
+  OZONECHARCODE_n = 0x006E,
+  OZONECHARCODE_o = 0x006F,
+  OZONECHARCODE_p = 0x0070,
+  OZONECHARCODE_q = 0x0071,
+  OZONECHARCODE_r = 0x0072,
+  OZONECHARCODE_s = 0x0073,
+  OZONECHARCODE_t = 0x0074,
+  OZONECHARCODE_u = 0x0075,
+  OZONECHARCODE_v = 0x0076,
+  OZONECHARCODE_w = 0x0077,
+  OZONECHARCODE_x = 0x0078,
+  OZONECHARCODE_y = 0x0079,
+  OZONECHARCODE_z = 0x007A,
+  OZONECHARCODE_OPEN_BRACE = 0x007B,
+  OZONECHARCODE_VERTICAL_BAR = 0x007C,
+  OZONECHARCODE_CLOSE_BRACE = 0x007D,
+  OZONECHARCODE_TILDE = 0x007E,  //  ~
+  OZONECHARCODE_DELETE = 0x007F,  //  del
+  OZONECHARCODE_NONBREAKING_SPACE = 0x00A0,
+  OZONECHARCODE_INVERTED_EXCLAMATION = 0x00A1,  // ¡
+  OZONECHARCODE_CENT = 0x00A2,  // ¢
+  OZONECHARCODE_STERLING = 0x00A3,  // £
+  OZONECHARCODE_CURRENCY = 0x00A4,  // ¤
+  OZONECHARCODE_YEN = 0x00A5,  // ¥
+  OZONECHARCODE_BROKEN_BAR = 0x00A6,  // ¦
+  OZONECHARCODE_SECTION = 0x00A7,  // §
+  OZONECHARCODE_SPACING_DIAERESIS = 0x00A8,  // ¨
+  OZONECHARCODE_COPYRIGHT = 0x00A9,  // ©
+  OZONECHARCODE_FEMININE_ORDINAL_INDICATOR = 0x00AA,  // ª
+  OZONECHARCODE_LEFT_ANGLE_QUOTES = 0x00AB,  // «
+  OZONECHARCODE_NOT_SIGN =  0x00AC,  // ¬
+  OZONECHARCODE_SOFT_HYPHEN = 0x00AD,
+  OZONECHARCODE_REGISTERED = 0x00AE,  // ®
+  OZONECHARCODE_SPACING_MACRON = 0x00AF,
+  OZONECHARCODE_DEGREE = 0x00B0,  // °
+  OZONECHARCODE_PLUS_MINUS = 0x00B1,  // ±
+  OZONECHARCODE_SUPERSCRIPT_TWO = 0x00B2,  // ²
+  OZONECHARCODE_SUPERSCRIPT_THREE = 0x00B3,  // ³
+  OZONECHARCODE_SPACING_ACUTE =  0x00B4,  // ´
+  OZONECHARCODE_MICRO = 0x00B5,  // µ
+  OZONECHARCODE_PARAGRAPH = 0x00B6,  // ¶
+  OZONECHARCODE_MIDDLEDOT = 0x00B7,  // ·
+  OZONECHARCODE_SPACING_CEDILLA = 0x00B8,  // ¸
+  OZONECHARCODE_SUPERSCRIPT_ONE = 0x00B9,  // ¹
+  OZONECHARCODE_MASCULINE_ORDINAL_INDICATOR = 0x00BA,  // º
+  OZONECHARCODE_RIGHTANGLE_QUOTES = 0x00BB,  // »
+  OZONECHARCODE_ONE_QUARTER = 0x00BC,  // ¼
+  OZONECHARCODE_ONE_HALF =  0x00BD,  // ½
+  OZONECHARCODE_THREE_QUARTERS = 0x00BE,  // ¾
+  OZONECHARCODE_INVERTED_QUESTION_MARK = 0x00BF,  // ¿
+  OZONECHARCODE_LA_WITH_GRAVE = 0x00C0,  // À
+  OZONECHARCODE_LA_WITH_ACUTE = 0x00C1,  // Á
+  OZONECHARCODE_LA_WITH_CIRCUMFLEX = 0x00C2,  // Â
+  OZONECHARCODE_LA_WITH_TILDE = 0x00C3,  // Ã
+  OZONECHARCODE_LA_WITH_DIAERESIS = 0x00C4,  // Ä
+  OZONECHARCODE_LA_WITH_RING_ABOVE = 0x00C5,  // Å
+  OZONECHARCODE_LAE = 0x00C6,  // Æ
+  OZONECHARCODE_LC_WITH_CEDILLA = 0x00C7,  // Ç
+  OZONECHARCODE_LE_WITH_GRAVE = 0x00C8,  // È
+  OZONECHARCODE_LE_WITH_ACUTE = 0x00C9,  // É
+  OZONECHARCODE_LE_WITH_CIRCUMFLEX = 0x00CA,  // Ê
+  OZONECHARCODE_LE_WITH_DIAERESIS = 0x00CB,  // Ë
+  OZONECHARCODE_LI_WITH_GRAVE = 0x00CC,  // Ì
+  OZONECHARCODE_LI_WITH_ACUTE = 0x00CD,  // Í
+  OZONECHARCODE_LI_WITH_CIRCUMFLEX = 0x00CE,  // Î
+  OZONECHARCODE_LI_WITH_DIAERESIS = 0x00CF,  // Ï
+  OZONECHARCODE_LETH = 0x00D0,  // Ð
+  OZONECHARCODE_LN_WITH_TILDE =  0x00D1,  // Ñ
+  OZONECHARCODE_LO_WITH_GRAVE = 0x00D2,  // Ò
+  OZONECHARCODE_LO_WITH_ACUTE = 0x00D3,  // Ó
+  OZONECHARCODE_LO_WITH_CIRCUMFLEX = 0x00D4,  // Ô
+  OZONECHARCODE_LO_WITH_TILDE =  0x00D5,  // Õ
+  OZONECHARCODE_LO_WITH_DIAERESIS = 0x00D6,  // Ö
+  OZONECHARCODE_MULTIPLY =  0x00D7,  // ×
+  OZONECHARCODE_LO_WITH_STROKE = 0x00D8,  // Ø
+  OZONECHARCODE_LU_WITH_GRAVE = 0x00D9,  // Ù
+  OZONECHARCODE_LU_WITH_ACUTE = 0x00DA,  // Ú
+  OZONECHARCODE_LU_WITH_CIRCUMFLEX = 0x00DB,  // Û
+  OZONECHARCODE_LU_WITH_DIAERESIS = 0x00DC,  // Ü
+  OZONECHARCODE_LY_WITH_ACUTE =  0x00DD,  // Ý
+  OZONECHARCODE_LTHORN = 0x00DE,  // Þ
+  OZONECHARCODE_LSMALL_SHARP = 0x00DF,  // ß
+  OZONECHARCODE_LSMALL_A_WITH_GRAVE = 0x00E0,  // à
+  OZONECHARCODE_LSMALL_A_WITH_ACUTE = 0x00E1,  // á
+  OZONECHARCODE_LSMALL_A_WITH_CIRCUMFLEX = 0x00E2,  // â
+  OZONECHARCODE_LSMALL_A_WITH_TILDE = 0x00E3,  // ã
+  OZONECHARCODE_LSMALL_A_WITH_DIAERESIS = 0x00E4,  // ä
+  OZONECHARCODE_LSMALL_A_WITH_RINGABOVE = 0x00E5,  // å
+  OZONECHARCODE_LSMALL_AE = 0x00E6,  // æ
+  OZONECHARCODE_LSMALL_C_WITH_CEDILLA = 0x00E7,  // ç
+  OZONECHARCODE_LSMALL_E_WITH_GRAVE = 0x00E8,  // è
+  OZONECHARCODE_LSMALL_E_WITH_ACUTE = 0x00E9,  // é
+  OZONECHARCODE_LSMALL_E_WITH_CIRCUMFLEX = 0x00EA,  // ê
+  OZONECHARCODE_LSMALL_E_WITH_DIAERESIS = 0x00EB,  // ë
+  OZONECHARCODE_LSMALL_I_WITH_GRAVE = 0x00EC,  // ì
+  OZONECHARCODE_LSMALL_I_WITH_ACUTE = 0x00ED,  // í
+  OZONECHARCODE_LSMALL_I_WITH_CIRCUMFLEX = 0x00EE,  // î
+  OZONECHARCODE_LSMALL_I_WITH_DIAERESIS = 0x00EF,  // ï
+  OZONECHARCODE_LSMALL_ETH = 0x00F0,  // ð
+  OZONECHARCODE_LSMALL_N_WITH_TILDE =  0x00F1,  // ñ
+  OZONECHARCODE_LSMALL_O_WITH_GRAVE = 0x00F2,  // ò
+  OZONECHARCODE_LSMALL_O_WITH_ACUTE = 0x00F3,  // ó
+  OZONECHARCODE_LSMALL_O_WITH_CIRCUMFLEX = 0x00F4,  // ô
+  OZONECHARCODE_LSMALL_O_WITH_TILDE =  0x00F5,  // õ
+  OZONECHARCODE_LSMALL_O_WITH_DIAERESIS = 0x00F6,  // ö
+  OZONECHARCODE_DIVISION =  0x00F7,  // ÷
+  OZONECHARCODE_LSMALL_O_WITH_SLASH = 0x00F8,  // ø
+  OZONECHARCODE_LSMALL_U_WITH_GRAVE = 0x00F9,  // ù
+  OZONECHARCODE_LSMALL_U_WITH_ACUTE = 0x00FA,  // ú
+  OZONECHARCODE_LSMALL_U_WITH_CIRCUMFLEX = 0x00FB,  // û
+  OZONECHARCODE_LSMALL_U_WITH_DIAERESIS = 0x00FC,  // ü
+  OZONECHARCODE_LSMALL_Y_WITH_ACUTE =  0x00FD,  // ý
+  OZONECHARCODE_LSMALL_THORN = 0x00FE,  // þ
+  OZONECHARCODE_LSMALL_UY_WITH_DIAERESIS = 0x00FF,  // ÿ
+  OZONECHARCODE_LSMALL_DOT_LESS_I = 0x0131,  // ı
+  OZONECHARCODE_LSMALL_KRA = 0x0138,  // ĸ
+  OZONECHARCODE_LENG = 0x014A,  // Ŋ
+  OZONECHARCODE_LSMALL_ENG = 0x014B,  // ŋ
+  OZONECHARCODE_LOE = 0x00152,  // Œ
+  OZONECHARCODE_LSMALL_OE = 0x0153,  // œ
+  OZONECHARCODE_LSWITH_CARRON = 0x0160,  // Š
+  OZONECHARCODE_LSMALL_S_WITH_CARRON = 0x0161,  // š
+  OZONECHARCODE_LY_WITH_DIAERESIS = 0x0178,  // Ÿ
+  OZONECHARCODE_LSMALL_F_WITH_HOOK = 0x0192,  // ƒ
+  OZONECHARCODE_CARON = 0x02C7,  // ˇ
+  OZONECHARCODE_DOUBLE_ACUTE_ACCENT = 0x02DD,  // ˝
+  OZONECHARCODE_COMBINING_HORN = 0x031B,  // ̛
+  OZONECHARCODE_COMBINING_DOT_BELOW = 0x0323,  // .
+  OZONECHARCODE_COMBINING_DIAERESIS_BELOW = 0x0324,  // ..
+  OZONECHARCODE_ENDASH =  0x2013,  // –
+  OZONECHARCODE_EMDASH =  0x2014,  // —
+  OZONECHARCODE_LEFT_SINGLE_QUOTATION_MARK = 0x2018,  // ‘
+  OZONECHARCODE_RIGHT_SINGLE_QUOTATION_MARK = 0x2019,  // ’
+  OZONECHARCODE_SINGLE_LOW_QUOTATION_MARK = 0x201A,  // ‚
+  OZONECHARCODE_LEFT_DOUBLE_QUOTATION_MARK = 0x201C,  // “
+  OZONECHARCODE_RIGHT_DOUBLE_QUOTATION_MARK = 0x201D,  // ”
+  OZONECHARCODE_DOUBLE_LOW_QUOTATION_MARK = 0x201E,  // „
+  OZONECHARCODE_DAGGER =  0x2020,  // †
+  OZONECHARCODE_DOUBLE_DAGGER = 0x2021,  // ‡
+  OZONECHARCODE_BULLET = 0x2022,  // •
+  OZONECHARCODE_HORIZONTAL_ELLIPSIS = 0x2026,  // …
+  OZONECHARCODE_PER_THOUSAND = 0x2030,  // ‰
+  OZONECHARCODE_EURO = 0x20AC,  // €
+  OZONECHARCODE_TRADEMARK = 0x2122  // ™
+};
+
+// Keys which result in specific Action. The enum is defined as
+// OZONEACTIONKEY_START + VKEY_ defined in keyboard_codes_posix. This is to
+// make it easy in oz-wl side to differentiate between character codes and
+// action keys.
+enum OzoneKeyboardCode {
+  OZONEACTIONKEY_START = 0x111100,
+  OZONEACTIONKEY_BACK = OZONEACTIONKEY_START + ui::VKEY_BACK,
+  OZONEACTIONKEY_TAB = OZONEACTIONKEY_START + ui::VKEY_TAB,
+  OZONEACTIONKEY_BACKTAB = OZONEACTIONKEY_START + ui::VKEY_BACKTAB,
+  OZONEACTIONKEY_CLEAR = OZONEACTIONKEY_START + ui::VKEY_CLEAR,
+  OZONEACTIONKEY_RETURN = OZONEACTIONKEY_START + ui::VKEY_RETURN,
+  OZONEACTIONKEY_SHIFT = OZONEACTIONKEY_START + ui::VKEY_SHIFT,
+  OZONEACTIONKEY_CONTROL = OZONEACTIONKEY_START + ui::VKEY_CONTROL,
+  OZONEACTIONKEY_MENU = OZONEACTIONKEY_START + ui::VKEY_MENU,
+  OZONEACTIONKEY_PAUSE = OZONEACTIONKEY_START + ui::VKEY_PAUSE,
+  OZONEACTIONKEY_CAPITAL = OZONEACTIONKEY_START + ui::VKEY_CAPITAL,
+  OZONEACTIONKEY_KANA = OZONEACTIONKEY_START + ui::VKEY_KANA,
+  OZONEACTIONKEY_HANGUL = OZONEACTIONKEY_START + ui::VKEY_HANGUL,
+  OZONEACTIONKEY_JUNJA = OZONEACTIONKEY_START + ui::VKEY_JUNJA,
+  OZONEACTIONKEY_FINAL = OZONEACTIONKEY_START + ui::VKEY_FINAL,
+  OZONEACTIONKEY_HANJA = OZONEACTIONKEY_START + ui::VKEY_HANJA,
+  OZONEACTIONKEY_KANJI = OZONEACTIONKEY_START + ui::VKEY_KANJI,
+  OZONEACTIONKEY_ESCAPE = OZONEACTIONKEY_START + ui::VKEY_ESCAPE,
+  OZONEACTIONKEY_CONVERT = OZONEACTIONKEY_START + ui::VKEY_CONVERT,
+  OZONEACTIONKEY_NONCONVERT = OZONEACTIONKEY_START + ui::VKEY_NONCONVERT,
+  OZONEACTIONKEY_ACCEPT = OZONEACTIONKEY_START + ui::VKEY_ACCEPT,
+  OZONEACTIONKEY_MODECHANGE = OZONEACTIONKEY_START + ui::VKEY_MODECHANGE,
+  OZONEACTIONKEY_SPACE = OZONEACTIONKEY_START + ui::VKEY_SPACE,
+  OZONEACTIONKEY_PRIOR = OZONEACTIONKEY_START + ui::VKEY_PRIOR,
+  OZONEACTIONKEY_NEXT = OZONEACTIONKEY_START + ui::VKEY_NEXT,
+  OZONEACTIONKEY_END = OZONEACTIONKEY_START + ui::VKEY_END,
+  OZONEACTIONKEY_HOME = OZONEACTIONKEY_START + ui::VKEY_HOME,
+  OZONEACTIONKEY_LEFT = OZONEACTIONKEY_START + ui::VKEY_LEFT,
+  OZONEACTIONKEY_UP = OZONEACTIONKEY_START + ui::VKEY_UP,
+  OZONEACTIONKEY_RIGHT = OZONEACTIONKEY_START + ui::VKEY_RIGHT,
+  OZONEACTIONKEY_DOWN = OZONEACTIONKEY_START + ui::VKEY_DOWN,
+  OZONEACTIONKEY_SELECT = OZONEACTIONKEY_START + ui::VKEY_SELECT,
+  OZONEACTIONKEY_PRINT = OZONEACTIONKEY_START + ui::VKEY_PRINT,
+  OZONEACTIONKEY_EXECUTE = OZONEACTIONKEY_START + ui::VKEY_EXECUTE,
+  OZONEACTIONKEY_SNAPSHOT = OZONEACTIONKEY_START + ui::VKEY_SNAPSHOT,
+  OZONEACTIONKEY_INSERT = OZONEACTIONKEY_START + ui::VKEY_INSERT,
+  OZONEACTIONKEY_DELETE = OZONEACTIONKEY_START + ui::VKEY_DELETE,
+  OZONEACTIONKEY_HELP = OZONEACTIONKEY_START + ui::VKEY_HELP,
+  OZONEACTIONKEY_LWIN = OZONEACTIONKEY_START + ui::VKEY_LWIN,
+  OZONEACTIONKEY_COMMAND = OZONEACTIONKEY_START + ui::VKEY_COMMAND,
+  OZONEACTIONKEY_RWIN = OZONEACTIONKEY_START + ui::VKEY_RWIN,
+  OZONEACTIONKEY_APPS = OZONEACTIONKEY_START + ui::VKEY_APPS,
+  OZONEACTIONKEY_SLEEP = OZONEACTIONKEY_START + ui::VKEY_SLEEP,
+  OZONEACTIONKEY_ADD = OZONEACTIONKEY_START + ui::VKEY_ADD,
+  OZONEACTIONKEY_SEPARATOR = OZONEACTIONKEY_START + ui::VKEY_SEPARATOR,
+  OZONEACTIONKEY_SUBTRACT = OZONEACTIONKEY_START + ui::VKEY_SUBTRACT,
+  OZONEACTIONKEY_DECIMAL = OZONEACTIONKEY_START + ui::VKEY_DECIMAL,
+  OZONEACTIONKEY_DIVIDE = OZONEACTIONKEY_START + ui::VKEY_DIVIDE,
+  OZONEACTIONKEY_F1 = OZONEACTIONKEY_START + ui::VKEY_F1,
+  OZONEACTIONKEY_F2 = OZONEACTIONKEY_START + ui::VKEY_F2,
+  OZONEACTIONKEY_F3 = OZONEACTIONKEY_START + ui::VKEY_F3,
+  OZONEACTIONKEY_F4 = OZONEACTIONKEY_START + ui::VKEY_F4,
+  OZONEACTIONKEY_F5 = OZONEACTIONKEY_START + ui::VKEY_F5,
+  OZONEACTIONKEY_F6 = OZONEACTIONKEY_START + ui::VKEY_F6,
+  OZONEACTIONKEY_F7 = OZONEACTIONKEY_START + ui::VKEY_F7,
+  OZONEACTIONKEY_F8 = OZONEACTIONKEY_START + ui::VKEY_F8,
+  OZONEACTIONKEY_F9 = OZONEACTIONKEY_START + ui::VKEY_F9,
+  OZONEACTIONKEY_F10 = OZONEACTIONKEY_START + ui::VKEY_F10,
+  OZONEACTIONKEY_F11 = OZONEACTIONKEY_START + ui::VKEY_F11,
+  OZONEACTIONKEY_F12 = OZONEACTIONKEY_START + ui::VKEY_F12,
+  OZONEACTIONKEY_F13 = OZONEACTIONKEY_START + ui::VKEY_F13,
+  OZONEACTIONKEY_F14 = OZONEACTIONKEY_START + ui::VKEY_F14,
+  OZONEACTIONKEY_F15 = OZONEACTIONKEY_START + ui::VKEY_F15,
+  OZONEACTIONKEY_F16 = OZONEACTIONKEY_START + ui::VKEY_F16,
+  OZONEACTIONKEY_F17 = OZONEACTIONKEY_START + ui::VKEY_F17,
+  OZONEACTIONKEY_F18 = OZONEACTIONKEY_START + ui::VKEY_F18,
+  OZONEACTIONKEY_F19 = OZONEACTIONKEY_START + ui::VKEY_F19,
+  OZONEACTIONKEY_F20 = OZONEACTIONKEY_START + ui::VKEY_F20,
+  OZONEACTIONKEY_F21 = OZONEACTIONKEY_START + ui::VKEY_F21,
+  OZONEACTIONKEY_F22 = OZONEACTIONKEY_START + ui::VKEY_F22,
+  OZONEACTIONKEY_F23 = OZONEACTIONKEY_START + ui::VKEY_F23,
+  OZONEACTIONKEY_F24 = OZONEACTIONKEY_START + ui::VKEY_F24,
+  OZONEACTIONKEY_NUMLOCK = OZONEACTIONKEY_START + ui::VKEY_NUMLOCK,
+  OZONEACTIONKEY_SCROLL = OZONEACTIONKEY_START + ui::VKEY_SCROLL,
+  OZONEACTIONKEY_WLAN = OZONEACTIONKEY_START + ui::VKEY_WLAN,
+  OZONEACTIONKEY_POWER = OZONEACTIONKEY_START + ui::VKEY_POWER,
+  OZONEACTIONKEY_LSHIFT = OZONEACTIONKEY_START + ui::VKEY_LSHIFT,
+  OZONEACTIONKEY_RSHIFT = OZONEACTIONKEY_START + ui::VKEY_RSHIFT,
+  OZONEACTIONKEY_LCONTROL = OZONEACTIONKEY_START + ui::VKEY_LCONTROL,
+  OZONEACTIONKEY_RCONTROL = OZONEACTIONKEY_START + ui::VKEY_RCONTROL,
+  OZONEACTIONKEY_LMENU = OZONEACTIONKEY_START + ui::VKEY_LMENU,
+  OZONEACTIONKEY_RMENU = OZONEACTIONKEY_START + ui::VKEY_RMENU,
+  OZONEACTIONKEY_BROWSER_BACK = OZONEACTIONKEY_START + ui::VKEY_BROWSER_BACK,
+  OZONEACTIONKEY_BROWSER_FORWARD = OZONEACTIONKEY_START +
+                                     ui::VKEY_BROWSER_FORWARD,
+  OZONEACTIONKEY_BROWSER_REFRESH = OZONEACTIONKEY_START +
+                                     ui::VKEY_BROWSER_REFRESH,
+  OZONEACTIONKEY_BROWSER_STOP = OZONEACTIONKEY_START + ui::VKEY_BROWSER_STOP,
+  OZONEACTIONKEY_BROWSER_SEARCH = OZONEACTIONKEY_START +
+                                    ui::VKEY_BROWSER_SEARCH,
+  OZONEACTIONKEY_BROWSER_FAVORITES = OZONEACTIONKEY_START +
+                                       ui::VKEY_BROWSER_FAVORITES,
+  OZONEACTIONKEY_BROWSER_HOME = OZONEACTIONKEY_START + ui::VKEY_BROWSER_HOME,
+  OZONEACTIONKEY_VOLUME_MUTE = OZONEACTIONKEY_START + ui::VKEY_VOLUME_MUTE,
+  OZONEACTIONKEY_VOLUME_DOWN = OZONEACTIONKEY_START + ui::VKEY_VOLUME_DOWN,
+  OZONEACTIONKEY_VOLUME_UP = OZONEACTIONKEY_START + ui::VKEY_VOLUME_UP,
+  OZONEACTIONKEY_MEDIA_NEXT_TRACK = OZONEACTIONKEY_START +
+                                      ui::VKEY_MEDIA_NEXT_TRACK ,
+  OZONEACTIONKEY_MEDIA_PREV_TRACK = OZONEACTIONKEY_START +
+                                      ui::VKEY_MEDIA_PREV_TRACK,
+  OZONEACTIONKEY_MEDIA_STOP = OZONEACTIONKEY_START + ui::VKEY_MEDIA_STOP,
+  OZONEACTIONKEY_MEDIA_PLAY_PAUSE = OZONEACTIONKEY_START +
+                                      ui::VKEY_MEDIA_PLAY_PAUSE,
+  OZONEACTIONKEY_MEDIA_LAUNCH_MAIL = OZONEACTIONKEY_START +
+                                       ui::VKEY_MEDIA_LAUNCH_MAIL,
+  OZONEACTIONKEY_MEDIA_LAUNCH_MEDIA_SELECT = OZONEACTIONKEY_START
+      +ui::VKEY_MEDIA_LAUNCH_MEDIA_SELECT,
+  OZONEACTIONKEY_MEDIA_LAUNCH_APP1 = OZONEACTIONKEY_START +
+                                       ui::VKEY_MEDIA_LAUNCH_APP1,
+  OZONEACTIONKEY_MEDIA_LAUNCH_APP2 = OZONEACTIONKEY_START +
+                                       ui::VKEY_MEDIA_LAUNCH_APP2,
+  OZONEACTIONKEY_OEM_1 = OZONEACTIONKEY_START + ui::VKEY_OEM_1,
+  OZONEACTIONKEY_OEM_PLUS = OZONEACTIONKEY_START + ui::VKEY_OEM_PLUS,
+  OZONEACTIONKEY_OEM_COMMA = OZONEACTIONKEY_START + ui::VKEY_OEM_COMMA,
+  OZONEACTIONKEY_OEM_MINUS = OZONEACTIONKEY_START + ui::VKEY_OEM_MINUS,
+  OZONEACTIONKEY_OEM_PERIOD = OZONEACTIONKEY_START + ui::VKEY_OEM_PERIOD,
+  OZONEACTIONKEY_OEM_2 = OZONEACTIONKEY_START + ui::VKEY_OEM_2,
+  OZONEACTIONKEY_OEM_3 = OZONEACTIONKEY_START + ui::VKEY_OEM_3,
+  OZONEACTIONKEY_BRIGHTNESS_DOWN = OZONEACTIONKEY_START +
+                                     ui::VKEY_BRIGHTNESS_DOWN,
+  OZONEACTIONKEY_BRIGHTNESS_UP = OZONEACTIONKEY_START + ui::VKEY_BRIGHTNESS_UP,
+  OZONEACTIONKEY_KBD_BRIGHTNESS_DOWN = OZONEACTIONKEY_START +
+                                         ui::VKEY_KBD_BRIGHTNESS_DOWN,
+  OZONEACTIONKEY_OEM_4 = OZONEACTIONKEY_START + ui::VKEY_OEM_4,
+  OZONEACTIONKEY_OEM_5 = OZONEACTIONKEY_START + ui::VKEY_OEM_5,
+  OZONEACTIONKEY_OEM_6 = OZONEACTIONKEY_START + ui::VKEY_OEM_6,
+  OZONEACTIONKEY_OEM_7 = OZONEACTIONKEY_START + ui::VKEY_OEM_7,
+  OZONEACTIONKEY_OEM_8 = OZONEACTIONKEY_START + ui::VKEY_OEM_8,
+  OZONEACTIONKEY_ALTGR = OZONEACTIONKEY_START + ui::VKEY_ALTGR,
+  OZONEACTIONKEY_OEM_102 = OZONEACTIONKEY_START + ui::VKEY_OEM_102,
+  OZONEACTIONKEY_OEM_103 = OZONEACTIONKEY_START + ui::VKEY_OEM_103,
+  OZONEACTIONKEY_OEM_104 = OZONEACTIONKEY_START + ui::VKEY_OEM_104,
+  OZONEACTIONKEY_PROCESSKEY = OZONEACTIONKEY_START + ui::VKEY_PROCESSKEY,
+  OZONEACTIONKEY_COMPOSE = OZONEACTIONKEY_START + 0xE6,
+  OZONEACTIONKEY_PACKET = OZONEACTIONKEY_START + ui::VKEY_PACKET,
+  OZONEACTIONKEY_KBD_BRIGHTNESS_UP = OZONEACTIONKEY_START +
+                                       ui::VKEY_KBD_BRIGHTNESS_UP,
+  OZONEACTIONKEY_DBE_SBCSCHAR = OZONEACTIONKEY_START + ui::VKEY_DBE_SBCSCHAR,
+  OZONEACTIONKEY_DBE_DBCSCHAR = OZONEACTIONKEY_START + ui::VKEY_DBE_DBCSCHAR,
+  OZONEACTIONKEY_ATTN = OZONEACTIONKEY_START + ui::VKEY_ATTN,
+  OZONEACTIONKEY_CRSEL = OZONEACTIONKEY_START + ui::VKEY_CRSEL,
+  OZONEACTIONKEY_EXSEL = OZONEACTIONKEY_START + ui::VKEY_EXSEL,
+  OZONEACTIONKEY_EREOF = OZONEACTIONKEY_START + ui::VKEY_EREOF,
+  OZONEACTIONKEY_PLAY = OZONEACTIONKEY_START + ui::VKEY_PLAY,
+  OZONEACTIONKEY_ZOOM = OZONEACTIONKEY_START + ui::VKEY_ZOOM,
+  OZONEACTIONKEY_NONAME = OZONEACTIONKEY_START + ui::VKEY_NONAME,
+  OZONEACTIONKEY_PA1 = OZONEACTIONKEY_START + ui::VKEY_PA1,
+  OZONEACTIONKEY_OEM_CLEAR = OZONEACTIONKEY_START + ui::VKEY_OEM_CLEAR
+};
+
+}  // namespace ui
+
+#endif  // OZONE_UI_EVENTS_KEYBOARD_CODES_OZONE_H_
--- /dev/null
+++ b/ozone/ui/events/output_change_observer.h
@@ -0,0 +1,26 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_EVENTS_OUTPUT_CHANGE_OBSERVER_H_
+#define OZONE_UI_EVENTS_OUTPUT_CHANGE_OBSERVER_H_
+
+#include "ozone/platform/ozone_export_wayland.h"
+
+namespace ui {
+
+// A simple observer interface for all clients interested in receiving various
+// output change notifications like size changes, when a new output is added,
+// etc.
+class OZONE_WAYLAND_EXPORT OutputChangeObserver {
+ public:
+  // Called when the current output size has changed.
+  virtual void OnOutputSizeChanged(unsigned width, unsigned height) = 0;
+
+ protected:
+  virtual ~OutputChangeObserver() {}
+};
+
+}  // namespace ui
+
+#endif  // OZONE_UI_EVENTS_OUPUT_CHANGE_OBSERVER_H_
--- /dev/null
+++ b/ozone/ui/events/window_change_observer.h
@@ -0,0 +1,43 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_EVENTS_WINDOW_CHANGE_OBSERVER_H_
+#define OZONE_UI_EVENTS_WINDOW_CHANGE_OBSERVER_H_
+
+#include <string>
+
+#include "ozone/platform/ozone_export_wayland.h"
+namespace ui {
+
+// A simple observer interface for all clients interested in recieving various
+// window state change notifications like when the pointer enters a
+// particular window.
+class OZONE_WAYLAND_EXPORT WindowChangeObserver {
+ public:
+  // Called when the pointer enters a window and recieves a button down
+  // notification.
+  virtual void OnWindowFocused(unsigned windowhandle) = 0;
+  // Called when the pointer enters a window.
+  virtual void OnWindowEnter(unsigned windowhandle) = 0;
+  // Called when the pointer leaves a window.
+  virtual void OnWindowLeave(unsigned windowhandle) = 0;
+  // Called when a window is closed.
+  virtual void OnWindowClose(unsigned windowhandle) = 0;
+  // Called when a window is resized by server.
+  virtual void OnWindowResized(unsigned windowhandle,
+                               unsigned width,
+                               unsigned height) = 0;
+  // FIXME(joone): Move to IMEChangeObserver?
+  virtual void OnPreeditChanged(unsigned handle,
+                                const std::string& text,
+                                const std::string& commit) = 0;
+  virtual void OnCommit(unsigned handle, const std::string& text) = 0;
+
+ protected:
+  virtual ~WindowChangeObserver() {}
+};
+
+}  // namespace ui
+
+#endif  // OZONE_UI_EVENTS_WINDOW_CHANGE_OBSERVER_H_
--- /dev/null
+++ b/ozone/ui/events/window_constants.h
@@ -0,0 +1,34 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_EVENTS_WINDOW_CONSTANTS_H_
+#define OZONE_UI_EVENTS_WINDOW_CONSTANTS_H_
+
+namespace ui {
+
+  enum WidgetState {
+    CREATE = 1,  // Create a new Widget
+    SHOW = 2,  // Widget is visible.
+    HIDE = 3,  // Widget is hidden.
+    FULLSCREEN = 4,  // Widget is in fullscreen mode.
+    MAXIMIZED = 5,  // Widget is maximized,
+    MINIMIZED = 6,  // Widget is minimized.
+    RESTORE = 7,  // Restore Widget.
+    ACTIVE = 8,  // Widget is Activated.
+    INACTIVE = 9,  // Widget is DeActivated.
+    RESIZE = 10,  // Widget is Resized.
+    DESTROYED = 11  // Widget is Destroyed.
+  };
+
+  enum WidgetType {
+    WINDOW = 1,  // A decorated Window.
+    WINDOWFRAMELESS = 2,  // An undecorated Window.
+    POPUP = 3  // An undecorated Window, with transient positioning relative to
+      // its parent and in which the input pointer is implicit grabbed
+      // (i.e. Wayland install the grab) by the Window.
+  };
+
+}  // namespace ui
+
+#endif  // OZONE_UI_EVENTS_WINDOW_CONSTANTS_H_
--- /dev/null
+++ b/ozone/ui/events/window_state_change_handler.cc
@@ -0,0 +1,30 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/events/window_state_change_handler.h"
+
+#include "base/logging.h"
+
+namespace ui {
+
+// static
+WindowStateChangeHandler* WindowStateChangeHandler::impl_ = NULL;
+
+WindowStateChangeHandler::WindowStateChangeHandler() {
+}
+
+WindowStateChangeHandler::~WindowStateChangeHandler() {
+}
+
+WindowStateChangeHandler* WindowStateChangeHandler::GetInstance() {
+  CHECK(impl_) << "No WindowStateChangeHandler implementation set.";
+  return impl_;
+}
+
+void WindowStateChangeHandler::SetInstance(WindowStateChangeHandler* impl) {
+  CHECK(!impl_) << "Replacing set WindowStateChangeHandler implementation.";
+  impl_ = impl;
+}
+
+}  // namespace ui
--- /dev/null
+++ b/ozone/ui/events/window_state_change_handler.h
@@ -0,0 +1,52 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_EVENTS_WINDOW_STATE_CHANGE_HANDLER_H_
+#define OZONE_UI_EVENTS_WINDOW_STATE_CHANGE_HANDLER_H_
+
+#include "base/basictypes.h"
+#include "base/strings/string16.h"
+#include "ozone/platform/ozone_export_wayland.h"
+#include "ozone/ui/events/window_constants.h"
+
+namespace ui {
+
+// A simple interface for passing Window state change notifications coming from
+// Aura to Wayland.
+class OZONE_WAYLAND_EXPORT WindowStateChangeHandler {
+ public:
+  WindowStateChangeHandler();
+  virtual ~WindowStateChangeHandler();
+
+  // Returns the static instance last set using SetInstance().
+  static WindowStateChangeHandler* GetInstance();
+
+  // Sets the implementation delegate. Ownership is retained by the caller.
+  static void SetInstance(WindowStateChangeHandler* instance);
+
+  // Called when AcceleratedWidget widget state has changed.
+  virtual void SetWidgetState(unsigned widget,
+                              ui::WidgetState state,
+                              unsigned width = 0,
+                              unsigned height = 0) = 0;
+
+  // Called when AcceleratedWidget widget title has changed.
+  virtual void SetWidgetTitle(unsigned widget, const base::string16& title) = 0;
+  // Called when Cursor has changed and the image needs to be updated.
+  virtual void SetWidgetCursor(int cursor_type) = 0;
+
+  // This is called when we want to create an AcceleratedWidget widget.
+  virtual void SetWidgetAttributes(unsigned widget,
+                                   unsigned parent,
+                                   unsigned x,
+                                   unsigned y,
+                                   ui::WidgetType type) = 0;
+
+ private:
+  static WindowStateChangeHandler* impl_;  // not owned
+};
+
+}  // namespace ui
+
+#endif  // OZONE_UI_EVENTS_WINDOW_STATE_CHANGE_HANDLER_H_
--- /dev/null
+++ b/ozone/ui/gfx/DEPS
@@ -0,0 +1,3 @@
+include_rules = [
+  "+ui/gfx",,
+]
--- /dev/null
+++ b/ozone/ui/gfx/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/ui/gfx/gfx.gypi
@@ -0,0 +1,14 @@
+# Copyright 2014 Intel Corporation. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+{
+  'dependencies': [
+    '<(DEPTH)/ui/gfx/gfx.gyp:gfx',
+  ],
+  'sources': [
+    'ozone_display.h',
+    'ozone_display.cc',
+    'vsync_provider_wayland.cc',
+    'vsync_provider_wayland.h',
+   ],
+}
--- /dev/null
+++ b/ozone/ui/gfx/ozone_display.cc
@@ -0,0 +1,75 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/gfx/ozone_display.h"
+
+#include "base/logging.h"
+#include "ozone/ui/events/window_state_change_handler.h"
+#include "ui/ozone/public/surface_ozone_egl.h"
+
+namespace gfx {
+
+// static
+OzoneDisplay* OzoneDisplay::instance_ = NULL;
+
+OzoneDisplay::OzoneDisplay() {
+}
+
+OzoneDisplay::~OzoneDisplay() {
+}
+
+OzoneDisplay* OzoneDisplay::GetInstance() {
+  CHECK(instance_) << "No OzoneDisplay implementation set.";
+  return instance_;
+}
+
+void OzoneDisplay::SetInstance(OzoneDisplay* instance) {
+  CHECK(!instance_) << "Replacing set OzoneDisplay implementation.";
+  instance_ = instance;
+}
+
+void OzoneDisplay::LookAheadOutputGeometry() {
+}
+
+//ui::SurfaceFactoryOzone::HardwareState
+//OzoneDisplay::InitializeHardware() {
+//  return ui::SurfaceFactoryOzone::FAILED;
+//}
+
+//void OzoneDisplay::ShutdownHardware() { }
+
+intptr_t OzoneDisplay::GetNativeDisplay() {
+  return (intptr_t)NULL;
+}
+
+#ifdef BEFOREDECEMBER
+gfx::AcceleratedWidget OzoneDisplay::GetAcceleratedWidget() {
+  static int opaque_handle = 0;
+  opaque_handle++;
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(opaque_handle,
+                                                              ui::CREATE,
+                                                              0,
+                                                              0);
+
+  return (gfx::AcceleratedWidget)opaque_handle;
+}
+#endif
+
+scoped_ptr<ui::SurfaceOzoneEGL> OzoneDisplay::CreateEGLSurfaceForWidget(
+    gfx::AcceleratedWidget w) {
+  return scoped_ptr<ui::SurfaceOzoneEGL>();
+}
+
+bool OzoneDisplay::LoadEGLGLES2Bindings(
+    ui::SurfaceFactoryOzone::AddGLLibraryCallback add_gl_library,
+    ui::SurfaceFactoryOzone::SetGLGetProcAddressProcCallback setprocaddress) {
+  return false;
+}
+
+const int32*
+OzoneDisplay::GetEGLSurfaceProperties(const int32* desired_list) {
+  return desired_list;
+}
+
+}  // namespace gfx
--- /dev/null
+++ b/ozone/ui/gfx/ozone_display.h
@@ -0,0 +1,55 @@
+// Copyright 2015 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_GFX_OZONE_DISPLAY_H_
+#define OZONE_UI_GFX_OZONE_DISPLAY_H_
+
+#include "ozone/platform/ozone_export_wayland.h"
+#include "ui/gfx/native_widget_types.h"
+#include "ui/ozone/public/surface_factory_ozone.h"
+
+namespace gfx {
+
+class OZONE_WAYLAND_EXPORT OzoneDisplay : public ui::SurfaceFactoryOzone {
+ public:
+  OzoneDisplay();
+  virtual ~OzoneDisplay();
+
+  // Returns the static instance last set using SetInstance().
+  static OzoneDisplay* GetInstance();
+
+  // Sets the implementation delegate. Ownership is retained by the caller.
+  static void SetInstance(OzoneDisplay* instance);
+  
+  // Returns the EGL_PLATFORM variable for use ith mesa.
+  static char const* GetEGLPlatform();
+
+  virtual void LookAheadOutputGeometry();
+
+  // Ozone Display implementation:
+  //virtual ui::SurfaceFactoryOzone::HardwareState InitializeHardware() override;
+  //virtual void ShutdownHardware() override;
+  virtual intptr_t GetNativeDisplay() override;
+
+  //virtual gfx::AcceleratedWidget GetAcceleratedWidget() override;
+
+  // Ownership is passed to the caller.
+  virtual scoped_ptr<ui::SurfaceOzoneEGL> CreateEGLSurfaceForWidget(
+        gfx::AcceleratedWidget widget) override;
+
+  virtual bool LoadEGLGLES2Bindings(
+    ui::SurfaceFactoryOzone::AddGLLibraryCallback add_gl_library,
+    ui::SurfaceFactoryOzone::SetGLGetProcAddressProcCallback
+        proc_address) override;
+  virtual const int32* GetEGLSurfaceProperties(
+      const int32* desired_list) override;
+
+ private:
+  static OzoneDisplay* instance_;
+  DISALLOW_COPY_AND_ASSIGN(OzoneDisplay);
+};
+
+}  // namespace gfx
+
+#endif  // OZONE_UI_GFX_OZONE_DISPLAY_H_
--- /dev/null
+++ b/ozone/ui/gfx/vsync_provider_wayland.cc
@@ -0,0 +1,24 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/gfx/vsync_provider_wayland.h"
+
+#include "base/bind.h"
+#include "base/message_loop/message_loop.h"
+#include "ozone/ui/gfx/ozone_display.h"
+
+namespace gfx {
+
+WaylandSyncProvider::WaylandSyncProvider() {
+}
+
+WaylandSyncProvider::~WaylandSyncProvider() {
+}
+
+void WaylandSyncProvider::GetVSyncParameters(
+         const UpdateVSyncCallback& callback) {
+  // TODO(kalyan): Pass refresh rate and time of the last refresh.
+}
+
+}  // namespace gfx
--- /dev/null
+++ b/ozone/ui/gfx/vsync_provider_wayland.h
@@ -0,0 +1,25 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_GFX_VSYNC_PROVIDER_WAYLAND_H_
+#define OZONE_UI_GFX_VSYNC_PROVIDER_WAYLAND_H_
+
+#include "ui/gfx/vsync_provider.h"
+
+namespace gfx {
+
+class WaylandSyncProvider : public gfx::VSyncProvider {
+ public:
+  explicit WaylandSyncProvider();
+  virtual ~WaylandSyncProvider();
+
+  virtual void GetVSyncParameters(const UpdateVSyncCallback& callback) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(WaylandSyncProvider);
+};
+
+}  // namespace gfx
+
+#endif  // OZONE_UI_GFX_VSYNC_PROVIDER_WAYLAND_H_
--- /dev/null
+++ b/ozone/ui/ime/DEPS
@@ -0,0 +1,3 @@
+include_rules = [
+  "+ui/events",
+]
--- /dev/null
+++ b/ozone/ui/ime/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/ui/ime/ime.gypi
@@ -0,0 +1,15 @@
+# Copyright 2013 Intel Corporation. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'dependencies': [
+    '<(DEPTH)/ui/base/ui_base.gyp:ui_base',
+  ],
+  'sources': [
+    'input_method_context_factory_wayland.h',
+    'input_method_context_factory_wayland.cc',
+    'input_method_context_impl_wayland.h',
+    'input_method_context_impl_wayland.cc',
+  ],
+}
--- /dev/null
+++ b/ozone/ui/ime/input_method_context_factory_wayland.cc
@@ -0,0 +1,25 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/ime/input_method_context_factory_wayland.h"
+
+#include "ozone/ui/ime/input_method_context_impl_wayland.h"
+
+namespace ui {
+
+InputMethodContextFactoryWayland::InputMethodContextFactoryWayland() {
+  LinuxInputMethodContextFactory::SetInstance(this);
+}
+
+InputMethodContextFactoryWayland::~InputMethodContextFactoryWayland() {
+}
+
+scoped_ptr<ui::LinuxInputMethodContext>
+InputMethodContextFactoryWayland::CreateInputMethodContext(
+      ui::LinuxInputMethodContextDelegate* delegate) const {
+  return scoped_ptr<ui::LinuxInputMethodContext>(
+             new InputMethodContextImplWayland(delegate));
+}
+
+}  // namespace ui
--- /dev/null
+++ b/ozone/ui/ime/input_method_context_factory_wayland.h
@@ -0,0 +1,25 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_IME_INPUT_METHOD_CONTEXT_FACTORY_OZONE_H_
+#define OZONE_UI_IME_INPUT_METHOD_CONTEXT_FACTORY_OZONE_H_
+
+#include "ozone/platform/ozone_export_wayland.h"
+#include "ui/base/ime/linux/linux_input_method_context_factory.h"
+
+namespace ui {
+
+class OZONE_WAYLAND_EXPORT InputMethodContextFactoryWayland
+    : public LinuxInputMethodContextFactory  {
+ public:
+  InputMethodContextFactoryWayland();
+  virtual ~InputMethodContextFactoryWayland();
+
+  virtual scoped_ptr<LinuxInputMethodContext> CreateInputMethodContext(
+      ui::LinuxInputMethodContextDelegate* delegate) const override;
+};
+
+}  // namespace ui
+
+#endif  // OZONE_UI_IME_INPUT_METHOD_CONTEXT_FACTORY_OZONE_H_
--- /dev/null
+++ b/ozone/ui/ime/input_method_context_impl_wayland.cc
@@ -0,0 +1,47 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/ui/ime/input_method_context_impl_wayland.h"
+
+#include "base/logging.h"
+#include "ozone/ui/events/ime_state_change_handler.h"
+
+namespace ui {
+
+InputMethodContextImplWayland::InputMethodContextImplWayland(
+    LinuxInputMethodContextDelegate* delegate)
+    : delegate_(delegate) {
+  CHECK(delegate_);
+}
+
+InputMethodContextImplWayland::~InputMethodContextImplWayland() {
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// InputMethodContextImplWayland, ui::LinuxInputMethodContext implementation:
+bool InputMethodContextImplWayland::DispatchKeyEvent(
+    const KeyEvent& key_event) {
+  return false;
+}
+
+void InputMethodContextImplWayland::Reset() {
+  IMEStateChangeHandler::GetInstance()->ResetIme();
+}
+
+void InputMethodContextImplWayland::OnTextInputTypeChanged(
+    ui::TextInputType text_input_type) {
+
+  // FIXME: We need to support more input types.
+  if (text_input_type == ui::TEXT_INPUT_TYPE_NONE)
+    IMEStateChangeHandler::GetInstance()->HideInputPanel();
+  else
+    IMEStateChangeHandler::GetInstance()->ShowInputPanel();
+}
+
+void InputMethodContextImplWayland::OnCaretBoundsChanged(
+    const gfx::Rect& caret_bounds) {
+  IMEStateChangeHandler::GetInstance()->ImeCaretBoundsChanged(caret_bounds);
+}
+
+}  // namespace ui
--- /dev/null
+++ b/ozone/ui/ime/input_method_context_impl_wayland.h
@@ -0,0 +1,38 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_UI_IME_INPUT_METHOD_CONTEXT_IMPL_WAYLAND_H_
+#define OZONE_UI_IME_INPUT_METHOD_CONTEXT_IMPL_WAYLAND_H_
+
+#include "ozone/platform/ozone_export_wayland.h"
+#include "ui/base/ime/linux/linux_input_method_context.h"
+#include "ui/gfx/geometry/rect.h"
+
+namespace ui {
+
+// An implementation of LinuxInputMethodContext for IME support on Ozone
+// platform using Wayland.
+class OZONE_WAYLAND_EXPORT InputMethodContextImplWayland
+    : public LinuxInputMethodContext {
+ public:
+  explicit InputMethodContextImplWayland(
+      ui::LinuxInputMethodContextDelegate* delegate);
+  virtual ~InputMethodContextImplWayland();
+
+  // Overriden from ui::LinuxInputMethodContext
+  virtual bool DispatchKeyEvent(const ui::KeyEvent& key_event) override;
+  virtual void Reset() override;
+  virtual void OnTextInputTypeChanged(ui::TextInputType text_input_type)
+      override;
+  virtual void OnCaretBoundsChanged(const gfx::Rect& caret_bounds) override;
+
+ private:
+  // Must not be NULL.
+  LinuxInputMethodContextDelegate* delegate_;
+  DISALLOW_COPY_AND_ASSIGN(InputMethodContextImplWayland);
+};
+
+}  // namespace ui
+
+#endif  // OZONE_UI_IME_INPUT_METHOD_CONTEXT_IMPL_WAYLAND_H_
--- /dev/null
+++ b/ozone/ui/ui.gypi
@@ -0,0 +1,11 @@
+# Copyright 2014 Intel Corporation. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+{
+  'includes': [
+    'cursor/cursor.gypi',
+    'events/event.gypi',
+    'gfx/gfx.gypi',
+    'ime/ime.gypi',
+   ],
+}
--- /dev/null
+++ b/ozone/wayland/DEPS
@@ -0,0 +1,6 @@
+include_rules = [
+  "-ozone/content",
+  "-ozone/ui/desktop_aura",
+  "+ozone/ui/events",
+  "+ozone/ui/gfx",
+]
--- /dev/null
+++ b/ozone/wayland/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/wayland/display.cc
@@ -0,0 +1,419 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/display.h"
+
+#include <EGL/egl.h>
+#include <string>
+
+#include "base/files/file_path.h"
+#include "base/native_library.h"
+#include "base/stl_util.h"
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/ui/events/output_change_observer.h"
+#include "ozone/ui/gfx/ozone_display.h"
+#include "ozone/wayland/display_poll_thread.h"
+#include "ozone/wayland/egl/surface_ozone_wayland.h"
+#include "ozone/wayland/input/cursor.h"
+#include "ozone/wayland/input_device.h"
+#include "ozone/wayland/screen.h"
+#include "ozone/wayland/shell/shell.h"
+#include "ozone/wayland/window.h"
+#include "ui/ozone/public/surface_ozone_egl.h"
+
+namespace ozonewayland {
+
+WaylandDisplay* WaylandDisplay::instance_ = NULL;
+
+WaylandDisplay::WaylandDisplay() : display_(NULL),
+    registry_(NULL),
+    compositor_(NULL),
+    shell_(NULL),
+    shm_(NULL),
+    primary_screen_(NULL),
+    primary_input_(NULL),
+    display_poll_thread_(NULL),
+    screen_list_(),
+    input_list_(),
+    widget_map_(),
+    serial_(0),
+    processing_events_(false) {
+  LOG(ERROR) << "ozonewayland::WaylandDisplay::WaylandDisplay";
+}
+
+WaylandDisplay::~WaylandDisplay() {
+  Terminate();
+}
+
+const std::list<WaylandScreen*>& WaylandDisplay::GetScreenList() const {
+  return screen_list_;
+}
+
+WaylandWindow* WaylandDisplay::GetWindow(unsigned window_handle) const {
+  return GetWidget(window_handle);
+}
+
+struct wl_text_input_manager* WaylandDisplay::GetTextInputManager() const {
+  return text_input_manager_;
+}
+
+void WaylandDisplay::SyncDisplay() {
+  wl_display_roundtrip(display_);
+}
+
+void WaylandDisplay::FlushDisplay() {
+  wl_display_flush(display_);
+}
+
+void WaylandDisplay::DestroyWindow(unsigned w) {
+  std::map<unsigned, WaylandWindow*>::const_iterator it = widget_map_.find(w);
+  WaylandWindow* widget = it == widget_map_.end() ? NULL : it->second;
+  DCHECK(widget);
+  delete widget;
+  widget_map_.erase(w);
+  if (widget_map_.empty())
+    StopProcessingEvents();
+}
+
+gfx::AcceleratedWidget WaylandDisplay::GetNativeWindow(unsigned window_handle) {
+  // Ensure we are processing wayland event requests.
+  StartProcessingEvents();
+  WaylandWindow* widget = GetWidget(window_handle);
+  DCHECK(widget);
+  widget->RealizeAcceleratedWidget();
+
+  return (gfx::AcceleratedWidget)widget->egl_window();
+}
+
+#if 0
+ui::SurfaceFactoryOzone::HardwareState
+WaylandDisplay::InitializeHardware() {
+  LOG(ERROR) << "ozonewayland::WaylandDisplay::InitializeHardware";
+  InitializeDisplay();
+  if (!display_) {
+    LOG(ERROR) << "WaylandDisplay failed to initialize hardware";
+    return ui::SurfaceFactoryOzone::FAILED;
+  }
+
+  return ui::SurfaceFactoryOzone::INITIALIZED;
+}
+
+void WaylandDisplay::ShutdownHardware() {
+  Terminate();
+}
+#endif
+
+intptr_t WaylandDisplay::GetNativeDisplay() {
+  LOG(ERROR) << "ozonewayland::WaylandDisplay::GetNativeDisplay";
+  return (intptr_t)display_;
+}
+
+/*
+gfx::AcceleratedWidget WaylandDisplay::GetAcceleratedWidget() {
+  static int opaque_handle = 0;
+  opaque_handle++;
+  ui::WindowStateChangeHandler::GetInstance()->SetWidgetState(opaque_handle,
+                                                              ui::CREATE,
+                                                              0,
+                                                              0);
+
+  return (gfx::AcceleratedWidget)opaque_handle;
+}
+*/
+
+scoped_ptr<ui::SurfaceOzoneEGL> WaylandDisplay::CreateEGLSurfaceForWidget(
+    gfx::AcceleratedWidget w) {
+  return make_scoped_ptr<ui::SurfaceOzoneEGL>(new SurfaceOzoneWayland(w));
+}
+
+bool WaylandDisplay::LoadEGLGLES2Bindings(
+    ui::SurfaceFactoryOzone::AddGLLibraryCallback add_gl_library,
+    ui::SurfaceFactoryOzone::SetGLGetProcAddressProcCallback setprocaddress) {
+  // The variable EGL_PLATFORM specifies native platform to be used by the
+  // drivers (atleast on Mesa). When the variable is not set, Mesa uses the
+  // first platform listed in --with-egl-platforms during compilation. Thus, we
+  // ensure here that wayland is set as the native platform. However, we don't
+  // override the EGL_PLATFORM value in case it has already been set.
+  setenv("EGL_PLATFORM", "wayland", 0);
+  base::NativeLibraryLoadError error;
+  base::NativeLibrary gles_library = base::LoadNativeLibrary(
+    base::FilePath("libGLESv2.so.2"), &error);
+
+  if (!gles_library) {
+    LOG(WARNING) << "Failed to load GLES library: " << error.ToString();
+    return false;
+  }
+
+  base::NativeLibrary egl_library = base::LoadNativeLibrary(
+    base::FilePath("libEGL.so.1"), &error);
+
+  if (!egl_library) {
+    LOG(WARNING) << "Failed to load EGL library: " << error.ToString();
+    base::UnloadNativeLibrary(gles_library);
+    return false;
+  }
+
+  GLGetProcAddressProc get_proc_address =
+      reinterpret_cast<GLGetProcAddressProc>(
+          base::GetFunctionPointerFromNativeLibrary(
+              egl_library, "eglGetProcAddress"));
+
+  if (!get_proc_address) {
+    LOG(ERROR) << "eglGetProcAddress not found.";
+    base::UnloadNativeLibrary(egl_library);
+    base::UnloadNativeLibrary(gles_library);
+    return false;
+  }
+
+  setprocaddress.Run(get_proc_address);
+  add_gl_library.Run(egl_library);
+  add_gl_library.Run(gles_library);
+  return true;
+}
+
+const int32*
+WaylandDisplay::GetEGLSurfaceProperties(const int32* desired_list) {
+  static const EGLint kConfigAttribs[] = {
+    EGL_BUFFER_SIZE, 32,
+    EGL_ALPHA_SIZE, 8,
+    EGL_BLUE_SIZE, 8,
+    EGL_GREEN_SIZE, 8,
+    EGL_RED_SIZE, 8,
+    EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+    EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+    EGL_NONE
+  };
+
+  return kConfigAttribs;
+}
+
+void WaylandDisplay::SetWidgetState(unsigned w,
+                                    ui::WidgetState state,
+                                    unsigned width,
+                                    unsigned height) {
+  switch (state) {
+    case ui::CREATE:
+    {
+      CreateAcceleratedSurface(w);
+      break;
+    }
+    case ui::FULLSCREEN:
+    {
+      WaylandWindow* widget = GetWidget(w);
+      widget->SetFullscreen();
+      widget->Resize(width, height);
+      break;
+    }
+    case ui::MAXIMIZED:
+    {
+      WaylandWindow* widget = GetWidget(w);
+      widget->Maximize();
+      break;
+    }
+    case ui::MINIMIZED:
+    {
+      WaylandWindow* widget = GetWidget(w);
+      widget->Minimize();
+      break;
+    }
+    case ui::RESTORE:
+    {
+      WaylandWindow* widget = GetWidget(w);
+      widget->Restore();
+      widget->Resize(width, height);
+      break;
+    }
+    case ui::ACTIVE:
+      NOTIMPLEMENTED() << " ACTIVE " << w;
+      break;
+    case ui::INACTIVE:
+      NOTIMPLEMENTED() << " INACTIVE " << w;
+      break;
+    case ui::SHOW:
+      NOTIMPLEMENTED() << " SHOW " << w;
+      break;
+    case ui::HIDE:
+      NOTIMPLEMENTED() << " HIDE " << w;
+      break;
+    default:
+      break;
+  }
+}
+
+void WaylandDisplay::SetWidgetTitle(unsigned w,
+                                    const base::string16& title) {
+  WaylandWindow* widget = GetWidget(w);
+  DCHECK(widget);
+  widget->SetWindowTitle(title);
+}
+
+void WaylandDisplay::SetWidgetCursor(int cursor_type) {
+  primary_input_->SetCursorType(cursor_type);
+}
+
+void WaylandDisplay::SetWidgetAttributes(unsigned widget,
+                                         unsigned parent,
+                                         unsigned x,
+                                         unsigned y,
+                                         ui::WidgetType type) {
+  WaylandWindow* window = GetWidget(widget);
+  WaylandWindow* parent_window = GetWidget(parent);
+  DCHECK(window);
+  switch (type) {
+  case ui::WINDOW:
+    window->SetShellAttributes(WaylandWindow::TOPLEVEL);
+    break;
+  case ui::WINDOWFRAMELESS:
+    NOTIMPLEMENTED();
+    break;
+  case ui::POPUP:
+    DCHECK(parent_window);
+    window->SetShellAttributes(WaylandWindow::POPUP,
+                               parent_window->ShellSurface(),
+                               x,
+                               y);
+    break;
+  default:
+    break;
+  }
+}
+
+void WaylandDisplay::InitializeDisplay() {
+  DCHECK(!display_);
+  display_ = wl_display_connect(NULL);
+  if (!display_)
+    return;
+
+  instance_ = this;
+  static const struct wl_registry_listener registry_all = {
+    WaylandDisplay::DisplayHandleGlobal
+  };
+
+  registry_ = wl_display_get_registry(display_);
+  wl_registry_add_listener(registry_, &registry_all, this);
+  shell_ = new WaylandShell();
+
+  if (wl_display_roundtrip(display_) < 0) {
+    Terminate();
+    return;
+  }
+
+  ui::WindowStateChangeHandler::SetInstance(this);
+  display_poll_thread_ = new WaylandDisplayPollThread(display_);
+}
+
+WaylandWindow* WaylandDisplay::CreateAcceleratedSurface(unsigned w) {
+  WaylandWindow* window = new WaylandWindow(w);
+  widget_map_[w] = window;
+
+  return window;
+}
+
+void WaylandDisplay::StartProcessingEvents() {
+  DCHECK(display_poll_thread_);
+  // Start polling for wayland events.
+  if (!processing_events_) {
+    display_poll_thread_->StartProcessingEvents();
+    processing_events_ = true;
+  }
+}
+
+void WaylandDisplay::StopProcessingEvents() {
+  DCHECK(display_poll_thread_);
+  // Start polling for wayland events.
+  if (processing_events_) {
+    display_poll_thread_->StopProcessingEvents();
+    processing_events_ = false;
+  }
+}
+
+void WaylandDisplay::Terminate() {
+  if (!widget_map_.empty()) {
+    STLDeleteValues(&widget_map_);
+    widget_map_.clear();
+  }
+
+  for (std::list<WaylandInputDevice*>::iterator i = input_list_.begin();
+      i != input_list_.end(); ++i) {
+      delete *i;
+  }
+
+  for (std::list<WaylandScreen*>::iterator i = screen_list_.begin();
+      i != screen_list_.end(); ++i) {
+      delete *i;
+  }
+
+  screen_list_.clear();
+  input_list_.clear();
+
+  WaylandCursor::Clear();
+
+  if (compositor_)
+    wl_compositor_destroy(compositor_);
+
+  delete shell_;
+  if (shm_)
+    wl_shm_destroy(shm_);
+
+  if (registry_)
+    wl_registry_destroy(registry_);
+
+  delete display_poll_thread_;
+
+  if (display_) {
+    wl_display_flush(display_);
+    wl_display_disconnect(display_);
+    display_ = NULL;
+  }
+
+  instance_ = NULL;
+}
+
+WaylandWindow* WaylandDisplay::GetWidget(unsigned w) const {
+  std::map<unsigned, WaylandWindow*>::const_iterator it = widget_map_.find(w);
+  return it == widget_map_.end() ? NULL : it->second;
+}
+
+
+// static
+void WaylandDisplay::DisplayHandleGlobal(void *data,
+    struct wl_registry *registry,
+    uint32_t name,
+    const char *interface,
+    uint32_t version) {
+
+  WaylandDisplay* disp = static_cast<WaylandDisplay*>(data);
+
+  if (strcmp(interface, "wl_compositor") == 0) {
+    disp->compositor_ = static_cast<wl_compositor*>(
+        wl_registry_bind(registry, name, &wl_compositor_interface, 1));
+  } else if (strcmp(interface, "wl_output") == 0) {
+    WaylandScreen* screen = new WaylandScreen(disp->registry(), name);
+    if (!disp->screen_list_.empty())
+      NOTIMPLEMENTED() << "Multiple screens support is not implemented";
+
+    disp->screen_list_.push_back(screen);
+    // (kalyan) Support extended output.
+    disp->primary_screen_ = disp->screen_list_.front();
+  } else if (strcmp(interface, "wl_seat") == 0) {
+    WaylandInputDevice *input_device = new WaylandInputDevice(disp, name);
+    disp->input_list_.push_back(input_device);
+    disp->primary_input_ = disp->input_list_.front();
+  } else if (strcmp(interface, "wl_shm") == 0) {
+    disp->shm_ = static_cast<wl_shm*>(
+        wl_registry_bind(registry, name, &wl_shm_interface, 1));
+  } else if (strcmp(interface, "wl_text_input_manager") == 0) {
+    disp->text_input_manager_ = static_cast<wl_text_input_manager*>(
+        wl_registry_bind(registry, name, &wl_text_input_manager_interface, 1));
+  } else {
+    disp->shell_->Initialize(registry, name, interface, version);
+  }
+}
+
+}  // namespace ozonewayland
+
+//char const* gfx::OzoneDisplay::GetEGLPlatform() {
+//  return "wayland";
+//}
--- /dev/null
+++ b/ozone/wayland/display.h
@@ -0,0 +1,161 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_DISPLAY_H_
+#define OZONE_WAYLAND_DISPLAY_H_
+
+#if !defined(__STDC_FORMAT_MACROS)
+#define __STDC_FORMAT_MACROS
+#endif
+
+#include <wayland-client.h>
+#include <list>
+#include <map>
+
+#include "base/basictypes.h"
+#include "ozone/ui/events/window_state_change_handler.h"
+#include "ozone/ui/gfx/ozone_display.h"
+#include "ozone/wayland/input/text-client-protocol.h"
+#include "ui/ozone/public/surface_factory_ozone.h"
+
+namespace ozonewayland {
+
+class WaylandDisplayPollThread;
+class WaylandInputDevice;
+class WaylandScreen;
+class WaylandShell;
+class WaylandWindow;
+struct wl_egl_window;
+
+typedef std::map<unsigned, WaylandWindow*> WindowMap;
+
+// WaylandDisplay is a wrapper around wl_display. Once we get a valid
+// wl_display, the Wayland server will send different events to register
+// the Wayland compositor, shell, screens, input devices, ...
+class WaylandDisplay : public ui::WindowStateChangeHandler,
+                       public ui::SurfaceFactoryOzone {
+ public:
+  explicit WaylandDisplay();
+  virtual ~WaylandDisplay();
+
+  // Ownership is not passed to the caller.
+  static WaylandDisplay* GetInstance() { return instance_; }
+
+  // Returns a pointer to wl_display.
+  wl_display* display() const { return display_; }
+
+  wl_registry* registry() const { return registry_; }
+
+  WaylandInputDevice* PrimaryInput() const { return primary_input_; }
+
+  // Returns a list of the registered screens.
+  const std::list<WaylandScreen*>& GetScreenList() const;
+  WaylandScreen* PrimaryScreen() const { return primary_screen_ ; }
+
+  WaylandShell* GetShell() const { return shell_; }
+
+  wl_shm* shm() const { return shm_; }
+  wl_compositor* GetCompositor() const { return compositor_; }
+  struct wl_text_input_manager* GetTextInputManager() const;
+
+  int GetDisplayFd() const { return wl_display_get_fd(display_); }
+  unsigned GetSerial() const { return serial_; }
+  void SetSerial(unsigned serial) { serial_ = serial; }
+  // Returns WaylandWindow associated with w. The ownership is not transferred
+  // to the caller.
+  WaylandWindow* GetWindow(unsigned window_handle) const;
+  gfx::AcceleratedWidget GetNativeWindow(unsigned window_handle);
+
+  // Destroys WaylandWindow whose handle is w.
+  void DestroyWindow(unsigned w);
+
+  // Does a round trip to Wayland server. This call blocks the current thread
+  // until all pending request are processed by the server.
+  void SyncDisplay();
+  void FlushDisplay();
+
+  // Ozone Display implementation:
+  //virtual ui::SurfaceFactoryOzone::HardwareState InitializeHardware() override;
+  //virtual void ShutdownHardware() override;
+  virtual intptr_t GetNativeDisplay() override;
+
+  //virtual gfx::AcceleratedWidget GetAcceleratedWidget() override;
+
+  // Ownership is passed to the caller.
+  virtual scoped_ptr<ui::SurfaceOzoneEGL> CreateEGLSurfaceForWidget(
+        gfx::AcceleratedWidget widget) override;
+
+  virtual bool LoadEGLGLES2Bindings(
+    ui::SurfaceFactoryOzone::AddGLLibraryCallback add_gl_library,
+    ui::SurfaceFactoryOzone::SetGLGetProcAddressProcCallback
+        proc_address) override;
+  virtual const int32* GetEGLSurfaceProperties(
+      const int32* desired_list) override;
+
+  // WindowStateChangeHandler implementation:
+  virtual void SetWidgetState(unsigned widget,
+                              ui::WidgetState state,
+                              unsigned width = 0,
+                              unsigned height = 0) override;
+  virtual void SetWidgetTitle(unsigned w,
+                              const base::string16& title) override;
+  virtual void SetWidgetCursor(int cursor_type) override;
+  virtual void SetWidgetAttributes(unsigned widget,
+                                   unsigned parent,
+                                   unsigned x,
+                                   unsigned y,
+                                   ui::WidgetType type) override;
+
+ private:
+  void InitializeDisplay();
+  // Creates a WaylandWindow backed by EGL Window and maps it to w. This can be
+  // useful for callers to track a particular surface. By default the type of
+  // surface(i.e. toplevel, menu) is none. One needs to explicitly call
+  // WaylandWindow::SetShellAttributes to set this. The ownership of
+  // WaylandWindow is not passed to the caller.
+  WaylandWindow* CreateAcceleratedSurface(unsigned w);
+
+  // Starts polling on display fd. This should be used when one needs to
+  // continuously read pending events coming from Wayland compositor and
+  // dispatch them. The polling is done completely on a separate thread and
+  // doesn't block the thread from which this is called.
+  void StartProcessingEvents();
+  // Stops polling on display fd.
+  void StopProcessingEvents();
+
+  void Terminate();
+  WaylandWindow* GetWidget(unsigned w) const;
+  // This handler resolves all server events used in initialization. It also
+  // handles input device registration, screen registration.
+  static void DisplayHandleGlobal(
+      void *data,
+      struct wl_registry *registry,
+      uint32_t name,
+      const char *interface,
+      uint32_t version);
+
+  // WaylandDisplay manages the memory of all these pointers.
+  wl_display* display_;
+  wl_registry* registry_;
+  wl_compositor* compositor_;
+  WaylandShell* shell_;
+  wl_shm* shm_;
+  struct wl_text_input_manager* text_input_manager_;
+  WaylandScreen* primary_screen_;
+  WaylandInputDevice* primary_input_;
+  WaylandDisplayPollThread* display_poll_thread_;
+
+  std::list<WaylandScreen*> screen_list_;
+  std::list<WaylandInputDevice*> input_list_;
+  WindowMap widget_map_;
+  unsigned serial_;
+  bool processing_events_;
+  static WaylandDisplay* instance_;
+  DISALLOW_COPY_AND_ASSIGN(WaylandDisplay);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_DISPLAY_H_
--- /dev/null
+++ b/ozone/wayland/display_poll_thread.cc
@@ -0,0 +1,166 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/display_poll_thread.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/epoll.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <wayland-client.h>
+
+#include "base/bind.h"
+#include "ozone/wayland/display.h"
+
+namespace ozonewayland {
+const int MAX_EVENTS = 16;
+// os-compatibility
+extern "C" {
+int osEpollCreateCloExec(void);
+
+static int setCloExecOrClose(int fd) {
+  int flags;
+
+  if (fd == -1)
+    return -1;
+
+  flags = fcntl(fd, F_GETFD);
+  if (flags == -1)
+    goto err;
+
+  if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)
+    goto err;
+
+  return fd;
+
+  err:
+    close(fd);
+    return -1;
+}
+
+int osEpollCreateCloExec(void) {
+  int fd;
+
+#ifdef EPOLL_CLOEXEC
+  fd = epoll_create1(EPOLL_CLOEXEC);
+  if (fd >= 0)
+    return fd;
+  if (errno != EINVAL)
+    return -1;
+#endif
+
+  fd = epoll_create(1);
+  return setCloExecOrClose(fd);
+}
+}  // os-compatibility
+
+WaylandDisplayPollThread::WaylandDisplayPollThread(wl_display* display)
+    : base::Thread("WaylandDisplayPollThread"),
+      display_(display),
+      polling_(true, false),
+      stop_polling_(true, false) {
+  DCHECK(display_);
+}
+
+WaylandDisplayPollThread::~WaylandDisplayPollThread() {
+  DCHECK(!polling_.IsSignaled());
+  Stop();
+}
+
+void WaylandDisplayPollThread::StartProcessingEvents() {
+  DCHECK(!polling_.IsSignaled());
+  base::Thread::Options options;
+  options.message_loop_type = base::MessageLoop::TYPE_IO;
+  StartWithOptions(options);
+  SetPriority(base::kThreadPriority_Background);
+  message_loop_proxy()->PostTask(FROM_HERE, base::Bind(
+      &WaylandDisplayPollThread::DisplayRun, this));
+}
+
+void WaylandDisplayPollThread::StopProcessingEvents() {
+  if (polling_.IsSignaled())
+    stop_polling_.Signal();
+}
+
+void  WaylandDisplayPollThread::DisplayRun(WaylandDisplayPollThread* data) {
+  struct epoll_event ep[MAX_EVENTS];
+  int i, ret, count = 0;
+  uint32_t event = 0;
+  bool epoll_err = false;
+  unsigned display_fd = wl_display_get_fd(data->display_);
+  int epoll_fd = osEpollCreateCloExec();
+  if (epoll_fd < 0) {
+    LOG(ERROR) << "Epoll creation failed.";
+    return;
+  }
+
+  ep[0].events = EPOLLIN;
+  ep[0].data.ptr = 0;
+  if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, display_fd, &ep[0]) < 0) {
+    close(epoll_fd);
+    LOG(ERROR) << "epoll_ctl Add failed";
+    return;
+  }
+
+  // Set the signal state. This is used to query from other threads (i.e.
+  // StopProcessingEvents on Main thread), if this thread is still polling.
+  data->polling_.Signal();
+
+  // Adopted from:
+  // http://cgit.freedesktop.org/wayland/weston/tree/clients/window.c#n5531.
+  while (1) {
+    wl_display_dispatch_pending(data->display_);
+    ret = wl_display_flush(data->display_);
+    if (ret < 0 && errno == EAGAIN) {
+      ep[0].events = EPOLLIN | EPOLLERR | EPOLLHUP;
+      epoll_ctl(epoll_fd, EPOLL_CTL_MOD, display_fd, &ep[0]);
+    } else if (ret < 0) {
+      epoll_err = true;
+      break;
+    }
+    // StopProcessingEvents has been called or we have been asked to stop
+    // polling. Break from the loop.
+    if (data->stop_polling_.IsSignaled())
+      break;
+
+    count = epoll_wait(epoll_fd, ep, MAX_EVENTS, -1);
+    // Break if epoll wait returned value less than 0 and we aren't interrupted
+    // by a signal.
+    if (count < 0 && errno != EINTR) {
+      LOG(ERROR) << "epoll_wait returned an error." << errno;
+      epoll_err = true;
+      break;
+    }
+
+    for (i = 0; i < count; i++) {
+      event = ep[i].events;
+      // We can have cases where EPOLLIN and EPOLLHUP are both set for
+      // example. Don't break if both flags are set.
+      if ((event & EPOLLERR || event & EPOLLHUP) &&
+             !(event & EPOLLIN)) {
+        epoll_err = true;
+        break;
+      }
+
+      if (event & EPOLLIN) {
+        ret = wl_display_dispatch(data->display_);
+        if (ret == -1) {
+          LOG(ERROR) << "wl_display_dispatch failed with an error." << errno;
+          epoll_err = true;
+          break;
+        }
+      }
+    }
+
+    if (epoll_err)
+      break;
+  }
+
+  close(epoll_fd);
+  data->polling_.Reset();
+  data->stop_polling_.Reset();
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/display_poll_thread.h
@@ -0,0 +1,37 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_DISPLAY_POLL_THREAD_H_
+#define OZONE_WAYLAND_DISPLAY_POLL_THREAD_H_
+
+#include "base/synchronization/waitable_event.h"
+#include "base/threading/thread.h"
+
+class wl_display;
+namespace ozonewayland {
+// This class lets you poll on a given Wayland display (passed in constructor),
+// read any pending events coming from Wayland compositor and dispatch them.
+// Caller should ensure that StopProcessingEvents is called before display is
+// destroyed.
+class WaylandDisplayPollThread : public base::Thread {
+ public:
+  explicit WaylandDisplayPollThread(wl_display* display);
+  virtual ~WaylandDisplayPollThread();
+
+  // Starts polling on wl_display fd and read/flush requests coming from Wayland
+  // compositor.
+  void StartProcessingEvents();
+  // Stops polling and handling of any events from Wayland compositor.
+  void StopProcessingEvents();
+ private:
+  static void DisplayRun(WaylandDisplayPollThread* data);
+  base::WaitableEvent polling_;  // Is set as long as the thread is polling.
+  base::WaitableEvent stop_polling_;
+  wl_display* display_;
+  DISALLOW_COPY_AND_ASSIGN(WaylandDisplayPollThread);
+};
+
+}  // namespace ozonewayland
+
+#endif
--- /dev/null
+++ b/ozone/wayland/egl/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/wayland/egl/egl_window.cc
@@ -0,0 +1,27 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/egl/egl_window.h"
+
+#include <EGL/egl.h>
+#include <wayland-egl.h>
+
+namespace ozonewayland {
+
+EGLWindow::EGLWindow(struct wl_surface* surface, int32_t width, int32_t height)
+    : window_(NULL) {
+  window_ = wl_egl_window_create(surface, width, height);
+}
+
+EGLWindow::~EGLWindow() {
+  wl_egl_window_destroy(window_);
+}
+
+bool EGLWindow::Resize(int32_t width, int32_t height) {
+  // TODO(kalyan): Check if we need to sync display here.
+  wl_egl_window_resize(window_, width, height, 0, 0);
+  return true;
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/egl/egl_window.h
@@ -0,0 +1,32 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_EGL_EGL_WINDOW_H_
+#define OZONE_WAYLAND_EGL_EGL_WINDOW_H_
+
+#include <wayland-client.h>
+
+#include "base/basictypes.h"
+
+struct wl_egl_window;
+
+namespace ozonewayland {
+
+class WaylandSurface;
+class EGLWindow {
+ public:
+  EGLWindow(struct wl_surface* surface, int32_t width, int32_t height);
+  ~EGLWindow();
+
+  wl_egl_window* egl_window() const { return window_; }
+  bool Resize(int32_t width, int32_t height);
+
+ private:
+  wl_egl_window* window_;
+  DISALLOW_COPY_AND_ASSIGN(EGLWindow);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_EGL_EGL_WINDOW_H_
--- /dev/null
+++ b/ozone/wayland/egl/surface_ozone_wayland.cc
@@ -0,0 +1,41 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/egl/surface_ozone_wayland.h"
+
+#include "ozone/ui/gfx/vsync_provider_wayland.h"
+#include "ozone/wayland/display.h"
+#include "ozone/wayland/window.h"
+
+namespace ozonewayland {
+
+SurfaceOzoneWayland::SurfaceOzoneWayland(unsigned handle)
+    : handle_(handle) {
+}
+
+SurfaceOzoneWayland::~SurfaceOzoneWayland() {
+  WaylandDisplay::GetInstance()->DestroyWindow(handle_);
+  WaylandDisplay::GetInstance()->FlushDisplay();
+}
+
+intptr_t SurfaceOzoneWayland::GetNativeWindow() {
+  return WaylandDisplay::GetInstance()->GetNativeWindow(handle_);
+}
+
+bool SurfaceOzoneWayland::ResizeNativeWindow(
+    const gfx::Size& viewport_size) {
+  WaylandWindow* window = WaylandDisplay::GetInstance()->GetWindow(handle_);
+  DCHECK(window);
+  window->Resize(viewport_size.width(), viewport_size.height());
+}
+
+bool SurfaceOzoneWayland::OnSwapBuffers() {
+  return true;
+}
+
+scoped_ptr<gfx::VSyncProvider> SurfaceOzoneWayland::CreateVSyncProvider() {
+  return scoped_ptr<gfx::VSyncProvider>(new gfx::WaylandSyncProvider());
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/egl/surface_ozone_wayland.h
@@ -0,0 +1,34 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_EGL_SURFACE_OZONE_WAYLAND
+#define OZONE_WAYLAND_EGL_SURFACE_OZONE_WAYLAND
+
+#include "base/basictypes.h"
+#include "base/memory/scoped_ptr.h"
+#include "ui/gfx/gfx_export.h"
+#include "ui/ozone/public/surface_ozone_egl.h"
+
+namespace ozonewayland {
+
+// Provides EGL support for SurfaceOzone.
+class SurfaceOzoneWayland : public ui::SurfaceOzoneEGL {
+public:
+  explicit SurfaceOzoneWayland(unsigned handle);
+  virtual ~SurfaceOzoneWayland() override;
+
+  // SurfaceOzone:
+  virtual intptr_t GetNativeWindow() override;
+  virtual bool ResizeNativeWindow(const gfx::Size& viewport_size) override;
+  virtual bool OnSwapBuffers() override;
+  virtual scoped_ptr<gfx::VSyncProvider> CreateVSyncProvider() override;
+
+ private:
+  unsigned handle_;
+  DISALLOW_COPY_AND_ASSIGN(SurfaceOzoneWayland);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_EGL_SURFACE_OZONE_WAYLAND
--- /dev/null
+++ b/ozone/wayland/input/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/wayland/input/cursor.cc
@@ -0,0 +1,171 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/input/cursor.h"
+
+#include <vector>
+
+#include "base/logging.h"
+#include "ozone/wayland/display.h"
+
+namespace ozonewayland {
+// This number should be equal to size of array defined in WaylandCursorData
+// constructor.
+const unsigned TotalCursorTypes = 24;
+
+class WaylandCursorData {
+ public:
+  explicit WaylandCursorData(wl_shm* shm);
+  ~WaylandCursorData();
+
+  static WaylandCursorData* GetInstance() {
+    return impl_;
+  }
+
+  static void InitializeCursorData(wl_shm* shm) {
+    if (!impl_)
+      impl_ = new WaylandCursorData(shm);
+  }
+
+  static void DestroyCursorData() {
+    if (impl_) {
+      delete impl_;
+      impl_ = NULL;
+    }
+  }
+
+  struct wl_cursor_image* GetCursorImage(WaylandCursor::CursorType index);
+
+ private:
+  wl_cursor_theme* cursor_theme_;
+  // All supported Cursor types.
+  std::vector<wl_cursor*> cursors_;
+  static WaylandCursorData* impl_;
+  DISALLOW_COPY_AND_ASSIGN(WaylandCursorData);
+};
+
+WaylandCursorData* WaylandCursorData::impl_ = NULL;
+
+WaylandCursorData::WaylandCursorData(wl_shm* shm)
+    : cursor_theme_(NULL),
+      cursors_(std::vector<wl_cursor*>(TotalCursorTypes)) {
+  // This list should be always in sync with WaylandCursor::CursorType
+  const char* cursor_names[] = {
+    "default",
+    "bottom_left_corner",
+    "bottom_right_corner",
+    "bottom_side",
+    "cross",
+    "fleur",
+    "grabbing",
+    "left_ptr",
+    "left_side",
+    "left_arrow",
+    "right_side",
+    "top_left_corner",
+    "top_left_arrow",
+    "top_right_corner",
+    "top_side",
+    "up_arrow",
+    "wait",
+    "watch",
+    "xterm",
+    "hand1",
+    "text",
+    "question_arrow",
+    "v_double_arrow",
+    "h_double_arrow"
+  };
+
+  // (kalyan) We should be able to configure the size of cursor and theme name.
+  cursor_theme_ = wl_cursor_theme_load(NULL, 24, shm);
+  DCHECK(cursor_theme_);
+
+  for (unsigned i = 0; i < TotalCursorTypes; i++)
+    cursors_[i] = wl_cursor_theme_get_cursor(cursor_theme_, cursor_names[i]);
+}
+
+struct wl_cursor_image* WaylandCursorData::GetCursorImage(
+    WaylandCursor::CursorType type) {
+  int index = type - 1;
+  const struct wl_cursor* cursor = cursors_.at(index);
+  if (!cursor)
+    return NULL;
+
+  return cursor->images[0];
+}
+
+WaylandCursorData::~WaylandCursorData() {
+  wl_cursor_theme_destroy(cursor_theme_);
+
+  if (!cursors_.empty())
+    cursors_.clear();
+}
+
+WaylandCursor::WaylandCursor(wl_shm* shm) : input_pointer_(NULL),
+    pointer_surface_(NULL),
+    current_cursor_(CURSOR_UNSET) {
+  WaylandCursorData::InitializeCursorData(shm);
+  WaylandDisplay* display = WaylandDisplay::GetInstance();
+  pointer_surface_ = wl_compositor_create_surface(display->GetCompositor());
+}
+
+WaylandCursor::~WaylandCursor() {
+  DCHECK(pointer_surface_);
+  wl_surface_destroy(pointer_surface_);
+}
+
+void WaylandCursor::Clear() {
+  WaylandCursorData::DestroyCursorData();
+}
+
+void WaylandCursor::Update(CursorType type, uint32_t serial) {
+  if (!input_pointer_)
+    return;
+
+  DCHECK(type != CURSOR_UNSET);
+  CursorType cursor_type = type;
+  wl_cursor_image* image = WaylandCursorData::GetInstance()->GetCursorImage(
+      cursor_type);
+
+  if (!image) {
+    LOG(INFO) << "The current cursor theme does not have a cursor for type "
+              << cursor_type << ". Falling back to the default cursor.";
+    // The cursor currently being displayed is already the default one, so we
+    // can just continue showing it.
+    if (current_cursor_ == CURSOR_LEFT_PTR)
+      return;
+
+    cursor_type = CURSOR_LEFT_PTR;
+    image = WaylandCursorData::GetInstance()->GetCursorImage(cursor_type);
+    DCHECK(image);
+  }
+
+  current_cursor_ = cursor_type;
+  struct wl_buffer* buffer = wl_cursor_image_get_buffer(image);
+  int width = image->width;
+  int height = image->height;
+  wl_pointer_set_cursor(input_pointer_,
+                        serial,
+                        pointer_surface_,
+                        image->hotspot_x,
+                        image->hotspot_y);
+
+  struct wl_surface* surface = pointer_surface_;
+  wl_surface_attach(surface, buffer, 0, 0);
+  wl_surface_damage(surface, 0, 0, width, height);
+  wl_surface_commit(surface);
+}
+
+void WaylandCursor::SetInputPointer(wl_pointer* pointer) {
+  if (input_pointer_ == pointer)
+    return;
+
+  if (input_pointer_)
+    wl_pointer_destroy(input_pointer_);
+
+  input_pointer_ = pointer;
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/input/cursor.h
@@ -0,0 +1,66 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_INPUT_CURSOR_H_
+#define OZONE_WAYLAND_INPUT_CURSOR_H_
+
+#include <wayland-client.h>
+#include <wayland-cursor.h>
+
+#include "base/basictypes.h"
+
+namespace ozonewayland {
+
+class WaylandCursor {
+ public:
+  enum CursorType {
+    CURSOR_UNSET = 0,
+    CURSOR_DEFAULT,
+    CURSOR_BOTTOM_LEFT,
+    CURSOR_BOTTOM_RIGHT,
+    CURSOR_BOTTOM,
+    CURSOR_CROSS,
+    CURSOR_FLEUR,
+    CURSOR_DRAGGING,
+    CURSOR_LEFT_PTR,
+    CURSOR_LEFT,
+    CURSOR_LEFT_ARROW,
+    CURSOR_RIGHT,
+    CURSOR_TOP_LEFT,
+    CURSOR_TOP_LEFT_ARROW,
+    CURSOR_TOP_RIGHT,
+    CURSOR_TOP,
+    CURSOR_UP_ARROW,
+    CURSOR_WAIT,
+    CURSOR_WATCH,
+    CURSOR_IBEAM,
+    CURSOR_HAND1,
+    CURSOR_TEXT,
+    CURSOR_QUESTION_ARROW,
+    CURSOR_V_DOUBLE_ARROW,
+    CURSOR_H_DOUBLE_ARROW
+  };
+
+  explicit WaylandCursor(wl_shm* shm);
+  ~WaylandCursor();
+
+  // Destroys CursorData. WaylandDisplay is responsible for calling this as
+  // needed. No other class should call this.
+  static void Clear();
+
+  void Update(CursorType type, uint32_t serial);
+
+  wl_pointer* GetInputPointer() const { return input_pointer_; }
+  void SetInputPointer(wl_pointer* pointer);
+
+ private:
+  wl_pointer* input_pointer_;
+  struct wl_surface* pointer_surface_;
+  CursorType current_cursor_;
+  DISALLOW_COPY_AND_ASSIGN(WaylandCursor);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_DISPLAY_H_
--- /dev/null
+++ b/ozone/wayland/input/keyboard.cc
@@ -0,0 +1,123 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/input/keyboard.h"
+
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/wayland/input/keyboard_engine_xkb.h"
+
+namespace ozonewayland {
+
+WaylandKeyboard::WaylandKeyboard() : input_keyboard_(NULL),
+    dispatcher_(NULL),
+    backend_(NULL) {
+}
+
+WaylandKeyboard::~WaylandKeyboard() {
+  delete backend_;
+
+  if (input_keyboard_)
+    wl_keyboard_destroy(input_keyboard_);
+}
+
+void WaylandKeyboard::OnSeatCapabilities(wl_seat *seat, uint32_t caps) {
+  static const struct wl_keyboard_listener kInputKeyboardListener = {
+    WaylandKeyboard::OnKeyboardKeymap,
+    WaylandKeyboard::OnKeyboardEnter,
+    WaylandKeyboard::OnKeyboardLeave,
+    WaylandKeyboard::OnKeyNotify,
+    WaylandKeyboard::OnKeyModifiers,
+  };
+
+  dispatcher_ = ui::EventFactoryOzoneWayland::GetInstance()->EventConverter();
+
+  if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !input_keyboard_) {
+    DCHECK(!backend_);
+    backend_ =  new KeyboardEngineXKB();
+    input_keyboard_ = wl_seat_get_keyboard(seat);
+    wl_keyboard_add_listener(input_keyboard_, &kInputKeyboardListener,
+        this);
+  } else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && input_keyboard_) {
+    if (backend_) {
+      delete backend_;
+      backend_ = NULL;
+    }
+
+    wl_keyboard_destroy(input_keyboard_);
+    input_keyboard_ = NULL;
+  }
+}
+
+void WaylandKeyboard::OnKeyNotify(void* data,
+                                  wl_keyboard* input_keyboard,
+                                  uint32_t serial,
+                                  uint32_t time,
+                                  uint32_t key,
+                                  uint32_t state) {
+  WaylandKeyboard* device = static_cast<WaylandKeyboard*>(data);
+  ui::EventType type = ui::ET_KEY_PRESSED;
+  WaylandDisplay::GetInstance()->SetSerial(serial);
+  if (state == WL_KEYBOARD_KEY_STATE_RELEASED)
+    type = ui::ET_KEY_RELEASED;
+
+  // Check if we can ignore the KeyEvent notification, saves an IPC call.
+  if (device->backend_->IgnoreKeyNotify(key, type == ui::ET_KEY_PRESSED))
+    return;
+
+  device->dispatcher_->KeyNotify(type,
+                                 device->backend_->ConvertKeyCodeFromEvdev(key),
+                                 device->backend_->GetKeyBoardModifiers());
+}
+
+void WaylandKeyboard::OnKeyboardKeymap(void *data,
+                                       struct wl_keyboard *keyboard,
+                                       uint32_t format,
+                                       int fd,
+                                       uint32_t size) {
+  WaylandKeyboard* device = static_cast<WaylandKeyboard*>(data);
+
+  if (!data) {
+    close(fd);
+    return;
+  }
+
+  if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1) {
+    close(fd);
+    return;
+  }
+
+  device->backend_->OnKeyboardKeymap(fd, size);
+  close(fd);
+}
+
+void WaylandKeyboard::OnKeyboardEnter(void* data,
+                                      wl_keyboard* input_keyboard,
+                                      uint32_t serial,
+                                      wl_surface* surface,
+                                      wl_array* keys) {
+  WaylandDisplay::GetInstance()->SetSerial(serial);
+}
+
+void WaylandKeyboard::OnKeyboardLeave(void* data,
+                                      wl_keyboard* input_keyboard,
+                                      uint32_t serial,
+                                      wl_surface* surface) {
+  WaylandDisplay::GetInstance()->SetSerial(serial);
+}
+
+void WaylandKeyboard::OnKeyModifiers(void *data,
+                                     wl_keyboard *keyboard,
+                                     uint32_t serial,
+                                     uint32_t mods_depressed,
+                                     uint32_t mods_latched,
+                                     uint32_t mods_locked,
+                                     uint32_t group) {
+  WaylandKeyboard* device = static_cast<WaylandKeyboard*>(data);
+  device->backend_->OnKeyModifiers(mods_depressed,
+                                   mods_latched,
+                                   mods_locked,
+                                   group);
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/input/keyboard.h
@@ -0,0 +1,70 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_INPUT_KEYBOARD_H_
+#define OZONE_WAYLAND_INPUT_KEYBOARD_H_
+
+#include <xkbcommon/xkbcommon.h>
+
+#include "ozone/wayland/display.h"
+
+namespace ui {
+class EventConverterOzoneWayland;
+}
+
+namespace ozonewayland {
+
+class KeyboardEngineXKB;
+
+class WaylandKeyboard {
+ public:
+  WaylandKeyboard();
+  ~WaylandKeyboard();
+  KeyboardEngineXKB* GetBackend() { return backend_;}
+
+  void OnSeatCapabilities(wl_seat *seat, uint32_t caps);
+
+ private:
+  static void OnKeyNotify(void* data,
+                          wl_keyboard* input_keyboard,
+                          uint32_t serial,
+                          uint32_t time,
+                          uint32_t key,
+                          uint32_t state);
+
+  static void OnKeyboardKeymap(void *data,
+                               struct wl_keyboard *keyboard,
+                               uint32_t format,
+                               int fd,
+                               uint32_t size);
+
+  static void OnKeyboardEnter(void* data,
+                              wl_keyboard* input_keyboard,
+                              uint32_t serial,
+                              wl_surface* surface,
+                              wl_array* keys);
+
+  static void OnKeyboardLeave(void* data,
+                              wl_keyboard* input_keyboard,
+                              uint32_t serial,
+                              wl_surface* surface);
+
+  static void OnKeyModifiers(void *data,
+                             wl_keyboard *keyboard,
+                             uint32_t serial,
+                             uint32_t mods_depressed,
+                             uint32_t mods_latched,
+                             uint32_t mods_locked,
+                             uint32_t group);
+
+  wl_keyboard* input_keyboard_;
+  ui::EventConverterOzoneWayland* dispatcher_;
+  KeyboardEngineXKB* backend_;
+
+  DISALLOW_COPY_AND_ASSIGN(WaylandKeyboard);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_INPUT_KEYBOARD_H_
--- /dev/null
+++ b/ozone/wayland/input/keyboard_engine_xkb.cc
@@ -0,0 +1,530 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/input/keyboard_engine_xkb.h"
+
+#include <sys/mman.h>
+
+#include "ozone/ui/events/keyboard_codes_ozone.h"
+#include "ui/events/event.h"
+
+namespace ozonewayland {
+
+KeyboardEngineXKB::KeyboardEngineXKB() : keyboard_modifiers_(0),
+    mods_depressed_(0),
+    mods_latched_(0),
+    mods_locked_(0),
+    group_(0),
+    last_key_(-1),
+    cached_sym_(XKB_KEY_NoSymbol),
+    keymap_(NULL),
+    state_(NULL),
+    context_(NULL) {
+}
+
+KeyboardEngineXKB::~KeyboardEngineXKB() {
+  FiniXKB();
+}
+
+void KeyboardEngineXKB::OnKeyboardKeymap(int fd, uint32_t size) {
+  char *map_str =
+      reinterpret_cast<char*>(mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0));
+  if (map_str == MAP_FAILED)
+    return;
+
+  InitXKB();
+  keymap_ = xkb_map_new_from_string(context_,
+                                    map_str,
+                                    XKB_KEYMAP_FORMAT_TEXT_V1,
+                                    (xkb_map_compile_flags)0);
+  munmap(map_str, size);
+  if (!keymap_)
+    return;
+
+  state_ = xkb_state_new(keymap_);
+  if (state_) {
+    xkb_map_unref(keymap_);
+    keymap_ = NULL;
+  }
+}
+
+void KeyboardEngineXKB::OnKeyModifiers(uint32_t mods_depressed,
+                                        uint32_t mods_latched,
+                                        uint32_t mods_locked,
+                                        uint32_t group) {
+  if (!state_)
+    return;
+
+  if ((mods_depressed_ == mods_depressed) && (mods_locked_ == mods_locked)
+      && (mods_latched_ == mods_latched) && (group_ == group)) {
+    return;
+  }
+
+  mods_depressed_ = mods_depressed;
+  mods_locked_ = mods_locked;
+  mods_latched_ = mods_latched;
+  group_ = group;
+  xkb_state_update_mask(state_,
+                        mods_depressed_,
+                        mods_latched_,
+                        mods_locked_,
+                        0,
+                        0,
+                        group_);
+
+  keyboard_modifiers_ = 0;
+  if (xkb_state_mod_name_is_active(
+      state_, XKB_MOD_NAME_SHIFT, XKB_STATE_MODS_EFFECTIVE))
+    keyboard_modifiers_ |= ui::EF_SHIFT_DOWN;
+
+  if (xkb_state_mod_name_is_active(
+      state_, XKB_MOD_NAME_CTRL, XKB_STATE_MODS_EFFECTIVE))
+    keyboard_modifiers_ |= ui::EF_CONTROL_DOWN;
+
+  if (xkb_state_mod_name_is_active(
+      state_, XKB_MOD_NAME_ALT, XKB_STATE_MODS_EFFECTIVE))
+    keyboard_modifiers_ |= ui::EF_ALT_DOWN;
+
+  if (xkb_state_mod_name_is_active(
+      state_, XKB_MOD_NAME_CAPS, XKB_STATE_MODS_EFFECTIVE))
+    keyboard_modifiers_ |= ui::EF_CAPS_LOCK_DOWN;
+}
+
+unsigned KeyboardEngineXKB::ConvertKeyCodeFromEvdev(unsigned hardwarecode) {
+  if (hardwarecode == last_key_)
+    return cached_sym_;
+
+  const xkb_keysym_t *syms;
+  xkb_keysym_t sym;
+  uint32_t code = hardwarecode + 8;
+  uint32_t num_syms = xkb_key_get_syms(state_, code, &syms);
+  if (num_syms == 1)
+    sym = syms[0];
+  else
+    sym = XKB_KEY_NoSymbol;
+
+  last_key_ = hardwarecode;
+  cached_sym_ = sym;
+  NormalizeKey();
+
+  return cached_sym_;
+}
+
+bool KeyboardEngineXKB::IgnoreKeyNotify(
+         unsigned hardwarecode, bool pressed) {
+  // If the key is pressed or it's a special modifier key i.e altgr, we cannot
+  // ignore it.
+  // TODO(kalyan): Handle all needed cases here.
+  if (pressed || IsSpecialModifier(hardwarecode))
+    return false;
+
+  // No modifiers set, we don't have to deal with any special cases. Ignore the
+  // release events.
+  if (!keyboard_modifiers_ || IsOnlyCapsLocked())
+    return true;
+
+  return false;
+}
+
+void KeyboardEngineXKB::InitXKB() {
+  if (context_)
+    return;
+
+  context_ = xkb_context_new((xkb_context_flags)0);
+}
+
+void KeyboardEngineXKB::FiniXKB() {
+  if (state_) {
+    xkb_state_unref(state_);
+    state_ = NULL;
+  }
+
+  if (keymap_) {
+    xkb_map_unref(keymap_);
+    keymap_ = NULL;
+  }
+
+  if (context_) {
+    xkb_context_unref(context_);
+    context_ = NULL;
+  }
+}
+
+bool KeyboardEngineXKB::IsSpecialModifier(unsigned hardwarecode) {
+    switch (ConvertKeyCodeFromEvdev(hardwarecode)) {
+    case XKB_KEY_ISO_Level3_Shift:  // altgr
+      return true;
+    break;
+    default:
+    return false;
+  }
+}
+
+bool KeyboardEngineXKB::IsOnlyCapsLocked() const {
+  if ((keyboard_modifiers_ & ui::EF_CONTROL_DOWN) != 0)
+    return false;
+
+  if ((keyboard_modifiers_ & ui::EF_ALT_DOWN) != 0)
+    return false;
+
+  if ((keyboard_modifiers_ & ui::EF_SHIFT_DOWN) != 0)
+    return false;
+
+  return true;
+}
+
+void KeyboardEngineXKB::NormalizeKey() {
+  if ((cached_sym_ >= XKB_KEY_A && cached_sym_ <= XKB_KEY_Z) ||
+       (cached_sym_ >= XKB_KEY_a && cached_sym_ <= XKB_KEY_z) ||
+         (cached_sym_ >= XKB_KEY_0 && cached_sym_ <= XKB_KEY_9))
+    return;
+
+  if (cached_sym_ >= XKB_KEY_KP_0 && cached_sym_ <= XKB_KEY_KP_9) {
+    // Numpad Number-keys can be represented by a keysym value of 0-9 nos.
+    cached_sym_ = XKB_KEY_0 + (cached_sym_ - XKB_KEY_KP_0);
+  } else if (cached_sym_ > 0x01000100 && cached_sym_ < 0x01ffffff) {
+    // Any UCS character in this range will simply be the character's
+    // Unicode number plus 0x01000000.
+    cached_sym_ = cached_sym_ - 0x001000000;
+  } else if (cached_sym_ >= XKB_KEY_F1 && cached_sym_ <= XKB_KEY_F24) {
+    cached_sym_ = ui::OZONEACTIONKEY_F1 + (cached_sym_ - XKB_KEY_F1);
+  } else if (cached_sym_ >= XKB_KEY_KP_F1 && cached_sym_ <= XKB_KEY_KP_F4) {
+      cached_sym_ = ui::OZONEACTIONKEY_F1 + (cached_sym_ - XKB_KEY_KP_F1);
+  } else {
+      switch (cached_sym_) {
+        case XKB_KEY_dead_circumflex:
+          cached_sym_ = ui::OZONECHARCODE_CARET_CIRCUMFLEX;
+          break;
+        case XKB_KEY_dead_diaeresis:
+          cached_sym_ = ui::OZONECHARCODE_SPACING_DIAERESIS;
+          break;
+        case XKB_KEY_dead_perispomeni:
+          cached_sym_ = ui::OZONECHARCODE_TILDE;
+          break;
+        case XKB_KEY_dead_acute:
+          cached_sym_ = ui::OZONECHARCODE_SPACING_ACUTE;
+          break;
+        case XKB_KEY_dead_grave:
+          cached_sym_ = ui::OZONECHARCODE_GRAVE_ASSCENT;
+          break;
+        case XKB_KEY_endash:
+          cached_sym_ = ui::OZONECHARCODE_ENDASH;
+          break;
+        case XKB_KEY_singlelowquotemark:
+          cached_sym_ = ui::OZONECHARCODE_SINGLE_LOW_QUOTATION_MARK;
+          break;
+        case XKB_KEY_dead_cedilla:
+          cached_sym_ = ui::OZONECHARCODE_SPACING_CEDILLA;
+          break;
+        case XKB_KEY_KP_Equal:
+          cached_sym_ = ui::OZONECHARCODE_EQUAL;
+          break;
+        case XKB_KEY_KP_Multiply:
+          cached_sym_ = ui::OZONECHARCODE_MULTIPLY;
+          break;
+        case XKB_KEY_KP_Add:
+          cached_sym_ = ui::OZONECHARCODE_PLUS;
+          break;
+        case XKB_KEY_KP_Separator:
+          cached_sym_ = ui::OZONECHARCODE_COMMA;
+          break;
+        case XKB_KEY_KP_Subtract:
+          cached_sym_ = ui::OZONECHARCODE_MINUS;
+          break;
+        case XKB_KEY_KP_Decimal:
+          cached_sym_ = ui::OZONECHARCODE_PERIOD;
+          break;
+        case XKB_KEY_KP_Divide:
+          cached_sym_ = ui::OZONECHARCODE_DIVISION;
+          break;
+        case XKB_KEY_Delete:
+        case XKB_KEY_KP_Delete:
+          cached_sym_ = ui::OZONEACTIONKEY_DELETE;
+          break;
+        case XKB_KEY_KP_Tab:
+        case XKB_KEY_ISO_Left_Tab:
+        case XKB_KEY_Tab:
+        case XKB_KEY_3270_BackTab:
+          cached_sym_ = ui::OZONEACTIONKEY_TAB;
+          break;
+        case XKB_KEY_Sys_Req:
+        case XKB_KEY_Escape:
+          cached_sym_ = ui::OZONEACTIONKEY_ESCAPE;
+          break;
+        case XKB_KEY_Linefeed:
+          cached_sym_ = ui::OZONECHARCODE_LINEFEED;
+          break;
+        case XKB_KEY_Return:
+        case XKB_KEY_KP_Enter:
+        case XKB_KEY_ISO_Enter:
+          cached_sym_ = ui::OZONEACTIONKEY_RETURN;
+          break;
+        case XKB_KEY_KP_Space:
+        case XKB_KEY_space:
+          cached_sym_ = ui::OZONEACTIONKEY_SPACE;
+          break;
+        case XKB_KEY_dead_caron:
+          cached_sym_ = ui::OZONECHARCODE_CARON;
+          break;
+        case XKB_KEY_BackSpace:
+          cached_sym_ = ui::OZONEACTIONKEY_BACK;
+          break;
+        case XKB_KEY_dead_doubleacute:
+          cached_sym_ = ui::OZONECHARCODE_DOUBLE_ACUTE_ACCENT;
+          break;
+        case XKB_KEY_dead_horn:
+          cached_sym_ = ui::OZONECHARCODE_COMBINING_HORN;
+          break;
+        case XKB_KEY_oe:
+          cached_sym_ = ui::OZONECHARCODE_LSMALL_OE;
+          break;
+        case XKB_KEY_OE:
+          cached_sym_ = ui::OZONECHARCODE_LOE;
+          break;
+        case XKB_KEY_idotless:
+          cached_sym_ = ui::OZONECHARCODE_LSMALL_DOT_LESS_I;
+          break;
+        case XKB_KEY_kra:
+          cached_sym_ = ui::OZONECHARCODE_LSMALL_KRA;
+          break;
+        case XKB_KEY_dead_stroke:
+          cached_sym_ = ui::OZONECHARCODE_MINUS;
+          break;
+        case XKB_KEY_eng:
+          cached_sym_ = ui::OZONECHARCODE_LSMALL_ENG;
+          break;
+        case XKB_KEY_ENG:
+          cached_sym_ = ui::OZONECHARCODE_LENG;
+          break;
+        case XKB_KEY_leftsinglequotemark:
+          cached_sym_ = ui::OZONECHARCODE_LEFT_SINGLE_QUOTATION_MARK;
+          break;
+        case XKB_KEY_rightsinglequotemark:
+          cached_sym_ = ui::OZONECHARCODE_RIGHT_SINGLE_QUOTATION_MARK;
+          break;
+        case XKB_KEY_dead_belowdot:
+          cached_sym_ = ui::OZONECHARCODE_COMBINING_DOT_BELOW;
+          break;
+        case XKB_KEY_dead_belowdiaeresis:
+          cached_sym_ = ui::OZONECHARCODE_COMBINING_DIAERESIS_BELOW;
+          break;
+        case XKB_KEY_Clear:
+        case XKB_KEY_KP_Begin:
+          cached_sym_ = ui::OZONEACTIONKEY_CLEAR;
+          break;
+        case XKB_KEY_Home:
+        case XKB_KEY_KP_Home:
+          cached_sym_ = ui::OZONEACTIONKEY_HOME;
+          break;
+        case XKB_KEY_End:
+        case XKB_KEY_KP_End:
+          cached_sym_ = ui::OZONEACTIONKEY_END;
+          break;
+        case XKB_KEY_Page_Up:
+        case XKB_KEY_KP_Page_Up:  // aka XKB_KEY_KP_Prior
+          cached_sym_ = ui::OZONEACTIONKEY_PRIOR;
+          break;
+        case XKB_KEY_Page_Down:
+        case XKB_KEY_KP_Page_Down:  // aka XKB_KEY_KP_Next
+          cached_sym_ = ui::OZONEACTIONKEY_NEXT;
+          break;
+        case XKB_KEY_Left:
+        case XKB_KEY_KP_Left:
+          cached_sym_ = ui::OZONEACTIONKEY_LEFT;
+          break;
+        case XKB_KEY_Right:
+        case XKB_KEY_KP_Right:
+          cached_sym_ = ui::OZONEACTIONKEY_RIGHT;
+          break;
+        case XKB_KEY_Down:
+        case XKB_KEY_KP_Down:
+          cached_sym_ = ui::OZONEACTIONKEY_DOWN;
+          break;
+        case XKB_KEY_Up:
+        case XKB_KEY_KP_Up:
+          cached_sym_ = ui::OZONEACTIONKEY_UP;
+          break;
+        case XKB_KEY_Kana_Lock:
+        case XKB_KEY_Kana_Shift:
+          cached_sym_ = ui::OZONEACTIONKEY_KANA;
+          break;
+        case XKB_KEY_Hangul:
+          cached_sym_ = ui::OZONEACTIONKEY_HANGUL;
+          break;
+        case XKB_KEY_Hangul_Hanja:
+          cached_sym_ = ui::OZONEACTIONKEY_HANJA;
+          break;
+        case XKB_KEY_Kanji:
+          cached_sym_ = ui::OZONEACTIONKEY_KANJI;
+          break;
+        case XKB_KEY_Henkan:
+          cached_sym_ = ui::OZONEACTIONKEY_CONVERT;
+          break;
+        case XKB_KEY_Muhenkan:
+          cached_sym_ = ui::OZONEACTIONKEY_NONCONVERT;
+          break;
+        case XKB_KEY_Zenkaku_Hankaku:
+          cached_sym_ = ui::OZONEACTIONKEY_DBE_DBCSCHAR;
+          break;
+        case XKB_KEY_ISO_Level5_Shift:
+          cached_sym_ = ui::OZONEACTIONKEY_OEM_8;
+          break;
+        case XKB_KEY_Shift_L:
+        case XKB_KEY_Shift_R:
+          cached_sym_ = ui::OZONEACTIONKEY_SHIFT;
+          break;
+        case XKB_KEY_Control_L:
+        case XKB_KEY_Control_R:
+          cached_sym_ = ui::OZONEACTIONKEY_CONTROL;
+          break;
+        case XKB_KEY_Meta_L:
+        case XKB_KEY_Meta_R:
+        case XKB_KEY_Alt_L:
+        case XKB_KEY_Alt_R:
+          cached_sym_ = ui::OZONEACTIONKEY_MENU;
+          break;
+        case XKB_KEY_ISO_Level3_Shift:
+          cached_sym_ = ui::OZONEACTIONKEY_ALTGR;
+          break;
+        case XKB_KEY_Multi_key:
+          cached_sym_ = 0xE6;
+          break;
+        case XKB_KEY_Pause:
+          cached_sym_ = ui::OZONEACTIONKEY_PAUSE;
+          break;
+        case XKB_KEY_Caps_Lock:
+          cached_sym_ = ui::OZONEACTIONKEY_CAPITAL;
+          break;
+        case XKB_KEY_Num_Lock:
+          cached_sym_ = ui::OZONEACTIONKEY_NUMLOCK;
+          break;
+        case XKB_KEY_Scroll_Lock:
+          cached_sym_ = ui::OZONEACTIONKEY_SCROLL;
+          break;
+        case XKB_KEY_Select:
+          cached_sym_ = ui::OZONEACTIONKEY_SELECT;
+          break;
+        case XKB_KEY_Print:
+          cached_sym_ = ui::OZONEACTIONKEY_PRINT;
+          break;
+        case XKB_KEY_Execute:
+          cached_sym_ = ui::OZONEACTIONKEY_EXECUTE;
+          break;
+        case XKB_KEY_Insert:
+        case XKB_KEY_KP_Insert:
+          cached_sym_ = ui::OZONEACTIONKEY_INSERT;
+          break;
+        case XKB_KEY_Help:
+          cached_sym_ = ui::OZONEACTIONKEY_HELP;
+          break;
+        case XKB_KEY_Super_L:
+          cached_sym_ = ui::OZONEACTIONKEY_LWIN;
+          break;
+        case XKB_KEY_Super_R:
+          cached_sym_ = ui::OZONEACTIONKEY_RWIN;
+          break;
+        case XKB_KEY_Menu:
+          cached_sym_ = ui::OZONEACTIONKEY_APPS;
+          break;
+        case XKB_KEY_XF86Tools:
+          cached_sym_ = ui::OZONEACTIONKEY_F13;
+          break;
+        case XKB_KEY_XF86Launch5:
+          cached_sym_ = ui::OZONEACTIONKEY_F14;
+          break;
+        case XKB_KEY_XF86Launch6:
+          cached_sym_ = ui::OZONEACTIONKEY_F15;
+          break;
+        case XKB_KEY_XF86Launch7:
+          cached_sym_ = ui::OZONEACTIONKEY_F16;
+          break;
+        case XKB_KEY_XF86Launch8:
+          cached_sym_ = ui::OZONEACTIONKEY_F17;
+          break;
+        case XKB_KEY_XF86Launch9:
+          cached_sym_ = ui::OZONEACTIONKEY_F18;
+          break;
+
+        // For supporting multimedia buttons on a USB keyboard.
+        case XKB_KEY_XF86Back:
+          cached_sym_ = ui::OZONEACTIONKEY_BROWSER_BACK;
+          break;
+        case XKB_KEY_XF86Forward:
+          cached_sym_ = ui::OZONEACTIONKEY_BROWSER_FORWARD;
+          break;
+        case XKB_KEY_XF86Reload:
+          cached_sym_ = ui::OZONEACTIONKEY_BROWSER_REFRESH;
+          break;
+        case XKB_KEY_XF86Stop:
+          cached_sym_ = ui::OZONEACTIONKEY_BROWSER_STOP;
+          break;
+        case XKB_KEY_XF86Search:
+          cached_sym_ = ui::OZONEACTIONKEY_BROWSER_SEARCH;
+          break;
+        case XKB_KEY_XF86Favorites:
+          cached_sym_ = ui::OZONEACTIONKEY_BROWSER_FAVORITES;
+          break;
+        case XKB_KEY_XF86HomePage:
+          cached_sym_ = ui::OZONEACTIONKEY_BROWSER_HOME;
+          break;
+        case XKB_KEY_XF86AudioMute:
+          cached_sym_ = ui::OZONEACTIONKEY_VOLUME_MUTE;
+          break;
+        case XKB_KEY_XF86AudioLowerVolume:
+          cached_sym_ = ui::OZONEACTIONKEY_VOLUME_DOWN;
+          break;
+        case XKB_KEY_XF86AudioRaiseVolume:
+          cached_sym_ = ui::OZONEACTIONKEY_VOLUME_UP;
+          break;
+        case XKB_KEY_XF86AudioNext:
+          cached_sym_ = ui::OZONEACTIONKEY_MEDIA_NEXT_TRACK;
+          break;
+        case XKB_KEY_XF86AudioPrev:
+          cached_sym_ = ui::OZONEACTIONKEY_MEDIA_PREV_TRACK;
+          break;
+        case XKB_KEY_XF86AudioStop:
+          cached_sym_ = ui::OZONEACTIONKEY_MEDIA_STOP;
+          break;
+        case XKB_KEY_XF86AudioPlay:
+          cached_sym_ = ui::OZONEACTIONKEY_MEDIA_PLAY_PAUSE;
+          break;
+        case XKB_KEY_XF86Mail:
+          cached_sym_ = ui::OZONEACTIONKEY_MEDIA_LAUNCH_MAIL;
+          break;
+        case XKB_KEY_XF86LaunchA:
+          cached_sym_ = ui::OZONEACTIONKEY_MEDIA_LAUNCH_APP1;
+          break;
+        case XKB_KEY_XF86LaunchB:
+        case XKB_KEY_XF86Calculator:
+          cached_sym_ = ui::OZONEACTIONKEY_MEDIA_LAUNCH_APP2;
+          break;
+        case XKB_KEY_XF86WLAN:
+          cached_sym_ = ui::OZONEACTIONKEY_WLAN;
+          break;
+        case XKB_KEY_XF86PowerOff:
+          cached_sym_ = ui::OZONEACTIONKEY_POWER;
+          break;
+        case XKB_KEY_XF86MonBrightnessDown:
+          cached_sym_ = ui::OZONEACTIONKEY_BRIGHTNESS_DOWN;
+          break;
+        case XKB_KEY_XF86MonBrightnessUp:
+          cached_sym_ = ui::OZONEACTIONKEY_BRIGHTNESS_UP;
+          break;
+        case XKB_KEY_XF86KbdBrightnessDown:
+          cached_sym_ = ui::OZONEACTIONKEY_KBD_BRIGHTNESS_DOWN;
+          break;
+        case XKB_KEY_XF86KbdBrightnessUp:
+          cached_sym_ = ui::OZONEACTIONKEY_KBD_BRIGHTNESS_UP;
+          break;
+        case XKB_KEY_emptyset:
+        case XKB_KEY_NoSymbol:
+          cached_sym_ = ui::OZONECHARCODE_NULL;
+          break;
+        default:
+          break;
+    }
+  }
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/input/keyboard_engine_xkb.h
@@ -0,0 +1,56 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_INPUT_KEYBOARD_ENGINE_XKB_H_
+#define OZONE_WAYLAND_INPUT_KEYBOARD_ENGINE_XKB_H_
+
+#include <xkbcommon/xkbcommon.h>
+
+#include "base/basictypes.h"
+
+namespace ozonewayland {
+
+class KeyboardEngineXKB {
+ public:
+  KeyboardEngineXKB();
+  ~KeyboardEngineXKB();
+
+  void OnKeyboardKeymap(int fd, uint32_t size);
+  void OnKeyModifiers(uint32_t mods_depressed,
+                      uint32_t mods_latched,
+                      uint32_t mods_locked,
+                      uint32_t group);
+  unsigned ConvertKeyCodeFromEvdev(unsigned hardwarecode);
+  bool IgnoreKeyNotify(unsigned hardwarecode, bool pressed);
+
+  uint32_t GetKeyBoardModifiers() const { return keyboard_modifiers_; }
+
+ private:
+  void InitXKB();
+  void FiniXKB();
+  bool IsSpecialModifier(unsigned hardwarecode);
+  bool IsOnlyCapsLocked() const;
+  void NormalizeKey();
+
+  // Keeps track of the currently active keyboard modifiers. We keep this
+  // since we want to advertise keyboard modifiers with mouse events.
+  uint32_t keyboard_modifiers_;
+  uint32_t mods_depressed_;
+  uint32_t mods_latched_;
+  uint32_t mods_locked_;
+  uint32_t group_;
+  int last_key_;
+  xkb_keysym_t cached_sym_;
+
+  // keymap used to transform keyboard events.
+  struct xkb_keymap *keymap_;
+  struct xkb_state *state_;
+  struct xkb_context *context_;
+
+  DISALLOW_COPY_AND_ASSIGN(KeyboardEngineXKB);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_INPUT_KEYBOARD_ENGINE_XKB_H_
--- /dev/null
+++ b/ozone/wayland/input/pointer.cc
@@ -0,0 +1,178 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/input/pointer.h"
+
+#include <linux/input.h>
+
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/wayland/input/cursor.h"
+#include "ozone/wayland/input_device.h"
+#include "ozone/wayland/window.h"
+#include "ui/events/event.h"
+
+namespace ozonewayland {
+
+WaylandPointer::WaylandPointer()
+  : cursor_(NULL),
+    dispatcher_(NULL),
+    pointer_position_(0, 0) {
+}
+
+WaylandPointer::~WaylandPointer() {
+  delete cursor_;
+}
+
+void WaylandPointer::OnSeatCapabilities(wl_seat *seat, uint32_t caps) {
+  static const struct wl_pointer_listener kInputPointerListener = {
+    WaylandPointer::OnPointerEnter,
+    WaylandPointer::OnPointerLeave,
+    WaylandPointer::OnMotionNotify,
+    WaylandPointer::OnButtonNotify,
+    WaylandPointer::OnAxisNotify,
+  };
+
+  if (!cursor_)
+    cursor_ = new WaylandCursor(WaylandDisplay::GetInstance()->shm());
+
+  dispatcher_ = ui::EventFactoryOzoneWayland::GetInstance()->EventConverter();
+
+  if ((caps & WL_SEAT_CAPABILITY_POINTER) && !cursor_->GetInputPointer()) {
+    wl_pointer* input_pointer = wl_seat_get_pointer(seat);
+      cursor_->SetInputPointer(input_pointer);
+    wl_pointer_set_user_data(input_pointer, this);
+    wl_pointer_add_listener(input_pointer, &kInputPointerListener, this);
+  } else if (!(caps & WL_SEAT_CAPABILITY_POINTER)
+                && cursor_->GetInputPointer()) {
+    cursor_->SetInputPointer(NULL);
+  }
+}
+
+void WaylandPointer::OnMotionNotify(void* data,
+                                    wl_pointer* input_pointer,
+                                    uint32_t time,
+                                    wl_fixed_t sx_w,
+                                    wl_fixed_t sy_w) {
+  WaylandPointer* device = static_cast<WaylandPointer*>(data);
+  WaylandInputDevice* input = WaylandDisplay::GetInstance()->PrimaryInput();
+  float sx = wl_fixed_to_double(sx_w);
+  float sy = wl_fixed_to_double(sy_w);
+
+  device->pointer_position_.SetPoint(sx, sy);
+  if (input->GetGrabWindowHandle() &&
+        input->GetGrabWindowHandle() != input->GetFocusWindowHandle()) {
+      return;
+  }
+
+  device->dispatcher_->MotionNotify(sx, sy);
+}
+
+void WaylandPointer::OnButtonNotify(void* data,
+                                    wl_pointer* input_pointer,
+                                    uint32_t serial,
+                                    uint32_t time,
+                                    uint32_t button,
+                                    uint32_t state) {
+  WaylandPointer* device = static_cast<WaylandPointer*>(data);
+  WaylandDisplay::GetInstance()->SetSerial(serial);
+  WaylandInputDevice* input = WaylandDisplay::GetInstance()->PrimaryInput();
+  if (input->GetFocusWindowHandle() && input->GetGrabButton() == 0 &&
+        state == WL_POINTER_BUTTON_STATE_PRESSED)
+    input->SetGrabWindowHandle(input->GetFocusWindowHandle(), button);
+
+  if (input->GetGrabWindowHandle()) {
+    ui::EventType type = ui::ET_MOUSE_PRESSED;
+    if (state == WL_POINTER_BUTTON_STATE_RELEASED)
+      type = ui::ET_MOUSE_RELEASED;
+
+    // TODO(vignatti): simultaneous clicks fail
+    ui::EventFlags flags = ui::EF_NONE;
+    if (button == BTN_LEFT)
+      flags = ui::EF_LEFT_MOUSE_BUTTON;
+    else if (button == BTN_RIGHT)
+      flags = ui::EF_RIGHT_MOUSE_BUTTON;
+    else if (button == BTN_MIDDLE)
+      flags = ui::EF_MIDDLE_MOUSE_BUTTON;
+
+    device->dispatcher_->ButtonNotify(input->GetFocusWindowHandle(),
+                                      type,
+                                      flags,
+                                      device->pointer_position_.x(),
+                                      device->pointer_position_.y());
+  }
+
+  if (input->GetGrabWindowHandle() && input->GetGrabButton() == button &&
+        state == WL_POINTER_BUTTON_STATE_RELEASED)
+    input->SetGrabWindowHandle(0, 0);
+}
+
+void WaylandPointer::OnAxisNotify(void* data,
+                                  wl_pointer* input_pointer,
+                                  uint32_t time,
+                                  uint32_t axis,
+                                  int32_t value) {
+  int x_offset = 0, y_offset = 0;
+  WaylandPointer* device = static_cast<WaylandPointer*>(data);
+  const int delta = ui::MouseWheelEvent::kWheelDelta;
+
+  switch (axis) {
+    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+      x_offset = value > 0 ? -delta : delta;
+      break;
+    case WL_POINTER_AXIS_VERTICAL_SCROLL:
+      y_offset = value > 0 ? -delta : delta;
+      break;
+    default:
+      break;
+  }
+
+  device->dispatcher_->AxisNotify(device->pointer_position_.x(),
+                                  device->pointer_position_.y(),
+                                  x_offset,
+                                  y_offset);
+}
+
+void WaylandPointer::OnPointerEnter(void* data,
+                                    wl_pointer* input_pointer,
+                                    uint32_t serial,
+                                    wl_surface* surface,
+                                    wl_fixed_t sx_w,
+                                    wl_fixed_t sy_w) {
+  WaylandInputDevice* input = WaylandDisplay::GetInstance()->PrimaryInput();
+
+  if (!surface) {
+    input->SetFocusWindowHandle(0);
+    return;
+  }
+
+  WaylandPointer* device = static_cast<WaylandPointer*>(data);
+  WaylandWindow* window =
+      static_cast<WaylandWindow*>(wl_surface_get_user_data(surface));
+  unsigned handle = window->Handle();
+  float sx = wl_fixed_to_double(sx_w);
+  float sy = wl_fixed_to_double(sy_w);
+
+  WaylandDisplay::GetInstance()->SetSerial(serial);
+  device->pointer_position_.SetPoint(sx, sy);
+  input->SetFocusWindowHandle(handle);
+  device->dispatcher_->PointerEnter(handle,
+                                    device->pointer_position_.x(),
+                                    device->pointer_position_.y());
+}
+
+void WaylandPointer::OnPointerLeave(void* data,
+                                    wl_pointer* input_pointer,
+                                    uint32_t serial,
+                                    wl_surface* surface) {
+  WaylandPointer* device = static_cast<WaylandPointer*>(data);
+  WaylandDisplay::GetInstance()->SetSerial(serial);
+
+  WaylandInputDevice* input = WaylandDisplay::GetInstance()->PrimaryInput();
+  device->dispatcher_->PointerLeave(input->GetFocusWindowHandle(),
+                                    device->pointer_position_.x(),
+                                    device->pointer_position_.y());
+  input->SetFocusWindowHandle(0);
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/input/pointer.h
@@ -0,0 +1,77 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_INPUT_POINTER_H_
+#define OZONE_WAYLAND_INPUT_POINTER_H_
+
+#include "ozone/wayland/display.h"
+#include "ui/gfx/geometry/point.h"
+
+namespace ui {
+class EventConverterOzoneWayland;
+}
+
+namespace ozonewayland {
+
+class WaylandCursor;
+class WaylandWindow;
+
+class WaylandPointer {
+ public:
+  WaylandPointer();
+  ~WaylandPointer();
+
+  void OnSeatCapabilities(wl_seat *seat, uint32_t caps);
+  WaylandCursor* Cursor() const { return cursor_; }
+
+ private:
+  static void OnMotionNotify(
+      void* data,
+      wl_pointer* input_pointer,
+      uint32_t time,
+      wl_fixed_t sx_w,
+      wl_fixed_t sy_w);
+
+  static void OnButtonNotify(
+      void* data,
+      wl_pointer* input_pointer,
+      uint32_t serial,
+      uint32_t time,
+      uint32_t button,
+      uint32_t state);
+
+  static void OnAxisNotify(
+      void* data,
+      wl_pointer* input_pointer,
+      uint32_t time,
+      uint32_t axis,
+      int32_t value);
+
+  static void OnPointerEnter(
+      void* data,
+      wl_pointer* input_pointer,
+      uint32_t serial,
+      wl_surface* surface,
+      wl_fixed_t sx_w,
+      wl_fixed_t sy_w);
+
+  static void OnPointerLeave(
+      void* data,
+      wl_pointer* input_pointer,
+      uint32_t serial,
+      wl_surface* surface);
+
+  WaylandCursor* cursor_;
+  ui::EventConverterOzoneWayland* dispatcher_;
+  // Keeps track of the last position for the motion event. We want to
+  // dispatch this with events such as wheel or button which don't have a
+  // position associated on Wayland.
+  gfx::Point pointer_position_;
+
+  DISALLOW_COPY_AND_ASSIGN(WaylandPointer);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_INPUT_POINTER_H_
--- /dev/null
+++ b/ozone/wayland/input/text-client-protocol.h
@@ -0,0 +1,544 @@
+/*
+ * Copyright © 2012, 2013 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this
+ * software and its documentation for any purpose is hereby granted
+ * without fee, provided that the above copyright notice appear in
+ * all copies and that both that copyright notice and this permission
+ * notice appear in supporting documentation, and that the name of
+ * the copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+ * THIS SOFTWARE.
+ */
+
+#ifndef TEXT_CLIENT_PROTOCOL_H
+#define TEXT_CLIENT_PROTOCOL_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+struct wl_client;
+struct wl_resource;
+
+struct wl_text_input;
+struct wl_text_input_manager;
+
+extern const struct wl_interface wl_text_input_interface;
+extern const struct wl_interface wl_text_input_manager_interface;
+
+#ifndef WL_TEXT_INPUT_CONTENT_HINT_ENUM
+#define WL_TEXT_INPUT_CONTENT_HINT_ENUM
+/**
+ * wl_text_input_content_hint - content hint
+ * @WL_TEXT_INPUT_CONTENT_HINT_NONE: no special behaviour
+ * @WL_TEXT_INPUT_CONTENT_HINT_DEFAULT: auto completion, correction and
+ *	capitalization
+ * @WL_TEXT_INPUT_CONTENT_HINT_PASSWORD: hidden and sensitive text
+ * @WL_TEXT_INPUT_CONTENT_HINT_AUTO_COMPLETION: suggest word completions
+ * @WL_TEXT_INPUT_CONTENT_HINT_AUTO_CORRECTION: suggest word corrections
+ * @WL_TEXT_INPUT_CONTENT_HINT_AUTO_CAPITALIZATION: switch to uppercase
+ *	letters at the start of a sentence
+ * @WL_TEXT_INPUT_CONTENT_HINT_LOWERCASE: prefer lowercase letters
+ * @WL_TEXT_INPUT_CONTENT_HINT_UPPERCASE: prefer uppercase letters
+ * @WL_TEXT_INPUT_CONTENT_HINT_TITLECASE: prefer casing for titles and
+ *	headings (can be language dependent)
+ * @WL_TEXT_INPUT_CONTENT_HINT_HIDDEN_TEXT: characters should be hidden
+ * @WL_TEXT_INPUT_CONTENT_HINT_SENSITIVE_DATA: typed text should not be
+ *	stored
+ * @WL_TEXT_INPUT_CONTENT_HINT_LATIN: just latin characters should be
+ *	entered
+ * @WL_TEXT_INPUT_CONTENT_HINT_MULTILINE: the text input is multiline
+ *
+ * Content hint is a bitmask to allow to modify the behavior of the text
+ * input.
+ */
+enum wl_text_input_content_hint {
+	WL_TEXT_INPUT_CONTENT_HINT_NONE = 0x0,
+	WL_TEXT_INPUT_CONTENT_HINT_DEFAULT = 0x7,
+	WL_TEXT_INPUT_CONTENT_HINT_PASSWORD = 0xc0,
+	WL_TEXT_INPUT_CONTENT_HINT_AUTO_COMPLETION = 0x1,
+	WL_TEXT_INPUT_CONTENT_HINT_AUTO_CORRECTION = 0x2,
+	WL_TEXT_INPUT_CONTENT_HINT_AUTO_CAPITALIZATION = 0x4,
+	WL_TEXT_INPUT_CONTENT_HINT_LOWERCASE = 0x8,
+	WL_TEXT_INPUT_CONTENT_HINT_UPPERCASE = 0x10,
+	WL_TEXT_INPUT_CONTENT_HINT_TITLECASE = 0x20,
+	WL_TEXT_INPUT_CONTENT_HINT_HIDDEN_TEXT = 0x40,
+	WL_TEXT_INPUT_CONTENT_HINT_SENSITIVE_DATA = 0x80,
+	WL_TEXT_INPUT_CONTENT_HINT_LATIN = 0x100,
+	WL_TEXT_INPUT_CONTENT_HINT_MULTILINE = 0x200,
+};
+#endif /* WL_TEXT_INPUT_CONTENT_HINT_ENUM */
+
+#ifndef WL_TEXT_INPUT_CONTENT_PURPOSE_ENUM
+#define WL_TEXT_INPUT_CONTENT_PURPOSE_ENUM
+/**
+ * wl_text_input_content_purpose - content purpose
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_NORMAL: default input, allowing all
+ *	characters
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_ALPHA: allow only alphabetic characters
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_DIGITS: allow only digits
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_NUMBER: input a number (including
+ *	decimal separator and sign)
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_PHONE: input a phone number
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_URL: input an URL
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_EMAIL: input an email address
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_NAME: input a name of a person
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_PASSWORD: input a password (combine
+ *	with password or sensitive_data hint)
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_DATE: input a date
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_TIME: input a time
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_DATETIME: input a date and time
+ * @WL_TEXT_INPUT_CONTENT_PURPOSE_TERMINAL: input for a terminal
+ *
+ * The content purpose allows to specify the primary purpose of a text
+ * input.
+ *
+ * This allows an input method to show special purpose input panels with
+ * extra characters or to disallow some characters.
+ */
+enum wl_text_input_content_purpose {
+	WL_TEXT_INPUT_CONTENT_PURPOSE_NORMAL = 0,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_ALPHA = 1,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_DIGITS = 2,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_NUMBER = 3,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_PHONE = 4,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_URL = 5,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_EMAIL = 6,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_NAME = 7,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_PASSWORD = 8,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_DATE = 9,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_TIME = 10,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_DATETIME = 11,
+	WL_TEXT_INPUT_CONTENT_PURPOSE_TERMINAL = 12,
+};
+#endif /* WL_TEXT_INPUT_CONTENT_PURPOSE_ENUM */
+
+#ifndef WL_TEXT_INPUT_PREEDIT_STYLE_ENUM
+#define WL_TEXT_INPUT_PREEDIT_STYLE_ENUM
+enum wl_text_input_preedit_style {
+	WL_TEXT_INPUT_PREEDIT_STYLE_DEFAULT = 0,
+	WL_TEXT_INPUT_PREEDIT_STYLE_NONE = 1,
+	WL_TEXT_INPUT_PREEDIT_STYLE_ACTIVE = 2,
+	WL_TEXT_INPUT_PREEDIT_STYLE_INACTIVE = 3,
+	WL_TEXT_INPUT_PREEDIT_STYLE_HIGHLIGHT = 4,
+	WL_TEXT_INPUT_PREEDIT_STYLE_UNDERLINE = 5,
+	WL_TEXT_INPUT_PREEDIT_STYLE_SELECTION = 6,
+	WL_TEXT_INPUT_PREEDIT_STYLE_INCORRECT = 7,
+};
+#endif /* WL_TEXT_INPUT_PREEDIT_STYLE_ENUM */
+
+#ifndef WL_TEXT_INPUT_TEXT_DIRECTION_ENUM
+#define WL_TEXT_INPUT_TEXT_DIRECTION_ENUM
+enum wl_text_input_text_direction {
+	WL_TEXT_INPUT_TEXT_DIRECTION_AUTO = 0,
+	WL_TEXT_INPUT_TEXT_DIRECTION_LTR = 1,
+	WL_TEXT_INPUT_TEXT_DIRECTION_RTL = 2,
+};
+#endif /* WL_TEXT_INPUT_TEXT_DIRECTION_ENUM */
+
+/**
+ * wl_text_input - text input
+ * @enter: enter event
+ * @leave: leave event
+ * @modifiers_map: modifiers map
+ * @input_panel_state: state of the input panel
+ * @preedit_string: pre-edit
+ * @preedit_styling: pre-edit styling
+ * @preedit_cursor: pre-edit cursor
+ * @commit_string: commit
+ * @cursor_position: set cursor to new position
+ * @delete_surrounding_text: delete surrounding text
+ * @keysym: keysym
+ * @language: language
+ * @text_direction: text direction
+ *
+ * An object used for text input. Adds support for text input and input
+ * methods to applications. A text-input object is created from a
+ * wl_text_input_manager and corresponds typically to a text entry in an
+ * application. Requests are used to activate/deactivate the text-input
+ * object and set state information like surrounding and selected text or
+ * the content type. The information about entered text is sent to the
+ * text-input object via the pre-edit and commit events. Using this
+ * interface removes the need for applications to directly process hardware
+ * key events and compose text out of them.
+ *
+ * Text is generally UTF-8 encoded, indices and lengths are in Unicode
+ * characters.
+ *
+ * Serials are used to synchronize the state between the text input and an
+ * input method. New serials are sent by the text input in the commit_state
+ * request and are used by the input method to indicate the known text
+ * input state in events like preedit_string, commit_string, and keysym.
+ * The text input can then ignore events from the input method which are
+ * based on an outdated state (for example after a reset).
+ */
+struct wl_text_input_listener {
+	/**
+	 * enter - enter event
+	 * @surface: (none)
+	 *
+	 * Notify the text-input object when it received focus. Typically
+	 * in response to an activate request.
+	 */
+	void (*enter)(void *data,
+		      struct wl_text_input *wl_text_input,
+		      struct wl_surface *surface);
+	/**
+	 * leave - leave event
+	 *
+	 * Notify the text-input object when it lost focus. Either in
+	 * response to a deactivate request or when the assigned surface
+	 * lost focus or was destroyed.
+	 */
+	void (*leave)(void *data,
+		      struct wl_text_input *wl_text_input);
+	/**
+	 * modifiers_map - modifiers map
+	 * @map: (none)
+	 *
+	 * Transfer an array of 0-terminated modifiers names. The
+	 * position in the array is the index of the modifier as used in
+	 * the modifiers bitmask in the keysym event.
+	 */
+	void (*modifiers_map)(void *data,
+			      struct wl_text_input *wl_text_input,
+			      struct wl_array *map);
+	/**
+	 * input_panel_state - state of the input panel
+	 * @state: (none)
+	 *
+	 * Notify when the visibility state of the input panel changed.
+	 */
+	void (*input_panel_state)(void *data,
+				  struct wl_text_input *wl_text_input,
+				  uint32_t state);
+	/**
+	 * preedit_string - pre-edit
+	 * @serial: serial of the latest known text input state
+	 * @text: (none)
+	 * @commit: (none)
+	 *
+	 * Notify when a new composing text (pre-edit) should be set
+	 * around the current cursor position. Any previously set composing
+	 * text should be removed.
+	 *
+	 * The commit text can be used to replace the preedit text on reset
+	 * (for example on unfocus).
+	 *
+	 * The text input should also handle all preedit_style and
+	 * preedit_cursor events occuring directly before preedit_string.
+	 */
+	void (*preedit_string)(void *data,
+			       struct wl_text_input *wl_text_input,
+			       uint32_t serial,
+			       const char *text,
+			       const char *commit);
+	/**
+	 * preedit_styling - pre-edit styling
+	 * @index: (none)
+	 * @length: (none)
+	 * @style: (none)
+	 *
+	 * Sets styling information on composing text. The style is
+	 * applied for length Unicode characters from index relative to the
+	 * beginning of the composing text (as Unicode character offset).
+	 * Multiple styles can be applied to a composing text by sending
+	 * multiple preedit_styling events.
+	 *
+	 * This event is handled as part of a following preedit_string
+	 * event.
+	 */
+	void (*preedit_styling)(void *data,
+				struct wl_text_input *wl_text_input,
+				uint32_t index,
+				uint32_t length,
+				uint32_t style);
+	/**
+	 * preedit_cursor - pre-edit cursor
+	 * @index: (none)
+	 *
+	 * Sets the cursor position inside the composing text (as Unicode
+	 * character offset) relative to the start of the composing text.
+	 * When index is a negative number no cursor is shown.
+	 *
+	 * This event is handled as part of a following preedit_string
+	 * event.
+	 */
+	void (*preedit_cursor)(void *data,
+			       struct wl_text_input *wl_text_input,
+			       int32_t index);
+	/**
+	 * commit_string - commit
+	 * @serial: serial of the latest known text input state
+	 * @text: (none)
+	 *
+	 * Notify when text should be inserted into the editor widget.
+	 * The text to commit could be either just a single character after
+	 * a key press or the result of some composing (pre-edit). It could
+	 * be also an empty text when some text should be removed (see
+	 * delete_surrounding_text) or when the input cursor should be
+	 * moved (see cursor_position).
+	 *
+	 * Any previously set composing text should be removed.
+	 */
+	void (*commit_string)(void *data,
+			      struct wl_text_input *wl_text_input,
+			      uint32_t serial,
+			      const char *text);
+	/**
+	 * cursor_position - set cursor to new position
+	 * @index: (none)
+	 * @anchor: (none)
+	 *
+	 * Notify when the cursor or anchor position should be modified.
+	 *
+	 * This event should be handled as part of a following
+	 * commit_string event.
+	 */
+	void (*cursor_position)(void *data,
+				struct wl_text_input *wl_text_input,
+				int32_t index,
+				int32_t anchor);
+	/**
+	 * delete_surrounding_text - delete surrounding text
+	 * @index: (none)
+	 * @length: (none)
+	 *
+	 * Notify when the text around the current cursor position should
+	 * be deleted.
+	 *
+	 * Index is relative to the current cursor (in Unicode characters).
+	 * Length is the length of deleted text (in Unicode characters).
+	 *
+	 * This event should be handled as part of a following
+	 * commit_string event.
+	 */
+	void (*delete_surrounding_text)(void *data,
+					struct wl_text_input *wl_text_input,
+					int32_t index,
+					uint32_t length);
+	/**
+	 * keysym - keysym
+	 * @serial: serial of the latest known text input state
+	 * @time: (none)
+	 * @sym: (none)
+	 * @state: (none)
+	 * @modifiers: (none)
+	 *
+	 * Notify when a key event was sent. Key events should not be
+	 * used for normal text input operations, which should be done with
+	 * commit_string, delete_surrounding_text, etc. The key event
+	 * follows the wl_keyboard key event convention. Sym is a XKB
+	 * keysym, state a wl_keyboard key_state. Modifiers are a mask for
+	 * effective modifiers (where the modifier indices are set by the
+	 * modifiers_map event)
+	 */
+	void (*keysym)(void *data,
+		       struct wl_text_input *wl_text_input,
+		       uint32_t serial,
+		       uint32_t time,
+		       uint32_t sym,
+		       uint32_t state,
+		       uint32_t modifiers);
+	/**
+	 * language - language
+	 * @serial: serial of the latest known text input state
+	 * @language: (none)
+	 *
+	 * Sets the language of the input text. The "language" argument
+	 * is a RFC-3066 format language tag.
+	 */
+	void (*language)(void *data,
+			 struct wl_text_input *wl_text_input,
+			 uint32_t serial,
+			 const char *language);
+	/**
+	 * text_direction - text direction
+	 * @serial: serial of the latest known text input state
+	 * @direction: (none)
+	 *
+	 * Sets the text direction of input text.
+	 *
+	 * It is mainly needed for showing input cursor on correct side of
+	 * the editor when there is no input yet done and making sure
+	 * neutral direction text is laid out properly.
+	 */
+	void (*text_direction)(void *data,
+			       struct wl_text_input *wl_text_input,
+			       uint32_t serial,
+			       uint32_t direction);
+};
+
+static inline int
+wl_text_input_add_listener(struct wl_text_input *wl_text_input,
+			   const struct wl_text_input_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_text_input,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_TEXT_INPUT_ACTIVATE	0
+#define WL_TEXT_INPUT_DEACTIVATE	1
+#define WL_TEXT_INPUT_SHOW_INPUT_PANEL	2
+#define WL_TEXT_INPUT_HIDE_INPUT_PANEL	3
+#define WL_TEXT_INPUT_RESET	4
+#define WL_TEXT_INPUT_SET_SURROUNDING_TEXT	5
+#define WL_TEXT_INPUT_SET_CONTENT_TYPE	6
+#define WL_TEXT_INPUT_SET_CURSOR_RECTANGLE	7
+#define WL_TEXT_INPUT_SET_PREFERRED_LANGUAGE	8
+#define WL_TEXT_INPUT_COMMIT_STATE	9
+#define WL_TEXT_INPUT_INVOKE_ACTION	10
+
+static inline void
+wl_text_input_set_user_data(struct wl_text_input *wl_text_input, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_text_input, user_data);
+}
+
+static inline void *
+wl_text_input_get_user_data(struct wl_text_input *wl_text_input)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_text_input);
+}
+
+static inline void
+wl_text_input_destroy(struct wl_text_input *wl_text_input)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_text_input);
+}
+
+static inline void
+wl_text_input_activate(struct wl_text_input *wl_text_input, struct wl_seat *seat, struct wl_surface *surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input,
+			 WL_TEXT_INPUT_ACTIVATE, seat, surface);
+}
+
+static inline void
+wl_text_input_deactivate(struct wl_text_input *wl_text_input, struct wl_seat *seat)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input,
+			 WL_TEXT_INPUT_DEACTIVATE, seat);
+}
+
+static inline void
+wl_text_input_show_input_panel(struct wl_text_input *wl_text_input)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input,
+			 WL_TEXT_INPUT_SHOW_INPUT_PANEL);
+}
+
+static inline void
+wl_text_input_hide_input_panel(struct wl_text_input *wl_text_input)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input,
+			 WL_TEXT_INPUT_HIDE_INPUT_PANEL);
+}
+
+static inline void
+wl_text_input_reset(struct wl_text_input *wl_text_input)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input,
+			 WL_TEXT_INPUT_RESET);
+}
+
+static inline void
+wl_text_input_set_surrounding_text(struct wl_text_input *wl_text_input, const char *text, uint32_t cursor, uint32_t anchor)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input,
+			 WL_TEXT_INPUT_SET_SURROUNDING_TEXT, text, cursor, anchor);
+}
+
+static inline void
+wl_text_input_set_content_type(struct wl_text_input *wl_text_input, uint32_t hint, uint32_t purpose)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input,
+			 WL_TEXT_INPUT_SET_CONTENT_TYPE, hint, purpose);
+}
+
+static inline void
+wl_text_input_set_cursor_rectangle(struct wl_text_input *wl_text_input, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input,
+			 WL_TEXT_INPUT_SET_CURSOR_RECTANGLE, x, y, width, height);
+}
+
+static inline void
+wl_text_input_set_preferred_language(struct wl_text_input *wl_text_input, const char *language)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input,
+			 WL_TEXT_INPUT_SET_PREFERRED_LANGUAGE, language);
+}
+
+static inline void
+wl_text_input_commit_state(struct wl_text_input *wl_text_input, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input,
+			 WL_TEXT_INPUT_COMMIT_STATE, serial);
+}
+
+static inline void
+wl_text_input_invoke_action(struct wl_text_input *wl_text_input, uint32_t button, uint32_t index)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input,
+			 WL_TEXT_INPUT_INVOKE_ACTION, button, index);
+}
+
+#define WL_TEXT_INPUT_MANAGER_CREATE_TEXT_INPUT	0
+
+static inline void
+wl_text_input_manager_set_user_data(struct wl_text_input_manager *wl_text_input_manager, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_text_input_manager, user_data);
+}
+
+static inline void *
+wl_text_input_manager_get_user_data(struct wl_text_input_manager *wl_text_input_manager)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_text_input_manager);
+}
+
+static inline void
+wl_text_input_manager_destroy(struct wl_text_input_manager *wl_text_input_manager)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_text_input_manager);
+}
+
+static inline struct wl_text_input *
+wl_text_input_manager_create_text_input(struct wl_text_input_manager *wl_text_input_manager)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_create((struct wl_proxy *) wl_text_input_manager,
+			     &wl_text_input_interface);
+	if (!id)
+		return NULL;
+
+	wl_proxy_marshal((struct wl_proxy *) wl_text_input_manager,
+			 WL_TEXT_INPUT_MANAGER_CREATE_TEXT_INPUT, id);
+
+	return (struct wl_text_input *) id;
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/ozone/wayland/input/text-protocol.c
@@ -0,0 +1,93 @@
+/*
+ * Copyright © 2012, 2013 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this
+ * software and its documentation for any purpose is hereby granted
+ * without fee, provided that the above copyright notice appear in
+ * all copies and that both that copyright notice and this permission
+ * notice appear in supporting documentation, and that the name of
+ * the copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+ * THIS SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface wl_text_input_interface;
+
+static const struct wl_interface *types[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&wl_seat_interface,
+	&wl_surface_interface,
+	&wl_seat_interface,
+	&wl_surface_interface,
+	&wl_text_input_interface,
+};
+
+static const struct wl_message wl_text_input_requests[] = {
+	{ "activate", "oo", types + 5 },
+	{ "deactivate", "o", types + 7 },
+	{ "show_input_panel", "", types + 0 },
+	{ "hide_input_panel", "", types + 0 },
+	{ "reset", "", types + 0 },
+	{ "set_surrounding_text", "suu", types + 0 },
+	{ "set_content_type", "uu", types + 0 },
+	{ "set_cursor_rectangle", "iiii", types + 0 },
+	{ "set_preferred_language", "s", types + 0 },
+	{ "commit_state", "u", types + 0 },
+	{ "invoke_action", "uu", types + 0 },
+};
+
+static const struct wl_message wl_text_input_events[] = {
+	{ "enter", "o", types + 8 },
+	{ "leave", "", types + 0 },
+	{ "modifiers_map", "a", types + 0 },
+	{ "input_panel_state", "u", types + 0 },
+	{ "preedit_string", "uss", types + 0 },
+	{ "preedit_styling", "uuu", types + 0 },
+	{ "preedit_cursor", "i", types + 0 },
+	{ "commit_string", "us", types + 0 },
+	{ "cursor_position", "ii", types + 0 },
+	{ "delete_surrounding_text", "iu", types + 0 },
+	{ "keysym", "uuuuu", types + 0 },
+	{ "language", "us", types + 0 },
+	{ "text_direction", "uu", types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_text_input_interface = {
+	"wl_text_input", 1,
+	11, wl_text_input_requests,
+	13, wl_text_input_events,
+};
+
+static const struct wl_message wl_text_input_manager_requests[] = {
+	{ "create_text_input", "n", types + 9 },
+};
+
+WL_EXPORT const struct wl_interface wl_text_input_manager_interface = {
+	"wl_text_input_manager", 1,
+	1, wl_text_input_manager_requests,
+	0, NULL,
+};
--- /dev/null
+++ b/ozone/wayland/input/text_input.cc
@@ -0,0 +1,203 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/input/text_input.h"
+
+#include <string>
+
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/ui/events/keyboard_codes_ozone.h"
+#include "ozone/wayland/display.h"
+#include "ozone/wayland/input/keyboard.h"
+#include "ozone/wayland/input/keyboard_engine_xkb.h"
+#include "ozone/wayland/input_device.h"
+#include "ozone/wayland/shell/shell_surface.h"
+#include "ozone/wayland/window.h"
+
+namespace ozonewayland {
+
+WaylandTextInput::WaylandTextInput(WaylandInputDevice* inputDevice):
+  text_input_(NULL), active_window_(NULL), last_active_window_(NULL),
+  input_device_(inputDevice) {
+}
+
+WaylandTextInput::~WaylandTextInput() {
+  if (text_input_)
+    wl_text_input_destroy(text_input_);
+}
+
+void WaylandTextInput::SetActiveWindow(WaylandWindow* window) {
+  active_window_ = window;
+  if (active_window_)
+    last_active_window_ = active_window_;
+}
+
+void WaylandTextInput::OnCommitString(void* data,
+                                      struct wl_text_input* text_input,
+                                      uint32_t serial,
+                                      const char* text) {
+  ui::EventConverterOzoneWayland* dispatcher =
+        ui::EventFactoryOzoneWayland::GetInstance()->EventConverter();
+  DCHECK(static_cast<WaylandTextInput*>(data)->last_active_window_);
+  dispatcher->Commit(static_cast<WaylandTextInput*>(data)->
+      last_active_window_->Handle(), std::string(text));
+}
+
+void WaylandTextInput::OnPreeditString(void* data,
+                                       struct wl_text_input* text_input,
+                                       uint32_t serial,
+                                       const char* text,
+                                       const char* commit) {
+  ui::EventConverterOzoneWayland* dispatcher =
+         ui::EventFactoryOzoneWayland::GetInstance()->EventConverter();
+  DCHECK(static_cast<WaylandTextInput*>(data)->last_active_window_);
+  dispatcher->PreeditChanged(static_cast<WaylandTextInput*>(data)->
+     last_active_window_->Handle(), std::string(text), std::string(commit));
+}
+
+void WaylandTextInput::OnDeleteSurroundingText(void* data,
+                                       struct wl_text_input* text_input,
+                                       int32_t index,
+                                       uint32_t length) {
+}
+
+void WaylandTextInput::OnCursorPosition(void* data,
+                                       struct wl_text_input* text_input,
+                                       int32_t index,
+                                       int32_t anchor) {
+}
+
+void WaylandTextInput::OnPreeditStyling(void* data,
+                                       struct wl_text_input* text_input,
+                                       uint32_t index,
+                                       uint32_t length,
+                                       uint32_t style) {
+}
+
+void WaylandTextInput::OnPreeditCursor(void* data,
+                                       struct wl_text_input* text_input,
+                                       int32_t index) {
+}
+
+void WaylandTextInput::OnModifiersMap(void* data,
+                                      struct wl_text_input* text_input,
+                                      struct wl_array* map) {
+}
+
+void WaylandTextInput::OnKeysym(void* data,
+                                struct wl_text_input* text_input,
+                                uint32_t serial,
+                                uint32_t time,
+                                uint32_t key,
+                                uint32_t state,
+                                uint32_t modifiers) {
+  WaylandTextInput* textInuput = static_cast<WaylandTextInput*>(data);
+
+  // Copid from WaylandKeyboard::OnKeyNotify()
+  ui::EventType type = ui::ET_KEY_PRESSED;
+  WaylandDisplay::GetInstance()->SetSerial(serial);
+  if (state == WL_KEYBOARD_KEY_STATE_RELEASED)
+    type = ui::ET_KEY_RELEASED;
+
+  // Check if we can ignore the KeyEvent notification, saves an IPC call.
+  if (textInuput->getInputDevice()->GetKeyBoard()->GetBackend()->
+    IgnoreKeyNotify(key, type == ui::ET_KEY_PRESSED))
+    return;
+
+  ui::EventConverterOzoneWayland* dispatcher =
+          ui::EventFactoryOzoneWayland::GetInstance()->EventConverter();
+
+  switch (key) {
+    case XKB_KEY_KP_Enter:
+    case XKB_KEY_Return:
+    case XKB_KEY_ISO_Enter:
+      dispatcher->KeyNotify(type, ui::OZONEACTIONKEY_RETURN, modifiers);
+      break;
+    case XKB_KEY_BackSpace:  // FIXME: Back space is not handled.
+      dispatcher->KeyNotify(type, ui::OZONEACTIONKEY_BACK, modifiers);
+      break;
+    case XKB_KEY_Left:
+    case XKB_KEY_KP_Left:
+      dispatcher->KeyNotify(type, ui::OZONEACTIONKEY_LEFT, modifiers);
+      break;
+    case XKB_KEY_Right:
+    case XKB_KEY_KP_Right:
+      dispatcher->KeyNotify(type, ui::OZONEACTIONKEY_RIGHT, modifiers);
+      break;
+    default:
+      break;
+  }
+}
+
+void WaylandTextInput::OnEnter(void* data,
+                               struct wl_text_input* text_input,
+                               struct wl_surface* surface) {
+}
+
+void WaylandTextInput::OnLeave(void* data,
+                               struct wl_text_input* text_input) {
+}
+
+void WaylandTextInput::OnInputPanelState(void* data,
+                               struct wl_text_input* text_input,
+                               uint32_t state) {
+}
+
+void WaylandTextInput::OnLanguage(void* data,
+                               struct wl_text_input* text_input,
+                               uint32_t serial,
+                               const char* language) {
+}
+
+void WaylandTextInput::OnTextDirection(void* data,
+                               struct wl_text_input* text_input,
+                               uint32_t serial,
+                               uint32_t direction) {
+}
+
+void WaylandTextInput::ResetIme() {
+  static const struct wl_text_input_listener text_input_listener = {
+      WaylandTextInput::OnEnter,
+      WaylandTextInput::OnLeave,
+      WaylandTextInput::OnModifiersMap,
+      WaylandTextInput::OnInputPanelState,
+      WaylandTextInput::OnPreeditString,
+      WaylandTextInput::OnPreeditStyling,
+      WaylandTextInput::OnPreeditCursor,
+      WaylandTextInput::OnCommitString,
+      WaylandTextInput::OnCursorPosition,
+      WaylandTextInput::OnDeleteSurroundingText,
+      WaylandTextInput::OnKeysym,
+      WaylandTextInput::OnLanguage,
+      WaylandTextInput::OnTextDirection
+  };
+
+#if defined(ENABLE_OZONE_WAYLAND_VKB)
+  if (!text_input_) {
+    text_input_ = wl_text_input_manager_create_text_input(
+        WaylandDisplay::GetInstance()->GetTextInputManager());
+    wl_text_input_add_listener(text_input_, &text_input_listener, this);
+  }
+#endif
+}
+
+void WaylandTextInput::ShowInputPanel(wl_seat* input_seat) {
+#if defined(ENABLE_OZONE_WAYLAND_VKB)
+  if (text_input_ && active_window_) {
+    wl_text_input_show_input_panel(text_input_);
+    wl_text_input_activate(text_input_,
+                           input_seat,
+                           active_window_->ShellSurface()->GetWLSurface());
+  }
+#endif
+}
+
+void WaylandTextInput::HideInputPanel(wl_seat* input_seat) {
+#if defined(ENABLE_OZONE_WAYLAND_VKB)
+  if (text_input_)
+    wl_text_input_deactivate(text_input_, input_seat);
+#endif
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/input/text_input.h
@@ -0,0 +1,101 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_TEXT_INPUT_H_
+#define OZONE_WAYLAND_TEXT_INPUT_H_
+
+#include "ozone/wayland/display.h"
+#include "ozone/wayland/input/text-client-protocol.h"
+
+namespace ozonewayland {
+
+class WaylandWindow;
+class WaylandInputDevice;
+
+class WaylandTextInput {
+ public:
+  explicit WaylandTextInput(WaylandInputDevice* inputDevice);
+  ~WaylandTextInput();
+  void ResetIme();
+  void ShowInputPanel(wl_seat* input_seat);
+  void HideInputPanel(wl_seat* input_seat);
+  void SetActiveWindow(WaylandWindow* window);
+  WaylandInputDevice* getInputDevice() { return input_device_; }
+
+ private:
+  static void OnCommitString(void* data,
+                             struct wl_text_input* text_input,
+                             uint32_t serial,
+                             const char* text);
+
+  static void OnPreeditString(void* data,
+                             struct wl_text_input* text_input,
+                             uint32_t serial,
+                             const char* text,
+                             const char* commit);
+
+  static void OnDeleteSurroundingText(void* data,
+                             struct wl_text_input* text_input,
+                             int32_t index,
+                             uint32_t length);
+
+  static void OnCursorPosition(void* data,
+                             struct wl_text_input* text_input,
+                             int32_t index,
+                             int32_t anchor);
+
+  static void OnPreeditStyling(void* data,
+                             struct wl_text_input* text_input,
+                             uint32_t index,
+                             uint32_t length,
+                             uint32_t style);
+
+  static void OnPreeditCursor(void* data,
+                            struct wl_text_input* text_input,
+                            int32_t index);
+
+  static void OnModifiersMap(void* data,
+                            struct wl_text_input* text_input,
+                            struct wl_array* map);
+
+  static void OnKeysym(void* data,
+                       struct wl_text_input* text_input,
+                       uint32_t serial,
+                       uint32_t time,
+                       uint32_t key,
+                       uint32_t state,
+                       uint32_t modifiers);
+
+  static void OnEnter(void* data,
+                      struct wl_text_input* text_input,
+                      struct wl_surface* surface);
+
+  static void OnLeave(void* data,
+                      struct wl_text_input* text_input);
+
+  static void OnInputPanelState(void* data,
+                      struct wl_text_input* text_input,
+                      uint32_t state);
+
+  static void OnLanguage(void* data,
+                      struct wl_text_input* text_input,
+                      uint32_t serial,
+                      const char* language);
+
+  static void OnTextDirection(void* data,
+                      struct wl_text_input* text_input,
+                      uint32_t serial,
+                      uint32_t direction);
+
+  struct wl_text_input* text_input_;
+  WaylandWindow* active_window_;
+  WaylandWindow* last_active_window_;
+  WaylandInputDevice* input_device_;
+
+  DISALLOW_COPY_AND_ASSIGN(WaylandTextInput);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_TEXT_INPUT_H_
--- /dev/null
+++ b/ozone/wayland/input/touchscreen.cc
@@ -0,0 +1,123 @@
+// Copyright (c) 2014 Noser Engineering AG. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/input/touchscreen.h"
+
+#include <linux/input.h>
+
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/wayland/input/cursor.h"
+#include "ozone/wayland/input_device.h"
+#include "ozone/wayland/window.h"
+#include "ui/events/event.h"
+
+namespace ozonewayland {
+
+WaylandTouchscreen::WaylandTouchscreen()
+  : dispatcher_(NULL),
+    pointer_position_(0, 0) {
+}
+
+WaylandTouchscreen::~WaylandTouchscreen() {
+}
+
+void WaylandTouchscreen::OnSeatCapabilities(wl_seat *seat, uint32_t caps) {
+  static const struct wl_touch_listener kInputTouchListener = {
+    WaylandTouchscreen::OnTouchDown,
+    WaylandTouchscreen::OnTouchUp,
+    WaylandTouchscreen::OnTouchMotion,
+    WaylandTouchscreen::OnTouchFrame,
+    WaylandTouchscreen::OnTouchCancel,
+  };
+
+  dispatcher_ = ui::EventFactoryOzoneWayland::GetInstance()->EventConverter();
+
+  if ((caps & WL_SEAT_CAPABILITY_TOUCH)) {
+    wl_touch* input_touch = wl_seat_get_touch(seat);
+    wl_touch_set_user_data(input_touch, this);
+    wl_touch_add_listener(input_touch, &kInputTouchListener, this);
+  }
+}
+
+void WaylandTouchscreen::OnTouchDown(void *data,
+                                     struct wl_touch *wl_touch,
+                                     uint32_t serial,
+                                     uint32_t time,
+                                     struct wl_surface *surface,
+                                     int32_t id,
+                                     wl_fixed_t x,
+                                     wl_fixed_t y) {
+  WaylandTouchscreen* device = static_cast<WaylandTouchscreen*>(data);
+  WaylandDisplay::GetInstance()->SetSerial(serial);
+  WaylandInputDevice* input = WaylandDisplay::GetInstance()->PrimaryInput();
+  if (input->GetFocusWindowHandle() && input->GetGrabButton() == 0)
+    input->SetGrabWindowHandle(input->GetFocusWindowHandle(), id);
+
+  float sx = wl_fixed_to_double(x);
+  float sy = wl_fixed_to_double(y);
+
+  device->pointer_position_.SetPoint(sx, sy);
+
+  device->dispatcher_->TouchNotify(ui::ET_TOUCH_PRESSED, sx, sy, id, time);
+}
+
+void WaylandTouchscreen::OnTouchUp(void *data,
+                                   struct wl_touch *wl_touch,
+                                   uint32_t serial,
+                                   uint32_t time,
+                                   int32_t id) {
+  WaylandTouchscreen* device = static_cast<WaylandTouchscreen*>(data);
+  WaylandDisplay::GetInstance()->SetSerial(serial);
+  WaylandInputDevice* input = WaylandDisplay::GetInstance()->PrimaryInput();
+
+  device->dispatcher_->TouchNotify(ui::ET_TOUCH_RELEASED,
+                                   device->pointer_position_.x(),
+                                   device->pointer_position_.y(), id, time);
+
+  if (input->GetGrabWindowHandle() && input->GetGrabButton() == id)
+    input->SetGrabWindowHandle(0, 0);
+}
+
+void WaylandTouchscreen::OnTouchMotion(void *data,
+                                      struct wl_touch *wl_touch,
+                                      uint32_t time,
+                                      int32_t id,
+                                      wl_fixed_t x,
+                                      wl_fixed_t y) {
+  WaylandTouchscreen* device = static_cast<WaylandTouchscreen*>(data);
+  WaylandInputDevice* input = WaylandDisplay::GetInstance()->PrimaryInput();
+  float sx = wl_fixed_to_double(x);
+  float sy = wl_fixed_to_double(y);
+
+  device->pointer_position_.SetPoint(sx, sy);
+
+  if (input->GetGrabWindowHandle() &&
+    input->GetGrabWindowHandle() != input->GetFocusWindowHandle()) {
+    return;
+  }
+
+  device->dispatcher_->TouchNotify(ui::ET_TOUCH_MOVED, sx, sy, id, time);
+}
+
+void WaylandTouchscreen::OnTouchFrame(void *data,
+                                      struct wl_touch *wl_touch) {
+  // TODO(speedpat): find out what should be done here
+}
+
+void WaylandTouchscreen::OnTouchCancel(void *data,
+                                       struct wl_touch *wl_touch) {
+  WaylandTouchscreen* device = static_cast<WaylandTouchscreen*>(data);
+  WaylandInputDevice* input = WaylandDisplay::GetInstance()->PrimaryInput();
+
+  device->dispatcher_->TouchNotify(ui::ET_TOUCH_CANCELLED,
+                                   device->pointer_position_.x(),
+                                   device->pointer_position_.y(),
+                                   input->GetGrabButton(),
+                                   0);
+
+  if (input->GetGrabWindowHandle() && input->GetGrabButton() != 0)
+    input->SetGrabWindowHandle(0, 0);
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/input/touchscreen.h
@@ -0,0 +1,68 @@
+// Copyright (c) 2014 Noser Engineering AG. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_INPUT_TOUCHSCREEN_H_
+#define OZONE_WAYLAND_INPUT_TOUCHSCREEN_H_
+
+#include "ozone/wayland/display.h"
+#include "ui/gfx/geometry/point.h"
+
+namespace ui {
+class EventConverterOzoneWayland;
+}
+
+namespace ozonewayland {
+
+class WaylandWindow;
+
+class WaylandTouchscreen {
+ public:
+  WaylandTouchscreen();
+  ~WaylandTouchscreen();
+
+  void OnSeatCapabilities(wl_seat *seat, uint32_t caps);
+
+ private:
+  static void OnTouchDown(
+      void *data,
+      struct wl_touch *wl_touch,
+      uint32_t serial,
+      uint32_t time,
+      struct wl_surface *surface,
+      int32_t id,
+      wl_fixed_t x,
+      wl_fixed_t y);
+
+  static void OnTouchUp(
+      void *data,
+      struct wl_touch *wl_touch,
+      uint32_t serial,
+      uint32_t time,
+      int32_t id);
+
+  static void OnTouchMotion(
+      void *data,
+      struct wl_touch *wl_touch,
+      uint32_t time,
+      int32_t id,
+      wl_fixed_t x,
+      wl_fixed_t y);
+
+  static void OnTouchFrame(
+      void *data,
+      struct wl_touch *wl_touch);
+
+  static void OnTouchCancel(
+      void *data,
+      struct wl_touch *wl_touch);
+
+  ui::EventConverterOzoneWayland* dispatcher_;
+  gfx::Point pointer_position_;
+
+  DISALLOW_COPY_AND_ASSIGN(WaylandTouchscreen);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_INPUT_POINTER_H_
--- /dev/null
+++ b/ozone/wayland/input_device.cc
@@ -0,0 +1,240 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/input_device.h"
+
+#include "base/logging.h"
+#include "ozone/wayland/display.h"
+#include "ozone/wayland/input/cursor.h"
+#include "ozone/wayland/input/keyboard.h"
+#include "ozone/wayland/input/pointer.h"
+#include "ozone/wayland/input/text_input.h"
+#include "ozone/wayland/input/touchscreen.h"
+
+namespace ozonewayland {
+
+const int kCursorNull = 0;
+const int kCursorPointer = 1;
+const int kCursorCross = 2;
+const int kCursorHand = 3;
+const int kCursorIBeam = 4;
+const int kCursorWait = 5;
+const int kCursorHelp = 6;
+const int kCursorEastResize = 7;
+const int kCursorNorthResize = 8;
+const int kCursorNorthEastResize = 9;
+const int kCursorNorthWestResize = 10;
+const int kCursorSouthResize = 11;
+const int kCursorSouthEastResize = 12;
+const int kCursorSouthWestResize = 13;
+const int kCursorWestResize = 14;
+const int kCursorNorthSouthResize = 15;
+const int kCursorEastWestResize = 16;
+const int kCursorNorthEastSouthWestResize = 17;
+const int kCursorNorthWestSouthEastResize = 18;
+const int kCursorColumnResize = 19;
+const int kCursorRowResize = 20;
+const int kCursorMiddlePanning = 21;
+const int kCursorEastPanning = 22;
+const int kCursorNorthPanning = 23;
+const int kCursorNorthEastPanning = 24;
+const int kCursorNorthWestPanning = 25;
+const int kCursorSouthPanning = 26;
+const int kCursorSouthEastPanning = 27;
+const int kCursorSouthWestPanning = 28;
+const int kCursorWestPanning = 29;
+const int kCursorMove = 30;
+const int kCursorVerticalText = 31;
+const int kCursorCell = 32;
+const int kCursorContextMenu = 33;
+const int kCursorAlias = 34;
+const int kCursorProgress = 35;
+const int kCursorNoDrop = 36;
+const int kCursorCopy = 37;
+const int kCursorNone = 38;
+const int kCursorNotAllowed = 39;
+const int kCursorZoomIn = 40;
+const int kCursorZoomOut = 41;
+const int kCursorGrab = 42;
+const int kCursorGrabbing = 43;
+const int kCursorCustom = 44;
+
+// Returns Wayland font cursor shape from an Aura cursor.
+WaylandCursor::CursorType CursorShapeFromNative(unsigned cursor_type) {
+  switch (cursor_type) {
+    case kCursorMiddlePanning:
+    case kCursorMove:
+      return WaylandCursor::CURSOR_FLEUR;
+    case kCursorEastPanning:
+      return WaylandCursor::CURSOR_RIGHT;
+    case kCursorNorthPanning:
+      return WaylandCursor::CURSOR_UP_ARROW;
+    case kCursorNorthEastPanning:
+      return WaylandCursor::CURSOR_TOP_RIGHT;
+    case kCursorNorthWestPanning:
+      return WaylandCursor::CURSOR_TOP_LEFT;
+    case kCursorSouthPanning:
+      return WaylandCursor::CURSOR_BOTTOM;
+    case kCursorSouthEastPanning:
+    case kCursorSouthEastResize:
+      return WaylandCursor::CURSOR_BOTTOM_RIGHT;
+    case kCursorSouthWestPanning:
+    case kCursorSouthWestResize:
+      return WaylandCursor::CURSOR_BOTTOM_LEFT;
+    case kCursorWestPanning:
+      return WaylandCursor::CURSOR_LEFT_ARROW;
+    case kCursorNone:
+    case kCursorNull:
+    case kCursorPointer:
+    // TODO(kalyan): Choose right cursor types.
+    case kCursorGrab:
+    case kCursorGrabbing:
+      return WaylandCursor::CURSOR_LEFT_PTR;
+    case kCursorCross:
+      return WaylandCursor::CURSOR_CROSS;
+    case kCursorHand:
+      return WaylandCursor::CURSOR_HAND1;
+    case kCursorIBeam:
+      return WaylandCursor::CURSOR_IBEAM;
+    case kCursorProgress:
+      return WaylandCursor::CURSOR_WATCH;
+    case kCursorWait:
+      return WaylandCursor::CURSOR_WAIT;
+    case kCursorHelp:
+      return WaylandCursor::CURSOR_QUESTION_ARROW;
+    case kCursorEastResize:
+      return WaylandCursor::CURSOR_RIGHT;
+    case kCursorNorthResize:
+      return WaylandCursor::CURSOR_TOP;
+    case kCursorNorthEastResize:
+      return WaylandCursor::CURSOR_TOP_RIGHT;
+    case kCursorNorthWestResize:
+      return WaylandCursor::CURSOR_TOP_LEFT_ARROW;
+    case kCursorSouthResize:
+      return WaylandCursor::CURSOR_BOTTOM;
+    case kCursorWestResize:
+      return WaylandCursor::CURSOR_LEFT;
+    case kCursorNorthSouthResize:
+    case kCursorRowResize:
+      return WaylandCursor::CURSOR_V_DOUBLE_ARROW;
+    case kCursorEastWestResize:
+    case kCursorColumnResize:
+      return WaylandCursor::CURSOR_H_DOUBLE_ARROW;
+    case kCursorCustom:
+      NOTREACHED();
+      return WaylandCursor::CURSOR_DEFAULT;
+  }
+  NOTREACHED() << "Case not handled for " << cursor_type;
+  return WaylandCursor::CURSOR_LEFT_PTR;
+}
+
+WaylandInputDevice::WaylandInputDevice(WaylandDisplay* display,
+                                       uint32_t id)
+    : focused_window_handle_(0),
+      grab_window_handle_(0),
+      grab_button_(0),
+      input_seat_(NULL),
+      input_keyboard_(NULL),
+      input_pointer_(NULL),
+      input_touch_(NULL),
+      text_input_(NULL) {
+  ui::IMEStateChangeHandler::SetInstance(this);
+  static const struct wl_seat_listener kInputSeatListener = {
+    WaylandInputDevice::OnSeatCapabilities,
+  };
+
+  input_seat_ = static_cast<wl_seat*>(
+      wl_registry_bind(display->registry(), id, &wl_seat_interface, 1));
+  DCHECK(input_seat_);
+  wl_seat_add_listener(input_seat_, &kInputSeatListener, this);
+  wl_seat_set_user_data(input_seat_, this);
+  text_input_ = new WaylandTextInput(this);
+}
+
+WaylandInputDevice::~WaylandInputDevice() {
+  delete input_keyboard_;
+  delete input_pointer_;
+  delete text_input_;
+  if (input_touch_ != NULL) {
+    delete input_touch_;
+  }
+  wl_seat_destroy(input_seat_);
+}
+
+void WaylandInputDevice::OnSeatCapabilities(void *data,
+                                            wl_seat *seat,
+                                            uint32_t caps) {
+  WaylandInputDevice* device = static_cast<WaylandInputDevice*>(data);
+  if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !device->input_keyboard_) {
+    device->input_keyboard_ = new WaylandKeyboard();
+  } else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && device->input_keyboard_) {
+    delete device->input_keyboard_;
+    device->input_keyboard_ = NULL;
+  }
+
+  if ((caps & WL_SEAT_CAPABILITY_POINTER) && !device->input_pointer_) {
+    device->input_pointer_ = new WaylandPointer();
+  } else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && device->input_pointer_) {
+    delete device->input_pointer_;
+    device->input_pointer_ = NULL;
+  }
+
+  if ((caps & WL_SEAT_CAPABILITY_TOUCH) && !device->input_touch_) {
+    device->input_touch_ = new WaylandTouchscreen();
+  } else if (!(caps & WL_SEAT_CAPABILITY_TOUCH) && device->input_touch_) {
+    delete device->input_touch_;
+    device->input_touch_ = NULL;
+  }
+
+  if (device->input_keyboard_)
+    device->input_keyboard_->OnSeatCapabilities(seat, caps);
+
+  if (device->input_pointer_)
+    device->input_pointer_->OnSeatCapabilities(seat, caps);
+
+  if (device->input_touch_)
+    device->input_touch_->OnSeatCapabilities(seat, caps);
+}
+
+void WaylandInputDevice::SetFocusWindowHandle(unsigned windowhandle) {
+  focused_window_handle_ = windowhandle;
+  WaylandWindow* window = NULL;
+  if (windowhandle)
+    window = WaylandDisplay::GetInstance()->GetWindow(windowhandle);
+  text_input_->SetActiveWindow(window);
+}
+
+void WaylandInputDevice::SetGrabWindowHandle(unsigned windowhandle,
+                                             uint32_t button) {
+  grab_window_handle_ = windowhandle;
+  grab_button_ = button;
+}
+
+void WaylandInputDevice::SetCursorType(int cursor_type) {
+  if (!input_pointer_) {
+    LOG(WARNING) << "Tried to change cursor without input configured";
+    return;
+  }
+  input_pointer_->Cursor()->Update(CursorShapeFromNative(cursor_type),
+                                   WaylandDisplay::GetInstance()->GetSerial());
+}
+
+void WaylandInputDevice::ResetIme() {
+  text_input_->ResetIme();
+}
+
+void WaylandInputDevice::ImeCaretBoundsChanged(gfx::Rect rect) {
+  NOTIMPLEMENTED();
+}
+
+void WaylandInputDevice::ShowInputPanel() {
+  text_input_->ShowInputPanel(input_seat_);
+}
+
+void WaylandInputDevice::HideInputPanel() {
+  text_input_->HideInputPanel(input_seat_);
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/input_device.h
@@ -0,0 +1,60 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_INPUT_DEVICE_H_
+#define OZONE_WAYLAND_INPUT_DEVICE_H_
+
+#include <wayland-client.h>
+#include "base/basictypes.h"
+#include "ozone/ui/events/ime_state_change_handler.h"
+
+namespace ozonewayland {
+
+class WaylandKeyboard;
+class WaylandPointer;
+class WaylandDisplay;
+class WaylandTouchscreen;
+class WaylandTextInput;
+
+class WaylandInputDevice : public ui::IMEStateChangeHandler {
+ public:
+  WaylandInputDevice(WaylandDisplay* display, uint32_t id);
+  virtual ~WaylandInputDevice();
+
+  wl_seat* GetInputSeat() const { return input_seat_; }
+  WaylandKeyboard* GetKeyBoard() const { return input_keyboard_; }
+  WaylandPointer* GetPointer() const { return input_pointer_; }
+  unsigned GetFocusWindowHandle() const { return focused_window_handle_; }
+  unsigned GetGrabWindowHandle() const { return grab_window_handle_; }
+  uint32_t GetGrabButton() const { return grab_button_; }
+  void SetFocusWindowHandle(unsigned windowhandle);
+  void SetGrabWindowHandle(unsigned windowhandle, uint32_t button);
+  void SetCursorType(int cursor_type);
+
+  virtual void ResetIme() override;
+  virtual void ImeCaretBoundsChanged(gfx::Rect rect) override;
+  virtual void ShowInputPanel() override;
+  virtual void HideInputPanel() override;
+
+ private:
+  static void OnSeatCapabilities(void *data,
+                                 wl_seat *seat,
+                                 uint32_t caps);
+
+  // Keeps track of current focused window.
+  unsigned focused_window_handle_;
+  unsigned grab_window_handle_;
+  uint32_t grab_button_;
+  wl_seat* input_seat_;
+  WaylandKeyboard* input_keyboard_;
+  WaylandPointer* input_pointer_;
+  WaylandTouchscreen* input_touch_;
+  WaylandTextInput* text_input_;
+
+  DISALLOW_COPY_AND_ASSIGN(WaylandInputDevice);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_INPUT_DEVICE_H_
--- /dev/null
+++ b/ozone/wayland/proxy_display.cc
@@ -0,0 +1,87 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/proxy_display.h"
+
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/ui/events/output_change_observer.h"
+#include "ozone/wayland/screen.h"
+
+namespace ozonewayland {
+
+WaylandProxyDisplay::WaylandProxyDisplay(): screen_(NULL) {
+  gfx::OzoneDisplay::SetInstance(this);
+}
+
+WaylandProxyDisplay::~WaylandProxyDisplay() {
+}
+
+// TODO(vignatti): GPU process conceptually is the one that deals with hardware
+// details and therefore we assume that the window system connection should
+// happen in there only. There's a glitch with Chrome though, that creates its
+// frame contents requiring access to the window system, before the GPU process
+// even exists. In other words, Chrome runs
+// BrowserMainLoop::PreMainMessageLoopRun before GpuProcessHost::Get. If the
+// assumption of window system connection belongs to the GPU process is valid,
+// then I believe this Chrome behavior needs to be addressed upstream.
+//
+// For now, we create another window system connection to look ahead the needed
+// output properties that Chrome (among others) need and then close right after
+// that. I haven't measured how long it takes to open a Wayland connection,
+// listen all the interface the compositor sends and close it, but _for_ _sure_
+// it slows down the overall initialization time of Chromium targets.
+// Therefore, this is something that has to be solved in the future, moving all
+// Chrome tasks after GPU process is created.
+//
+void WaylandProxyDisplay::LookAheadOutputGeometry() {
+  wl_display* display = wl_display_connect(NULL);
+  if (!display)
+    return;
+
+  static const struct wl_registry_listener registry_output = {
+    WaylandProxyDisplay::DisplayHandleOutputOnly
+  };
+
+  wl_registry* registry = wl_display_get_registry(display);
+  wl_registry_add_listener(registry, &registry_output, this);
+
+  if (wl_display_roundtrip(display) > 0) {
+    while (screen_->Geometry().IsEmpty())
+      wl_display_roundtrip(display);
+
+    ui::EventFactoryOzoneWayland* event_factory =
+        ui::EventFactoryOzoneWayland::GetInstance();
+    DCHECK(event_factory->GetOutputChangeObserver());
+
+    unsigned width = screen_->Geometry().width();
+    unsigned height = screen_->Geometry().height();
+    event_factory->GetOutputChangeObserver()->OnOutputSizeChanged(width,
+                                                                  height);
+  }
+
+  if (screen_) {
+    delete screen_;
+    screen_ = NULL;
+  }
+
+  wl_registry_destroy(registry);
+  wl_display_flush(display);
+  wl_display_disconnect(display);
+}
+
+// static
+void WaylandProxyDisplay::DisplayHandleOutputOnly(void *data,
+                                             struct wl_registry *registry,
+                                             uint32_t name,
+                                             const char *interface,
+                                             uint32_t version) {
+  WaylandProxyDisplay* disp = static_cast<WaylandProxyDisplay*>(data);
+
+  if (strcmp(interface, "wl_output") == 0) {
+    WaylandScreen* screen = new WaylandScreen(registry, name);
+    disp->screen_ = screen;
+  }
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/proxy_display.h
@@ -0,0 +1,45 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_PROXY_DISPLAY_H_
+#define OZONE_WAYLAND_PROXY_DISPLAY_H_
+
+#if !defined(__STDC_FORMAT_MACROS)
+#define __STDC_FORMAT_MACROS
+#endif
+
+#include <wayland-client.h>
+#include "ozone/ui/gfx/ozone_display.h"
+
+namespace ozonewayland {
+
+class WaylandScreen;
+// WaylandProxyDisplay is a wrapper around wl_display. Once we get a valid
+// wl_display, the Wayland server will send different events to register
+// the Wayland compositor, shell, screens, input devices, ...
+class WaylandProxyDisplay : public gfx::OzoneDisplay {
+ public:
+  explicit WaylandProxyDisplay();
+  virtual ~WaylandProxyDisplay();
+
+  virtual void LookAheadOutputGeometry() override;
+
+ private:
+  // This handler resolves only screen registration. In general you don't want
+  // to use this but the one below.
+  static void DisplayHandleOutputOnly(
+      void *data,
+      struct wl_registry *registry,
+      uint32_t name,
+      const char *interface,
+      uint32_t version);
+
+  // WaylandProxyDisplay manages the memory of all these pointers.
+  WaylandScreen* screen_;
+  DISALLOW_COPY_AND_ASSIGN(WaylandProxyDisplay);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_PROXY_DISPLAY_H_
--- /dev/null
+++ b/ozone/wayland/screen.cc
@@ -0,0 +1,70 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/screen.h"
+
+#include <wayland-client.h>
+
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/wayland/display.h"
+
+namespace ozonewayland {
+
+WaylandScreen::WaylandScreen(wl_registry* registry, uint32_t id)
+    : output_(NULL),
+      refresh_(0),
+      rect_(0, 0, 0, 0) {
+  static const wl_output_listener kOutputListener = {
+    WaylandScreen::OutputHandleGeometry,
+    WaylandScreen::OutputHandleMode,
+  };
+
+  output_ = static_cast<wl_output*>(
+      wl_registry_bind(registry, id, &wl_output_interface, 1));
+  wl_output_add_listener(output_, &kOutputListener, this);
+  DCHECK(output_);
+}
+
+WaylandScreen::~WaylandScreen() {
+  wl_output_destroy(output_);
+}
+
+// static
+void WaylandScreen::OutputHandleGeometry(void *data,
+                                         wl_output *output,
+                                         int32_t x,
+                                         int32_t y,
+                                         int32_t physical_width,
+                                         int32_t physical_height,
+                                         int32_t subpixel,
+                                         const char* make,
+                                         const char* model,
+                                         int32_t output_transform) {
+  WaylandScreen* screen = static_cast<WaylandScreen*>(data);
+  screen->rect_.set_origin(gfx::Point(x, y));
+}
+
+// static
+void WaylandScreen::OutputHandleMode(void* data,
+                                     wl_output* wl_output,
+                                     uint32_t flags,
+                                     int32_t width,
+                                     int32_t height,
+                                     int32_t refresh) {
+  WaylandScreen* screen = static_cast<WaylandScreen*>(data);
+  if (flags & WL_OUTPUT_MODE_CURRENT) {
+    screen->rect_.set_width(width);
+    screen->rect_.set_height(height);
+    screen->refresh_ = refresh;
+
+    if (!WaylandDisplay::GetInstance())
+      return;
+
+    //ui::EventFactoryOzoneWayland::GetInstance()->EventConverter()->
+    //    OutputSizeChanged(width, height);
+  }
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/screen.h
@@ -0,0 +1,65 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_SCREEN_H_
+#define OZONE_WAYLAND_SCREEN_H_
+
+#include <stdint.h>
+
+#include "base/basictypes.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
+
+struct wl_output;
+struct wl_registry;
+
+namespace ozonewayland {
+
+class WaylandDisplay;
+
+// WaylandScreen objects keep track of the current outputs (screens/monitors)
+// that are available to the application.
+class WaylandScreen {
+ public:
+  WaylandScreen(wl_registry* registry, uint32_t id);
+  ~WaylandScreen();
+
+  // Returns the active allocation of the screen.
+  gfx::Rect Geometry() const { return rect_; }
+
+ private:
+  // Callback functions that allows the display to initialize the screen's
+  // position and available modes.
+  static void OutputHandleGeometry(void* data,
+                                   wl_output* output,
+                                   int32_t x,
+                                   int32_t y,
+                                   int32_t physical_width,
+                                   int32_t physical_height,
+                                   int32_t subpixel,
+                                   const char* make,
+                                   const char* model,
+                                   int32_t output_transform);
+
+  static void OutputHandleMode(void* data,
+                               wl_output* wl_output,
+                               uint32_t flags,
+                               int32_t width,
+                               int32_t height,
+                               int32_t refresh);
+
+  // The Wayland output this object wraps
+  wl_output* output_;
+
+  // Rect and Refresh rate of active mode.
+  int32_t refresh_;
+  gfx::Rect rect_;
+
+  DISALLOW_COPY_AND_ASSIGN(WaylandScreen);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_SCREEN_H_
--- /dev/null
+++ b/ozone/wayland/shell/OWNERS
@@ -0,0 +1,2 @@
+kalyan.kondapally@intel.com
+tiago.vignatti@intel.com
--- /dev/null
+++ b/ozone/wayland/shell/shell.cc
@@ -0,0 +1,69 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/shell/shell.h"
+
+#include "base/logging.h"
+#include "ozone/wayland/display.h"
+#include "ozone/wayland/shell/wl_shell_surface.h"
+#if defined(ENABLE_XDG_SHELL)
+#include "ozone/wayland/shell/xdg-shell-client-protocol.h"
+#include "ozone/wayland/shell/xdg_shell_surface.h"
+#endif
+
+namespace ozonewayland {
+
+WaylandShell::WaylandShell()
+    : shell_(NULL),
+      xdg_shell_(NULL) {
+}
+
+WaylandShell::~WaylandShell() {
+  if (shell_)
+    wl_shell_destroy(shell_);
+#if defined(ENABLE_XDG_SHELL)
+  if (xdg_shell_)
+    xdg_shell_destroy(xdg_shell_);
+#endif
+}
+
+WaylandShellSurface* WaylandShell::CreateShellSurface(WaylandWindow* window) {
+  DCHECK(shell_ || xdg_shell_);
+  WaylandDisplay* display = WaylandDisplay::GetInstance();
+  DCHECK(display);
+  WaylandShellSurface* surface = NULL;
+#if defined(ENABLE_XDG_SHELL)
+  if (xdg_shell_)
+    surface = new XDGShellSurface();
+#endif
+  if (!surface)
+    surface = new WLShellSurface();
+
+  DCHECK(surface);
+  surface->InitializeShellSurface(window);
+  wl_surface_set_user_data(surface->GetWLSurface(), window);
+  display->FlushDisplay();
+
+  return surface;
+}
+
+void WaylandShell::Initialize(struct wl_registry *registry,
+                              uint32_t name,
+                              const char *interface,
+                              uint32_t version) {
+  if (strcmp(interface, "wl_shell") == 0) {
+    DCHECK(!shell_);
+    shell_ = static_cast<wl_shell*>(
+        wl_registry_bind(registry, name, &wl_shell_interface, 1));
+#if defined(ENABLE_XDG_SHELL)
+  } else if (strcmp(interface, "xdg_shell") == 0) {
+      DCHECK(!xdg_shell_);
+      xdg_shell_ = static_cast<xdg_shell*>(
+          wl_registry_bind(registry, name, &xdg_shell_interface, 1));
+      xdg_shell_use_unstable_version(xdg_shell_, XDG_SHELL_VERSION_CURRENT);
+#endif
+  }
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/shell/shell.h
@@ -0,0 +1,42 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_SHELL_SHELL_H_
+#define OZONE_WAYLAND_SHELL_SHELL_H_
+
+#include <wayland-client.h>
+
+#include "base/basictypes.h"
+
+struct xdg_shell;
+namespace ozonewayland {
+
+class WaylandShellSurface;
+class WaylandWindow;
+
+class WaylandShell {
+ public:
+  WaylandShell();
+  ~WaylandShell();
+  // Creates shell surface for a given WaylandWindow. This can be either
+  // wl_shell, xdg_shell or any shell which supports wayland protocol.
+  // Ownership is passed to the caller.
+  WaylandShellSurface* CreateShellSurface(WaylandWindow* parent);
+  void Initialize(struct wl_registry *registry,
+                  uint32_t name,
+                  const char *interface,
+                  uint32_t version);
+
+  wl_shell* GetWLShell() const { return shell_; }
+  xdg_shell* GetXDGShell() const { return xdg_shell_; }
+
+ private:
+  wl_shell* shell_;
+  xdg_shell* xdg_shell_;
+  DISALLOW_COPY_AND_ASSIGN(WaylandShell);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_SHELL_H_
--- /dev/null
+++ b/ozone/wayland/shell/shell_surface.cc
@@ -0,0 +1,55 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/shell/shell_surface.h"
+
+#include "ozone/ui/events/event_factory_ozone_wayland.h"
+#include "ozone/wayland/display.h"
+#include "ozone/wayland/input_device.h"
+
+namespace ozonewayland {
+
+WaylandShellSurface::WaylandShellSurface()
+    : surface_(NULL) {
+  WaylandDisplay* display = WaylandDisplay::GetInstance();
+  surface_ = wl_compositor_create_surface(display->GetCompositor());
+}
+
+WaylandShellSurface::~WaylandShellSurface() {
+  DCHECK(surface_);
+  wl_surface_destroy(surface_);
+  FlushDisplay();
+}
+
+struct wl_surface* WaylandShellSurface::GetWLSurface() const {
+    return surface_;
+}
+
+void WaylandShellSurface::FlushDisplay() const {
+  WaylandDisplay* display = WaylandDisplay::GetInstance();
+  DCHECK(display);
+  display->FlushDisplay();
+}
+
+void WaylandShellSurface::PopupDone() {
+  WaylandInputDevice* input = WaylandDisplay::GetInstance()->PrimaryInput();
+  ui::EventConverterOzoneWayland* dispatcher =
+      ui::EventFactoryOzoneWayland::GetInstance()->EventConverter();
+
+  if (!input->GetGrabWindowHandle())
+    return;
+  dispatcher->CloseWidget(input->GetGrabWindowHandle());
+  input->SetGrabWindowHandle(0, 0);
+}
+
+void WaylandShellSurface::WindowResized(void* data,
+                                 unsigned width,
+                                 unsigned height) {
+  WaylandWindow *window = static_cast<WaylandWindow*>(data);
+  ui::EventConverterOzoneWayland* dispatcher =
+      ui::EventFactoryOzoneWayland::GetInstance()->EventConverter();
+  dispatcher->WindowResized(window->Handle(), width, height);
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/shell/shell_surface.h
@@ -0,0 +1,49 @@
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_SHELL_SHELL_SURFACE_H_
+#define OZONE_WAYLAND_SHELL_SHELL_SURFACE_H_
+
+#include <wayland-client.h>
+
+#include "base/basictypes.h"
+#include "ozone/wayland/window.h"
+
+namespace ozonewayland {
+
+class WaylandWindow;
+
+class WaylandShellSurface {
+ public:
+  WaylandShellSurface();
+  virtual ~WaylandShellSurface();
+
+  struct wl_surface* GetWLSurface() const;
+
+  // The implementation should initialize the shell and set up all
+  // necessary callbacks.
+  virtual void InitializeShellSurface(WaylandWindow* window) = 0;
+  virtual void UpdateShellSurface(WaylandWindow::ShellType type,
+                                  WaylandShellSurface* shell_parent,
+                                  unsigned x,
+                                  unsigned y) = 0;
+  virtual void SetWindowTitle(const base::string16& title) = 0;
+  virtual void Maximize() = 0;
+  virtual void Minimize() = 0;
+
+  // static functions.
+  static void PopupDone();
+  static void WindowResized(void *data, unsigned width, unsigned height);
+
+ protected:
+  void FlushDisplay() const;
+
+ private:
+  struct wl_surface* surface_;
+  DISALLOW_COPY_AND_ASSIGN(WaylandShellSurface);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_SHELL_SHELL_SURFACE_H_
--- /dev/null
+++ b/ozone/wayland/shell/wl_shell_surface.cc
@@ -0,0 +1,116 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/shell/wl_shell_surface.h"
+
+#include "base/logging.h"
+#include "base/strings/utf_string_conversions.h"
+
+#include "ozone/wayland/display.h"
+#include "ozone/wayland/input_device.h"
+#include "ozone/wayland/shell/shell.h"
+
+namespace ozonewayland {
+
+WLShellSurface::WLShellSurface()
+    : WaylandShellSurface(),
+      shell_surface_(NULL) {
+}
+
+WLShellSurface::~WLShellSurface() {
+  wl_shell_surface_destroy(shell_surface_);
+}
+
+void WLShellSurface::InitializeShellSurface(WaylandWindow* window) {
+  DCHECK(!shell_surface_);
+  WaylandDisplay* display = WaylandDisplay::GetInstance();
+  DCHECK(display);
+  WaylandShell* shell = WaylandDisplay::GetInstance()->GetShell();
+  DCHECK(shell && shell->GetWLShell());
+  shell_surface_ = wl_shell_get_shell_surface(shell->GetWLShell(),
+                                              GetWLSurface());
+
+  static const wl_shell_surface_listener shell_surface_listener = {
+    WLShellSurface::HandlePing,
+    WLShellSurface::HandleConfigure,
+    WLShellSurface::HandlePopupDone
+  };
+
+  wl_shell_surface_add_listener(shell_surface_,
+                                &shell_surface_listener,
+                                window);
+
+  DCHECK(shell_surface_);
+}
+
+void WLShellSurface::UpdateShellSurface(WaylandWindow::ShellType type,
+                                        WaylandShellSurface* shell_parent,
+                                        unsigned x,
+                                        unsigned y) {
+  switch (type) {
+  case WaylandWindow::TOPLEVEL:
+    wl_shell_surface_set_toplevel(shell_surface_);
+    break;
+  case WaylandWindow::POPUP: {
+    WaylandDisplay* display = WaylandDisplay::GetInstance();
+    WaylandInputDevice* input_device = display->PrimaryInput();
+    wl_surface* parent_surface = shell_parent->GetWLSurface();
+    wl_shell_surface_set_popup(shell_surface_,
+                               input_device->GetInputSeat(),
+                               display->GetSerial(),
+                               parent_surface,
+                               x,
+                               y,
+                               0);
+    break;
+  }
+  case WaylandWindow::FULLSCREEN:
+    wl_shell_surface_set_fullscreen(shell_surface_,
+                                    WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT,
+                                    0,
+                                    NULL);
+    break;
+  case WaylandWindow::CUSTOM:
+      NOTREACHED() << "Unsupported shell type: " << type;
+    break;
+    default:
+      break;
+  }
+
+  WaylandShellSurface::FlushDisplay();
+}
+
+void WLShellSurface::SetWindowTitle(const base::string16& title) {
+  wl_shell_surface_set_title(shell_surface_, UTF16ToUTF8(title).c_str());
+  WaylandShellSurface::FlushDisplay();
+}
+
+void WLShellSurface::Maximize() {
+  wl_shell_surface_set_maximized(shell_surface_, NULL);
+  WaylandShellSurface::FlushDisplay();
+}
+
+void WLShellSurface::Minimize() {
+}
+
+void WLShellSurface::HandleConfigure(void* data,
+                                     struct wl_shell_surface* surface,
+                                     uint32_t edges,
+                                     int32_t width,
+                                     int32_t height) {
+  WaylandShellSurface::WindowResized(data, width, height);
+}
+
+void WLShellSurface::HandlePopupDone(void* data,
+                                     struct wl_shell_surface* surface) {
+  WaylandShellSurface::PopupDone();
+}
+
+void WLShellSurface::HandlePing(void* data,
+                                struct wl_shell_surface* shell_surface,
+                                uint32_t serial) {
+  wl_shell_surface_pong(shell_surface, serial);
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/shell/wl_shell_surface.h
@@ -0,0 +1,47 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_SHELL_WL_SHELL_SURFACE_H_
+#define OZONE_WAYLAND_SHELL_WL_SHELL_SURFACE_H_
+
+#include "ozone/wayland/shell/shell_surface.h"
+
+namespace ozonewayland {
+
+class WaylandSurface;
+class WaylandWindow;
+
+class WLShellSurface : public WaylandShellSurface {
+ public:
+  WLShellSurface();
+  virtual ~WLShellSurface();
+
+  virtual void InitializeShellSurface(WaylandWindow* window) override;
+  virtual void UpdateShellSurface(WaylandWindow::ShellType type,
+                                  WaylandShellSurface* shell_parent,
+                                  unsigned x,
+                                  unsigned y) override;
+  virtual void SetWindowTitle(const base::string16& title) override;
+  virtual void Maximize() override;
+  virtual void Minimize() override;
+
+  static void HandleConfigure(void* data,
+                              struct wl_shell_surface* shell_surface,
+                              uint32_t edges,
+                              int32_t width,
+                              int32_t height);
+  static void HandlePopupDone(void* data,
+                              struct wl_shell_surface* shell_surface);
+  static void HandlePing(void* data,
+                         struct wl_shell_surface* shell_surface,
+                         uint32_t serial);
+
+ private:
+  wl_shell_surface* shell_surface_;
+  DISALLOW_COPY_AND_ASSIGN(WLShellSurface);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_SHELL_WL_SHELL_SURFACE_H_
--- /dev/null
+++ b/ozone/wayland/shell/xdg-shell-client-protocol.h
@@ -0,0 +1,512 @@
+/*
+ * Copyright © 2008-2013 Kristian Høgsberg
+ * Copyright © 2013      Rafael Antognolli
+ * Copyright © 2013      Jasper St. Pierre
+ * Copyright © 2010-2013 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this
+ * software and its documentation for any purpose is hereby granted
+ * without fee, provided that the above copyright notice appear in
+ * all copies and that both that copyright notice and this permission
+ * notice appear in supporting documentation, and that the name of
+ * the copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+ * THIS SOFTWARE.
+ */
+
+#ifndef XDG_SHELL_CLIENT_PROTOCOL_H
+#define XDG_SHELL_CLIENT_PROTOCOL_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+struct wl_client;
+struct wl_resource;
+
+struct xdg_shell;
+struct xdg_surface;
+struct xdg_popup;
+
+extern const struct wl_interface xdg_shell_interface;
+extern const struct wl_interface xdg_surface_interface;
+extern const struct wl_interface xdg_popup_interface;
+
+#ifndef XDG_SHELL_VERSION_ENUM
+#define XDG_SHELL_VERSION_ENUM
+/**
+ * xdg_shell_version - latest protocol version
+ * @XDG_SHELL_VERSION_CURRENT: Always the latest version
+ *
+ * Use this enum to check the protocol version, and it will be updated
+ * automatically.
+ */
+enum xdg_shell_version {
+	XDG_SHELL_VERSION_CURRENT = 1,
+};
+#endif /* XDG_SHELL_VERSION_ENUM */
+
+#define XDG_SHELL_USE_UNSTABLE_VERSION	0
+#define XDG_SHELL_GET_XDG_SURFACE	1
+#define XDG_SHELL_GET_XDG_POPUP	2
+
+static inline void
+xdg_shell_set_user_data(struct xdg_shell *xdg_shell, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_shell, user_data);
+}
+
+static inline void *
+xdg_shell_get_user_data(struct xdg_shell *xdg_shell)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_shell);
+}
+
+static inline void
+xdg_shell_destroy(struct xdg_shell *xdg_shell)
+{
+	wl_proxy_destroy((struct wl_proxy *) xdg_shell);
+}
+
+static inline void
+xdg_shell_use_unstable_version(struct xdg_shell *xdg_shell, int32_t version)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_shell,
+			 XDG_SHELL_USE_UNSTABLE_VERSION, version);
+}
+
+static inline struct xdg_surface *
+xdg_shell_get_xdg_surface(struct xdg_shell *xdg_shell, struct wl_surface *surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) xdg_shell,
+			 XDG_SHELL_GET_XDG_SURFACE, &xdg_surface_interface, NULL, surface);
+
+	return (struct xdg_surface *) id;
+}
+
+static inline struct xdg_popup *
+xdg_shell_get_xdg_popup(struct xdg_shell *xdg_shell, struct wl_surface *surface, struct wl_surface *parent, struct wl_seat *seat, uint32_t serial, int32_t x, int32_t y, uint32_t flags)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) xdg_shell,
+			 XDG_SHELL_GET_XDG_POPUP, &xdg_popup_interface, NULL, surface, parent, seat, serial, x, y, flags);
+
+	return (struct xdg_popup *) id;
+}
+
+#ifndef XDG_SURFACE_RESIZE_EDGE_ENUM
+#define XDG_SURFACE_RESIZE_EDGE_ENUM
+/**
+ * xdg_surface_resize_edge - edge values for resizing
+ * @XDG_SURFACE_RESIZE_EDGE_NONE: (none)
+ * @XDG_SURFACE_RESIZE_EDGE_TOP: (none)
+ * @XDG_SURFACE_RESIZE_EDGE_BOTTOM: (none)
+ * @XDG_SURFACE_RESIZE_EDGE_LEFT: (none)
+ * @XDG_SURFACE_RESIZE_EDGE_TOP_LEFT: (none)
+ * @XDG_SURFACE_RESIZE_EDGE_BOTTOM_LEFT: (none)
+ * @XDG_SURFACE_RESIZE_EDGE_RIGHT: (none)
+ * @XDG_SURFACE_RESIZE_EDGE_TOP_RIGHT: (none)
+ * @XDG_SURFACE_RESIZE_EDGE_BOTTOM_RIGHT: (none)
+ *
+ * These values are used to indicate which edge of a surface is being
+ * dragged in a resize operation. The server may use this information to
+ * adapt its behavior, e.g. choose an appropriate cursor image.
+ */
+enum xdg_surface_resize_edge {
+	XDG_SURFACE_RESIZE_EDGE_NONE = 0,
+	XDG_SURFACE_RESIZE_EDGE_TOP = 1,
+	XDG_SURFACE_RESIZE_EDGE_BOTTOM = 2,
+	XDG_SURFACE_RESIZE_EDGE_LEFT = 4,
+	XDG_SURFACE_RESIZE_EDGE_TOP_LEFT = 5,
+	XDG_SURFACE_RESIZE_EDGE_BOTTOM_LEFT = 6,
+	XDG_SURFACE_RESIZE_EDGE_RIGHT = 8,
+	XDG_SURFACE_RESIZE_EDGE_TOP_RIGHT = 9,
+	XDG_SURFACE_RESIZE_EDGE_BOTTOM_RIGHT = 10,
+};
+#endif /* XDG_SURFACE_RESIZE_EDGE_ENUM */
+
+/**
+ * xdg_surface - desktop-style metadata interface
+ * @ping: ping client
+ * @configure: suggest resize
+ * @request_set_fullscreen: server requests that the client set
+ *	fullscreen
+ * @request_unset_fullscreen: server requests that the client unset
+ *	fullscreen
+ * @request_set_maximized: server requests that the client set maximized
+ * @request_unset_maximized: server requests that the client unset
+ *	maximized
+ * @request_set_minimized: server requests that the client set minimized
+ * @request_unset_minimized: server requests that the client unset
+ *	maximized
+ * @focused_set: surface was focused
+ * @focused_unset: surface was unfocused
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides requests to treat surfaces like windows, allowing to set
+ * properties like maximized, fullscreen, minimized, and to move and resize
+ * them, and associate metadata like title and app id.
+ *
+ * On the server side the object is automatically destroyed when the
+ * related wl_surface is destroyed. On client side, xdg_surface.destroy()
+ * must be called before destroying the wl_surface object.
+ */
+struct xdg_surface_listener {
+	/**
+	 * ping - ping client
+	 * @serial: (none)
+	 *
+	 * Ping a client to check if it is receiving events and sending
+	 * requests. A client is expected to reply with a pong request.
+	 */
+	void (*ping)(void *data,
+		     struct xdg_surface *xdg_surface,
+		     uint32_t serial);
+	/**
+	 * configure - suggest resize
+	 * @edges: (none)
+	 * @width: (none)
+	 * @height: (none)
+	 *
+	 * The configure event asks the client to resize its surface.
+	 *
+	 * The size is a hint, in the sense that the client is free to
+	 * ignore it if it doesn't resize, pick a smaller size (to satisfy
+	 * aspect ratio or resize in steps of NxM pixels).
+	 *
+	 * The edges parameter provides a hint about how the surface was
+	 * resized. The client may use this information to decide how to
+	 * adjust its content to the new size (e.g. a scrolling area might
+	 * adjust its content position to leave the viewable content
+	 * unmoved). Valid edge values are from resize_edge enum.
+	 *
+	 * The client is free to dismiss all but the last configure event
+	 * it received.
+	 *
+	 * The width and height arguments specify the size of the window in
+	 * surface local coordinates.
+	 */
+	void (*configure)(void *data,
+			  struct xdg_surface *xdg_surface,
+			  uint32_t edges,
+			  int32_t width,
+			  int32_t height);
+	/**
+	 * request_set_fullscreen - server requests that the client set
+	 *	fullscreen
+	 *
+	 * Event sent from the compositor to the client requesting that
+	 * the client goes to a fullscreen state. It's the client job to
+	 * call set_fullscreen and really trigger the fullscreen state.
+	 */
+	void (*request_set_fullscreen)(void *data,
+				       struct xdg_surface *xdg_surface);
+	/**
+	 * request_unset_fullscreen - server requests that the client
+	 *	unset fullscreen
+	 *
+	 * Event sent from the compositor to the client requesting that
+	 * the client leaves the fullscreen state. It's the client job to
+	 * call unset_fullscreen and really leave the fullscreen state.
+	 */
+	void (*request_unset_fullscreen)(void *data,
+					 struct xdg_surface *xdg_surface);
+	/**
+	 * request_set_maximized - server requests that the client set
+	 *	maximized
+	 *
+	 * Event sent from the compositor to the client requesting that
+	 * the client goes to a maximized state. It's the client job to
+	 * call set_maximized and really trigger the maximized state.
+	 */
+	void (*request_set_maximized)(void *data,
+				      struct xdg_surface *xdg_surface);
+	/**
+	 * request_unset_maximized - server requests that the client
+	 *	unset maximized
+	 *
+	 * Event sent from the compositor to the client requesting that
+	 * the client leaves the maximized state. It's the client job to
+	 * call unset_maximized and really leave the maximized state.
+	 */
+	void (*request_unset_maximized)(void *data,
+					struct xdg_surface *xdg_surface);
+	/**
+	 * request_set_minimized - server requests that the client set
+	 *	minimized
+	 *
+	 * Event sent from the compositor to the client requesting that
+	 * the client goes to a minimized state. It's the client job to
+	 * call set_minimized and trigger its minimized state.
+	 */
+	void (*request_set_minimized)(void *data,
+				      struct xdg_surface *xdg_surface);
+	/**
+	 * request_unset_minimized - server requests that the client
+	 *	unset maximized
+	 *
+	 * Event sent from the compositor to the client requesting that
+	 * the client leaves the minimized state. It's the client job to
+	 * call unset_maximized and leave its minimized state.
+	 */
+	void (*request_unset_minimized)(void *data,
+					struct xdg_surface *xdg_surface);
+	/**
+	 * focused_set - surface was focused
+	 *
+	 * The focused_set event is sent when this surface has been
+	 * activated. Window decorations should be updated accordingly.
+	 */
+	void (*focused_set)(void *data,
+			    struct xdg_surface *xdg_surface);
+	/**
+	 * focused_unset - surface was unfocused
+	 *
+	 * The focused_unset event is sent when this surface has been
+	 * deactivated, because another surface has been activated. Window
+	 * decorations should be updated accordingly.
+	 */
+	void (*focused_unset)(void *data,
+			      struct xdg_surface *xdg_surface);
+};
+
+static inline int
+xdg_surface_add_listener(struct xdg_surface *xdg_surface,
+			 const struct xdg_surface_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) xdg_surface,
+				     (void (**)(void)) listener, data);
+}
+
+#define XDG_SURFACE_DESTROY	0
+#define XDG_SURFACE_SET_TRANSIENT_FOR	1
+#define XDG_SURFACE_SET_TITLE	2
+#define XDG_SURFACE_SET_APP_ID	3
+#define XDG_SURFACE_PONG	4
+#define XDG_SURFACE_MOVE	5
+#define XDG_SURFACE_RESIZE	6
+#define XDG_SURFACE_SET_OUTPUT	7
+#define XDG_SURFACE_SET_FULLSCREEN	8
+#define XDG_SURFACE_UNSET_FULLSCREEN	9
+#define XDG_SURFACE_SET_MAXIMIZED	10
+#define XDG_SURFACE_UNSET_MAXIMIZED	11
+#define XDG_SURFACE_SET_MINIMIZED	12
+
+static inline void
+xdg_surface_set_user_data(struct xdg_surface *xdg_surface, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_surface, user_data);
+}
+
+static inline void *
+xdg_surface_get_user_data(struct xdg_surface *xdg_surface)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_surface);
+}
+
+static inline void
+xdg_surface_destroy(struct xdg_surface *xdg_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) xdg_surface);
+}
+
+static inline void
+xdg_surface_set_transient_for(struct xdg_surface *xdg_surface, struct wl_surface *parent)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_SET_TRANSIENT_FOR, parent);
+}
+
+static inline void
+xdg_surface_set_title(struct xdg_surface *xdg_surface, const char *title)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_SET_TITLE, title);
+}
+
+static inline void
+xdg_surface_set_app_id(struct xdg_surface *xdg_surface, const char *app_id)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_SET_APP_ID, app_id);
+}
+
+static inline void
+xdg_surface_pong(struct xdg_surface *xdg_surface, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_PONG, serial);
+}
+
+static inline void
+xdg_surface_move(struct xdg_surface *xdg_surface, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_MOVE, seat, serial);
+}
+
+static inline void
+xdg_surface_resize(struct xdg_surface *xdg_surface, struct wl_seat *seat, uint32_t serial, uint32_t edges)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_RESIZE, seat, serial, edges);
+}
+
+static inline void
+xdg_surface_set_output(struct xdg_surface *xdg_surface, struct wl_output *output)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_SET_OUTPUT, output);
+}
+
+static inline void
+xdg_surface_set_fullscreen(struct xdg_surface *xdg_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_SET_FULLSCREEN);
+}
+
+static inline void
+xdg_surface_unset_fullscreen(struct xdg_surface *xdg_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_UNSET_FULLSCREEN);
+}
+
+static inline void
+xdg_surface_set_maximized(struct xdg_surface *xdg_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_SET_MAXIMIZED);
+}
+
+static inline void
+xdg_surface_unset_maximized(struct xdg_surface *xdg_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_UNSET_MAXIMIZED);
+}
+
+static inline void
+xdg_surface_set_minimized(struct xdg_surface *xdg_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_SET_MINIMIZED);
+}
+
+/**
+ * xdg_popup - desktop-style metadata interface
+ * @ping: ping client
+ * @popup_done: popup interaction is done
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style popups/menus. A popup
+ * surface is a transient surface with an added pointer grab.
+ *
+ * An existing implicit grab will be changed to owner-events mode, and the
+ * popup grab will continue after the implicit grab ends (i.e. releasing
+ * the mouse button does not cause the popup to be unmapped).
+ *
+ * The popup grab continues until the window is destroyed or a mouse button
+ * is pressed in any other clients window. A click in any of the clients
+ * surfaces is reported as normal, however, clicks in other clients
+ * surfaces will be discarded and trigger the callback.
+ *
+ * The x and y arguments specify the locations of the upper left corner of
+ * the surface relative to the upper left corner of the parent surface, in
+ * surface local coordinates.
+ *
+ * xdg_popup surfaces are always transient for another surface.
+ */
+struct xdg_popup_listener {
+	/**
+	 * ping - ping client
+	 * @serial: (none)
+	 *
+	 * Ping a client to check if it is receiving events and sending
+	 * requests. A client is expected to reply with a pong request.
+	 */
+	void (*ping)(void *data,
+		     struct xdg_popup *xdg_popup,
+		     uint32_t serial);
+	/**
+	 * popup_done - popup interaction is done
+	 * @serial: serial of the implicit grab on the pointer
+	 *
+	 * The popup_done event is sent out when a popup grab is broken,
+	 * that is, when the users clicks a surface that doesn't belong to
+	 * the client owning the popup surface.
+	 */
+	void (*popup_done)(void *data,
+			   struct xdg_popup *xdg_popup,
+			   uint32_t serial);
+};
+
+static inline int
+xdg_popup_add_listener(struct xdg_popup *xdg_popup,
+		       const struct xdg_popup_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) xdg_popup,
+				     (void (**)(void)) listener, data);
+}
+
+#define XDG_POPUP_DESTROY	0
+#define XDG_POPUP_PONG	1
+
+static inline void
+xdg_popup_set_user_data(struct xdg_popup *xdg_popup, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_popup, user_data);
+}
+
+static inline void *
+xdg_popup_get_user_data(struct xdg_popup *xdg_popup)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_popup);
+}
+
+static inline void
+xdg_popup_destroy(struct xdg_popup *xdg_popup)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_popup,
+			 XDG_POPUP_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) xdg_popup);
+}
+
+static inline void
+xdg_popup_pong(struct xdg_popup *xdg_popup, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_popup,
+			 XDG_POPUP_PONG, serial);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
--- /dev/null
+++ b/ozone/wayland/shell/xdg-shell-protocol.c
@@ -0,0 +1,128 @@
+/*
+ * Copyright © 2008-2013 Kristian Høgsberg
+ * Copyright © 2013      Rafael Antognolli
+ * Copyright © 2013      Jasper St. Pierre
+ * Copyright © 2010-2013 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this
+ * software and its documentation for any purpose is hereby granted
+ * without fee, provided that the above copyright notice appear in
+ * all copies and that both that copyright notice and this permission
+ * notice appear in supporting documentation, and that the name of
+ * the copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+ * THIS SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface xdg_surface_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface xdg_popup_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_output_interface;
+
+static const struct wl_interface *types[] = {
+	NULL,
+	NULL,
+	NULL,
+	&xdg_surface_interface,
+	&wl_surface_interface,
+	&xdg_popup_interface,
+	&wl_surface_interface,
+	&wl_surface_interface,
+	&wl_seat_interface,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&wl_surface_interface,
+	&wl_seat_interface,
+	NULL,
+	&wl_seat_interface,
+	NULL,
+	NULL,
+	&wl_output_interface,
+};
+
+static const struct wl_message xdg_shell_requests[] = {
+	{ "use_unstable_version", "i", types + 0 },
+	{ "get_xdg_surface", "no", types + 3 },
+	{ "get_xdg_popup", "nooouiiu", types + 5 },
+};
+
+WL_EXPORT const struct wl_interface xdg_shell_interface = {
+	"xdg_shell", 1,
+	3, xdg_shell_requests,
+	0, NULL,
+};
+
+static const struct wl_message xdg_surface_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "set_transient_for", "?o", types + 13 },
+	{ "set_title", "s", types + 0 },
+	{ "set_app_id", "s", types + 0 },
+	{ "pong", "u", types + 0 },
+	{ "move", "ou", types + 14 },
+	{ "resize", "ouu", types + 16 },
+	{ "set_output", "?o", types + 19 },
+	{ "set_fullscreen", "", types + 0 },
+	{ "unset_fullscreen", "", types + 0 },
+	{ "set_maximized", "", types + 0 },
+	{ "unset_maximized", "", types + 0 },
+	{ "set_minimized", "", types + 0 },
+};
+
+static const struct wl_message xdg_surface_events[] = {
+	{ "ping", "u", types + 0 },
+	{ "configure", "uii", types + 0 },
+	{ "request_set_fullscreen", "", types + 0 },
+	{ "request_unset_fullscreen", "", types + 0 },
+	{ "request_set_maximized", "", types + 0 },
+	{ "request_unset_maximized", "", types + 0 },
+	{ "request_set_minimized", "", types + 0 },
+	{ "request_unset_minimized", "", types + 0 },
+	{ "focused_set", "", types + 0 },
+	{ "focused_unset", "", types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_surface_interface = {
+	"xdg_surface", 1,
+	13, xdg_surface_requests,
+	10, xdg_surface_events,
+};
+
+static const struct wl_message xdg_popup_requests[] = {
+	{ "destroy", "", types + 0 },
+	{ "pong", "u", types + 0 },
+};
+
+static const struct wl_message xdg_popup_events[] = {
+	{ "ping", "u", types + 0 },
+	{ "popup_done", "u", types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_popup_interface = {
+	"xdg_popup", 1,
+	2, xdg_popup_requests,
+	2, xdg_popup_events,
+};
--- /dev/null
+++ b/ozone/wayland/shell/xdg_shell_surface.cc
@@ -0,0 +1,141 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/shell/xdg_shell_surface.h"
+
+#include "base/logging.h"
+#include "base/strings/utf_string_conversions.h"
+
+#include "ozone/wayland/display.h"
+#include "ozone/wayland/input_device.h"
+#include "ozone/wayland/shell/shell.h"
+#include "ozone/wayland/shell/xdg-shell-client-protocol.h"
+
+namespace ozonewayland {
+
+XDGShellSurface::XDGShellSurface()
+    : WaylandShellSurface(),
+      xdg_surface_(NULL),
+      xdg_popup_(NULL),
+      maximized_(false) {
+}
+
+XDGShellSurface::~XDGShellSurface() {
+  if (xdg_surface_)
+    xdg_surface_destroy(xdg_surface_);
+  if (xdg_popup_)
+    xdg_popup_destroy(xdg_popup_);
+}
+
+void XDGShellSurface::InitializeShellSurface(WaylandWindow* window) {
+  DCHECK(!xdg_surface_);
+  WaylandDisplay* display = WaylandDisplay::GetInstance();
+  DCHECK(display);
+  WaylandShell* shell = WaylandDisplay::GetInstance()->GetShell();
+  DCHECK(shell && shell->GetXDGShell());
+  xdg_surface_ = xdg_shell_get_xdg_surface(shell->GetXDGShell(),
+                                           GetWLSurface());
+
+  static const xdg_surface_listener xdg_surface_listener = {
+    XDGShellSurface::HandlePing,
+    XDGShellSurface::HandleConfigure,
+  };
+
+  xdg_surface_add_listener(xdg_surface_,
+                           &xdg_surface_listener,
+                           window);
+
+  DCHECK(xdg_surface_);
+}
+
+void XDGShellSurface::UpdateShellSurface(WaylandWindow::ShellType type,
+                                         WaylandShellSurface* shell_parent,
+                                         unsigned x,
+                                         unsigned y) {
+  switch (type) {
+  case WaylandWindow::TOPLEVEL: {
+    if (maximized_) {
+      xdg_surface_unset_maximized(xdg_surface_);
+      maximized_ = false;
+    }
+    break;
+  }
+  case WaylandWindow::POPUP: {
+    WaylandDisplay* display = WaylandDisplay::GetInstance();
+    WaylandInputDevice* input_device = display->PrimaryInput();
+    wl_surface* surface = GetWLSurface();
+    wl_surface* parent_surface = shell_parent->GetWLSurface();
+    xdg_popup_ = xdg_shell_get_xdg_popup(display->GetShell()->GetXDGShell(),
+                                         surface,
+                                         parent_surface,
+                                         input_device->GetInputSeat(),
+                                         display->GetSerial(),
+                                         x,
+                                         y,
+                                         0);
+    static const xdg_popup_listener xdg_popup_listener = {
+      XDGShellSurface::HandlePopupPing,
+      XDGShellSurface::HandlePopupPopupDone
+    };
+    xdg_popup_add_listener(xdg_popup_,
+                           &xdg_popup_listener,
+                           NULL);
+    DCHECK(xdg_popup_);
+    break;
+  }
+  case WaylandWindow::FULLSCREEN:
+    xdg_surface_set_fullscreen(xdg_surface_);
+    break;
+  case WaylandWindow::CUSTOM:
+      NOTREACHED() << "Unsupported shell type: " << type;
+    break;
+    default:
+      break;
+  }
+
+  WaylandShellSurface::FlushDisplay();
+}
+
+void XDGShellSurface::SetWindowTitle(const base::string16& title) {
+  xdg_surface_set_title(xdg_surface_, UTF16ToUTF8(title).c_str());
+  WaylandShellSurface::FlushDisplay();
+}
+
+void XDGShellSurface::Maximize() {
+  xdg_surface_set_maximized(xdg_surface_);
+  maximized_ = true;
+  WaylandShellSurface::FlushDisplay();
+}
+
+void XDGShellSurface::Minimize() {
+  xdg_surface_set_minimized(xdg_surface_);
+}
+
+void XDGShellSurface::HandleConfigure(void* data,
+                                 struct xdg_surface* xdg_surface,
+                                 uint32_t edges,
+                                 int32_t width,
+                                 int32_t height) {
+  WaylandShellSurface::WindowResized(data, width, height);
+}
+
+void XDGShellSurface::HandlePing(void* data,
+                            struct xdg_surface* xdg_surface,
+                            uint32_t serial) {
+  xdg_surface_pong(xdg_surface, serial);
+}
+
+void XDGShellSurface::HandlePopupPopupDone(void* data,
+                                      struct xdg_popup* xdg_popup,
+                                      uint32_t serial) {
+  WaylandShellSurface::PopupDone();
+}
+
+void XDGShellSurface::HandlePopupPing(void* data,
+                                 struct xdg_popup* xdg_popup,
+                                 uint32_t serial) {
+  xdg_popup_pong(xdg_popup, serial);
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/shell/xdg_shell_surface.h
@@ -0,0 +1,58 @@
+// Copyright 2014 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_SHELL_XDG_SURFACE_H_
+#define OZONE_WAYLAND_SHELL_XDG_SURFACE_H_
+
+#include "ozone/wayland/shell/shell_surface.h"
+
+struct xdg_surface;
+struct xdg_popup;
+
+namespace ozonewayland {
+
+class WaylandSurface;
+class WaylandWindow;
+
+class XDGShellSurface : public WaylandShellSurface {
+ public:
+  XDGShellSurface();
+  virtual ~XDGShellSurface();
+
+  virtual void InitializeShellSurface(WaylandWindow* window) override;
+  virtual void UpdateShellSurface(WaylandWindow::ShellType type,
+                                  WaylandShellSurface* shell_parent,
+                                  unsigned x,
+                                  unsigned y) override;
+  virtual void SetWindowTitle(const base::string16& title) override;
+  virtual void Maximize() override;
+  virtual void Minimize() override;
+
+  static void HandleConfigure(void* data,
+                              struct xdg_surface* xdg_surface,
+                              uint32_t edges,
+                              int32_t width,
+                              int32_t height);
+  static void HandlePing(void* data,
+                         struct xdg_surface* shell_surface,
+                         uint32_t serial);
+
+  static void HandlePopupPopupDone(void* data,
+                                   struct xdg_popup* xdg_popup,
+                                   uint32_t serial);
+  static void HandlePopupPing(void* data,
+                              struct xdg_popup* xdg_popup,
+                              uint32_t serial);
+
+ private:
+  xdg_surface* xdg_surface_;
+  xdg_popup* xdg_popup_;
+  bool maximized_;
+  DISALLOW_COPY_AND_ASSIGN(XDGShellSurface);
+};
+
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_SHELL_XDG_SURFACE_H_
--- /dev/null
+++ b/ozone/wayland/wayland.gyp
@@ -0,0 +1,120 @@
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Copyright 2013 Intel Corporation. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'variables': {
+    'variables':  {
+      'enable_ozone_wayland_vkb%': 0,
+      'enable_xdg_shell%': 0,
+    },
+    'enable_ozone_wayland_vkb%': '<(enable_ozone_wayland_vkb)',
+    'enable_xdg_shell%': '<(enable_xdg_shell)',
+    'conditions': [
+      ['sysroot!=""', {
+        'pkg-config': '../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)"',
+      }, {
+        'pkg-config': 'pkg-config'
+      }],
+    ],
+  },
+
+  'targets': [
+    {
+      'target_name': 'wayland_toolkit',
+      'type': 'static_library',
+      'variables': {
+        'WAYLAND_VERSION': '1.7.0',
+        'MESA_VERSION': '9.1.3',
+        'wayland_packages': [
+          'egl >= <(MESA_VERSION)',
+          'wayland-client = <(WAYLAND_VERSION)',
+          'wayland-cursor = <(WAYLAND_VERSION)',
+          'wayland-egl >= <(MESA_VERSION)',
+          'weston = <(WAYLAND_VERSION)',
+          'xkbcommon',
+        ],
+      },
+      'cflags': [
+        '<!@(<(pkg-config) --cflags <(wayland_packages))',
+      ],
+      'direct_dependent_settings': {
+        'cflags': [
+          '<!@(<(pkg-config) --cflags <(wayland_packages))',
+        ],
+      },
+      'link_settings': {
+        'ldflags': [
+          '<!@(<(pkg-config) --libs-only-L --libs-only-other <(wayland_packages))',
+        ],
+        'libraries': [
+          '<!@(<(pkg-config) --libs-only-l <(wayland_packages))',
+        ],
+      },
+      'dependencies': [
+        '../../base/base.gyp:base',
+      ],
+      'include_dirs': [
+        '../..',
+        '<(DEPTH)/third_party/khronos',
+      ],
+      'sources': [
+        'display.cc',
+        'display.h',
+        'display_poll_thread.cc',
+        'display_poll_thread.h',
+        'input_device.cc',
+        'input_device.h',
+        'proxy_display.cc',
+        'proxy_display.h',
+        'screen.cc',
+        'screen.h',
+        'window.cc',
+        'window.h',
+        'egl/egl_window.cc',
+        'egl/egl_window.h',
+        'egl/surface_ozone_wayland.cc',
+        'egl/surface_ozone_wayland.h',
+        'input/cursor.cc',
+        'input/cursor.h',
+        'input/keyboard.cc',
+        'input/keyboard.h',
+        'input/keyboard_engine_xkb.h',
+        'input/keyboard_engine_xkb.cc',
+        'input/pointer.cc',
+        'input/pointer.h',
+        'input/text_input.h',
+        'input/text_input.cc',
+        'input/text-protocol.c',
+        'input/text-client-protocol.h',
+        'input/touchscreen.cc',
+        'input/touchscreen.h',
+        'shell/shell.cc',
+        'shell/shell.h',
+        'shell/shell_surface.h',
+        'shell/shell_surface.cc',
+        'shell/wl_shell_surface.cc',
+        'shell/wl_shell_surface.h',
+      ],
+      'conditions': [
+        ['<(enable_ozone_wayland_vkb)==1', {
+          'defines': [
+            'ENABLE_OZONE_WAYLAND_VKB',
+          ],
+        }],
+        ['<(enable_xdg_shell)==1', {
+          'defines': [
+            'ENABLE_XDG_SHELL',
+          ],
+          'sources': [
+            'shell/xdg_shell_surface.cc',
+            'shell/xdg_shell_surface.h',
+            'shell/xdg-shell-protocol.c',
+            'shell/xdg-shell-client-protocol.h',
+          ],
+        }],
+      ],
+    },
+  ]
+}
--- /dev/null
+++ b/ozone/wayland/window.cc
@@ -0,0 +1,116 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ozone/wayland/window.h"
+
+#include "base/logging.h"
+#include "ozone/wayland/display.h"
+#include "ozone/wayland/egl/egl_window.h"
+#include "ozone/wayland/input_device.h"
+#include "ozone/wayland/shell/shell.h"
+#include "ozone/wayland/shell/shell_surface.h"
+
+namespace ozonewayland {
+
+WaylandWindow::WaylandWindow(unsigned handle) : shell_surface_(NULL),
+    window_(NULL),
+    type_(None),
+    handle_(handle),
+    allocation_(gfx::Rect(0, 0, 1, 1)) {
+  LOG(ERROR) << "ozonewayland::WaylandWindow::WaylandWindow";
+}
+
+WaylandWindow::~WaylandWindow() {
+  delete window_;
+  delete shell_surface_;
+}
+
+void WaylandWindow::SetShellAttributes(ShellType type) {
+  if (type_ == type)
+    return;
+
+  if (!shell_surface_) {
+    shell_surface_ =
+        WaylandDisplay::GetInstance()->GetShell()->CreateShellSurface(this);
+  }
+
+  type_ = type;
+  shell_surface_->UpdateShellSurface(type_, NULL, 0, 0);
+}
+
+void WaylandWindow::SetShellAttributes(ShellType type,
+                                       WaylandShellSurface* shell_parent,
+                                       unsigned x,
+                                       unsigned y) {
+  DCHECK(shell_parent && (type == POPUP));
+
+  if (!shell_surface_) {
+    shell_surface_ =
+        WaylandDisplay::GetInstance()->GetShell()->CreateShellSurface(this);
+    WaylandInputDevice* input = WaylandDisplay::GetInstance()->PrimaryInput();
+    input->SetGrabWindowHandle(handle_, 0);
+  }
+
+  type_ = type;
+  shell_surface_->UpdateShellSurface(type_, shell_parent, x, y);
+}
+
+void WaylandWindow::SetWindowTitle(const base::string16& title) {
+  shell_surface_->SetWindowTitle(title);
+}
+
+void WaylandWindow::Maximize() {
+  if (type_ != FULLSCREEN)
+    shell_surface_->Maximize();
+}
+
+void WaylandWindow::Minimize() {
+  shell_surface_->Minimize();
+}
+
+void WaylandWindow::Restore() {
+  // If window is created as fullscreen, we don't set/restore any window states
+  // like Maximize etc.
+  if (type_ != FULLSCREEN)
+    shell_surface_->UpdateShellSurface(type_, NULL, 0, 0);
+}
+
+void WaylandWindow::SetFullscreen() {
+  if (type_ != FULLSCREEN)
+    shell_surface_->UpdateShellSurface(FULLSCREEN, NULL, 0, 0);
+}
+
+void WaylandWindow::RealizeAcceleratedWidget() {
+  if (!shell_surface_) {
+    LOG(ERROR) << "Shell type not set. Setting it to TopLevel";
+    SetShellAttributes(TOPLEVEL);
+  }
+
+  if (!window_)
+    window_ = new EGLWindow(shell_surface_->GetWLSurface(),
+                            allocation_.width(),
+                            allocation_.height());
+}
+
+wl_egl_window* WaylandWindow::egl_window() const {
+  DCHECK(window_);
+  return window_->egl_window();
+}
+
+void WaylandWindow::Resize(unsigned width, unsigned height) {
+  if ((allocation_.width() == width) && (allocation_.height() == height))
+    return;
+
+  allocation_ = gfx::Rect(allocation_.x(), allocation_.y(), width, height);
+  if (!shell_surface_ || !window_)
+    return;
+
+  window_->Resize(width, height);
+  WaylandDisplay* display = WaylandDisplay::GetInstance();
+  DCHECK(display);
+  display->FlushDisplay();
+}
+
+}  // namespace ozonewayland
--- /dev/null
+++ b/ozone/wayland/window.h
@@ -0,0 +1,73 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Copyright 2013 Intel Corporation. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef OZONE_WAYLAND_WINDOW_H_
+#define OZONE_WAYLAND_WINDOW_H_
+
+#include <wayland-client.h>
+
+#include "base/strings/string16.h"
+#include "ui/gfx/geometry/rect.h"
+
+namespace ozonewayland {
+
+class WaylandShellSurface;
+class EGLWindow;
+struct wl_egl_window;
+
+typedef unsigned WaylandWindowId;
+
+class WaylandWindow {
+ public:
+  enum ShellType {
+    None,
+    TOPLEVEL,
+    FULLSCREEN,
+    POPUP,
+    CUSTOM
+  };
+
+  // Creates a window and maps it to handle.
+  explicit WaylandWindow(unsigned handle);
+  ~WaylandWindow();
+
+  void SetShellAttributes(ShellType type);
+  void SetShellAttributes(ShellType type,
+                          WaylandShellSurface* shell_parent,
+                          unsigned x,
+                          unsigned y);
+  void SetWindowTitle(const base::string16& title);
+  void Maximize();
+  void Minimize();
+  void Restore();
+  void SetFullscreen();
+
+  ShellType Type() const { return type_; }
+  unsigned Handle() const { return handle_; }
+  WaylandShellSurface* ShellSurface() const { return shell_surface_; }
+
+  void RealizeAcceleratedWidget();
+
+  // Returns pointer to egl window associated with the window.
+  // The WaylandWindow object owns the pointer.
+  wl_egl_window* egl_window() const;
+
+  // Immediately Resizes window and flushes Wayland Display.
+  void Resize(unsigned width, unsigned height);
+  gfx::Rect GetBounds() const { return allocation_; }
+
+ private:
+  WaylandShellSurface* shell_surface_;
+  EGLWindow* window_;
+
+  ShellType type_;
+  unsigned handle_;
+  gfx::Rect allocation_;
+  DISALLOW_COPY_AND_ASSIGN(WaylandWindow);
+};
+
+}  // namespace ozonewayland
+
+#endif  // OZONE_WAYLAND_WINDOW_H_
--- a/ui/views/views.gyp
+++ b/ui/views/views.gyp
@@ -4,6 +4,7 @@
 {
   'variables': {
     'chromium_code': 1,
+    'external_ozone_views_files': [],
     # Sources lists shared with GN build.
     'views_sources': [
       'accessibility/native_view_accessibility.cc',
@@ -680,6 +681,9 @@
           'msvs_disabled_warnings': [ 4267, ],
         }],
         ['use_ozone==1', {
+          'sources': [
+            '<@(external_ozone_views_files)',
+          ],
           'dependencies': [
             '../ozone/ozone.gyp:ozone',
           ],
